{"version":3,"sources":["../../node_modules/base-x/src/index.js","../../node_modules/index.ts","../../src/index.ts","../../src/Address/index.ts","../../src/Address/constants.ts","../../src/Address/imports.ts","../../node_modules/@noble/hashes/src/_assert.ts","../../node_modules/@noble/hashes/src/_u64.ts","../../node_modules/@noble/hashes/src/utils.ts","../../node_modules/@noble/hashes/src/sha3.ts","../../node_modules/@noble/hashes/src/_blake2.ts","../../node_modules/@noble/hashes/src/blake2b.ts","../../src/Address/ethereum.ts","../../src/Address/substrate.ts","../../src/Address/crossAccountId.ts","../../src/Utils/coin.ts","../../node_modules/src/coin.ts"],"sourcesContent":["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","export const HexString = {\n  fromArray: (bytes: number[] | Uint8Array) => {\n    if (!(bytes instanceof Uint8Array) && !Array.isArray(bytes)) {\n      throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes}, ${bytes}`)\n    }\n    const arr = bytes instanceof Uint8Array ? Array.from(bytes) : bytes\n    return '0x' + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n  },\n  fromU8a: (bytes: number[] | Uint8Array) => HexString.fromArray(bytes),\n  toArray(hexString: string): number[] {\n    if (typeof hexString !== 'string') {\n      throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`)\n    }\n\n    const str: string = hexString.startsWith('0x') ? hexString.slice(2) : hexString\n    const pairs: RegExpMatchArray = str.match(/.{1,2}/g) || []\n    return pairs.map((byte) => parseInt(byte, 16))\n  },\n  toU8a: (hexString: string): Uint8Array => Uint8Array.from(HexString.toArray(hexString)),\n}\n\n\nexport const Utf8 = {\n  stringToU8a(str: string): Uint8Array {\n    const u8a = new Uint8Array(Utf8.lengthInBytes(str))\n\n    let offset = 0\n    const start = offset\n    let c1: number = 0 // character 1\n    let c2: number = 0 // character 2\n\n    let i = 0\n\n    while (i < str.length) {\n      c1 = str.charCodeAt(i)\n      if (c1 < 128) {\n        u8a[offset++] = c1\n      } else if (c1 < 2048) {\n        u8a[offset++] = c1 >> 6 | 192\n        u8a[offset++] = c1 & 63 | 128\n      } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = str.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n        c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n        ++i\n        u8a[offset++] = c1 >> 18 | 240\n        u8a[offset++] = c1 >> 12 & 63 | 128\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      } else {\n        u8a[offset++] = c1 >> 12 | 224\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      }\n\n      i += 1\n    }\n    const diff = offset - start\n\n    return u8a\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf8.stringToU8a(str))\n  },\n  u8aToString(u8a: Uint8Array): string {\n    let start = 0\n    let end = u8a.length\n\n    if (end - start < 1) {\n      return \"\"\n    }\n\n    let str = \"\"\n\n    let i = start\n\n    while (i < end) {\n      const t = u8a[i++]\n      if (t <= 0x7F) {\n        str += String.fromCharCode(t);\n      } else if (t >= 0xC0 && t < 0xE0) {\n        str += String.fromCharCode((t & 0x1F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xE0 && t < 0xF0) {\n        str += String.fromCharCode((t & 0xF) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xF0) {\n        const t2 = ((t & 7) << 18 | (u8a[i++] & 0x3F) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F) - 0x10000\n        str += String.fromCharCode(0xD800 + (t2 >> 10))\n        str += String.fromCharCode(0xDC00 + (t2 & 0x3FF))\n      }\n    }\n\n    return str\n  },\n  numberArrayToString(arr: number[] | Uint8Array): string {\n    return Utf8.u8aToString(Uint8Array.from(arr))\n  },\n  stringToHexString(str: string): string {\n    return HexString.fromU8a(Utf8.stringToU8a(str))\n  },\n  hexStringToString(hexString: string): string {\n    return Utf8.u8aToString(HexString.toU8a(hexString))\n  },\n  lengthInBytes(str: string): number {\n    let len = 0\n    let c = 0\n\n    let i = 0\n\n    while (i < str.length) {\n      c = str.charCodeAt(i) as number\n      if (c < 128) {\n        len += 1\n      } else if (c < 2048) {\n        len += 2\n      } else if ((c & 0xFC00) === 0xD800 && ((str.charCodeAt(i + 1) as number) & 0xFC00) === 0xDC00) {\n        ++i\n        len += 4\n      } else {\n        len += 3\n      }\n\n      i += 1\n    }\n    return len\n  },\n}\n\n\nexport const Utf16 = {\n  stringToU16a(str: string): Uint16Array {\n    const u16arr = new Uint16Array(Utf16.lengthInBytes(str))\n\n    let i = 0\n\n    while (i < str.length) {\n      let cp = str.codePointAt(i) as number\n\n      if (cp <= 0xFFFF) {\n        u16arr[i++] = cp\n      } else {\n        cp -= 0x10000\n        u16arr[i++] = (cp >> 10) + 0xD800\n        u16arr[i++] = (cp % 0x400) + 0xDC00\n      }\n    }\n    return u16arr\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf16.stringToU16a(str))\n  },\n  numberArrayToString(arr: number[] | Uint16Array) {\n    let i = 0\n    const len = arr.length\n    let s = ''\n\n    while (i < len - 1) {\n      const c1 = arr[i]\n      const c2 = arr[i + 1]\n\n      if (c1 >= 0xD800 && c1 <= 0xDFFF) {\n        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {\n          s += String.fromCodePoint((c1 - 0xD800) * 0x400 + c2 - 0xDC00 + 0x10000)\n          i += 2\n        } else {\n          throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`)\n        }\n      } else {\n        s += String.fromCodePoint(c1)\n        i += 1\n      }\n    }\n\n    if (i < len) {\n      s += String.fromCodePoint(arr[len - 1])\n    }\n\n    return s\n  },\n  u16aToString(arr: number[] | Uint16Array): string {\n    return Utf16.numberArrayToString(arr)\n  },\n  lengthInBytes(str: string): number {\n    let i = 0\n\n    while (i < str.length) {\n      i += (str.codePointAt(i) as number <= 0xFFFF) ? 1 : 2\n    }\n\n    return i\n  },\n}\n\nexport const UtfHelpers = {\n  HexString,\n  Utf8,\n  Utf16,\n}\n","import * as Address from './Address'\nimport * as constants from './Address/constants'\nimport * as StringUtils from 'utf-helpers'\nimport * as CoinUtils from './Utils/coin'\n\nexport {\n  Address,\n  StringUtils,\n  constants,\n  CoinUtils,\n}\n\nexport const {\n  HexString,\n  Utf8,\n  Utf16,\n} = StringUtils\n\nexport const HexUtils = StringUtils.HexString\n\nexport {Coin} from './Utils/coin'\nexport type {ICoin, ICoinFormats} from './Utils/coin'\n\nexport * from './types'\n","import {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from './constants'\n\nimport {\n  addressToEvm, compareSubstrateAddresses,\n  decodeSubstrateAddress, encodeSubstrateAddress,\n  evmToAddress,\n  normalizeSubstrateAddress\n} from './substrate'\n\nimport {\n  collectionIdAndTokenIdToNestingAddress,\n  collectionIdToEthAddress, compareEthereumAddresses, DWORDHexString,\n  ethAddressToCollectionId,\n  nestingAddressToCollectionIdAndTokenId,\n  normalizeEthereumAddress\n} from './ethereum'\nimport {\n  CrossAccountId, CrossAccountIdUncapitalized,\n  EthAddressObj, EthAddressObjUncapitalized,\n  SubAddressObj, SubAddressObjUncapitalized,\n  EnhancedCrossAccountId, EthCrossAccountId,\n} from '../types'\nimport {\n  addressInAnyFormToEnhancedCrossAccountId,\n  guessAddressAndExtractCrossAccountIdSafe,\n  guessAddressAndExtractCrossAccountIdUnsafe,\n  substrateOrMirrorIfEthereum\n} from './crossAccountId'\n\nimport * as algorithms from './imports'\nimport * as constants from './constants'\n\nexport {constants, algorithms}\n\nconst ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nconst SUB_PUBLIC_KEY_REGEX = /^0x[a-fA-F0-9]{64}$/\n\nexport type DecodeSubstrateAddressResult = {\n  u8a: Uint8Array\n  hex: string\n  bigint: bigint\n  ss58Prefix: number\n}\n\nexport const validate = {\n  substrateAddress: (address: string) => {\n    decodeSubstrateAddress(address)\n    return true\n  },\n  ethereumAddress: (address: string) => {\n    if (!is.ethereumAddress(address)) {\n      throw new Error(`address \"${address}\" is not valid ethereum address`)\n    }\n    return true\n  },\n  substratePublicKey: (address: string) => {\n    if (!is.substratePublicKey(address)) {\n      throw new Error(`address \"${address}\" is not valid substrate public key`)\n    }\n    return true\n  },\n  collectionAddress: (address: string) => {\n    if (!is.collectionAddress(address)) {\n      throw new Error(`address ${address} is not a collection address`)\n    }\n    return true\n  },\n  nestingAddress: (address: string) => {\n    if (!is.nestingAddress(address)) {\n      throw new Error(`address ${address} is not a nesting address`)\n    }\n    return true\n  },\n  collectionId: (collectionId: number) => {\n    if (!is.collectionId(collectionId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n  tokenId: (tokenId: number) => {\n    if (!is.tokenId(tokenId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n}\n\nexport const is = {\n  substrateAddress: (address: string): boolean => {\n    try {\n      decodeSubstrateAddress(address)\n      return !is.substratePublicKey(address)\n    } catch {\n      return false\n    }\n  },\n  ethereumAddress: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 42 && !!address.match(ETH_ADDRESS_REGEX)\n  },\n  substratePublicKey: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 66 && !!address.match(SUB_PUBLIC_KEY_REGEX)\n  },\n\n  collectionAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(COLLECTION_ADDRESS_PREFIX)\n  },\n  nestingAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(NESTING_PREFIX)\n  },\n\n  collectionId: (collectionId: number): boolean => {\n    return !(typeof collectionId !== 'number' || isNaN(collectionId) || collectionId < 0 || collectionId > 0xffffffff)\n  },\n  tokenId: (tokenId: number): boolean => {\n    return !(typeof tokenId !== 'number' || isNaN(tokenId) || tokenId < 0 || tokenId > 0xffffffff)\n  },\n\n  crossAccountId(obj: any): obj is CrossAccountId {\n    return is.substrateAddressObject(obj) || is.ethereumAddressObject(obj)\n  },\n  crossAccountIdUncapitalized(obj: any): obj is CrossAccountIdUncapitalized {\n    return is.substrateAddressObjectUncapitalized(obj) || is.ethereumAddressObjectUncapitalized(obj)\n  },\n  substrateAddressObject(obj: any): obj is SubAddressObj {\n    return typeof obj === 'object' && typeof obj?.Substrate === 'string' && is.substrateAddress(obj.Substrate)\n  },\n  ethereumAddressObject(obj: any): obj is EthAddressObj {\n    return typeof obj === 'object' && typeof obj?.Ethereum === 'string' && is.ethereumAddress(obj.Ethereum)\n  },\n  substrateAddressObjectUncapitalized(obj: any): obj is SubAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.substrate === 'string' && is.substrateAddress(obj.substrate)\n  },\n  ethereumAddressObjectUncapitalized(obj: any): obj is EthAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.ethereum === 'string' && is.ethereumAddress(obj.ethereum)\n  },\n  substrateAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.substrateAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.substrateAddressObject(address) || is.substrateAddressObjectUncapitalized(address))\n      )\n  },\n  ethereumAddressInAnyForm(address: any): address is string | EthAddressObj | EthAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.ethereumAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.ethereumAddressObject(address) || is.ethereumAddressObjectUncapitalized(address))\n      )\n  },\n  validAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized | EthAddressObj | EthAddressObjUncapitalized {\n    return is.ethereumAddressInAnyForm(address) || is.substrateAddressInAnyForm(address)\n  }\n}\n\nexport const collection = {\n  idToAddress: collectionIdToEthAddress,\n  addressToId: ethAddressToCollectionId,\n}\nexport const nesting = {\n  idsToAddress: collectionIdAndTokenIdToNestingAddress,\n  addressToIds: nestingAddressToCollectionIdAndTokenId,\n}\n\nexport const extract = {\n  address: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressForScanNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string\n  },\n  addressForScanNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string : null\n  },\n\n\n  crossAccountId: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n  },\n  crossAccountIdSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n  },\n\n  crossAccountIdNormalized: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n  },\n  crossAccountIdNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n  },\n\n  crossAccountIdUncapitalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n  crossAccountIdUncapitalizedNormalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalizedNormalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n\n  substrateOrMirrorIfEthereum: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n  },\n  substrateOrMirrorIfEthereumSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  substrateOrMirrorIfEthereumNormalized: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n  },\n  substrateOrMirrorIfEthereumNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n    } catch {\n      return null\n    }\n  },\n\n  substratePublicKey: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    if (!crossAccountId.Substrate) {\n      throw new Error('Address is not a substrate address')\n    }\n    return substrate.decode(crossAccountId.Substrate).hex\n  },\n  substratePublicKeySafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return extract.substratePublicKey(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  enhancedCrossAccountId: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n    return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n  },\n  enhancedCrossAccountIdSafe: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId | null => {\n    try {\n      return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n    } catch {\n      return null\n    }\n  },\n\n  ethCrossAccountId: (addressInAnyForm: string | object): EthCrossAccountId => {\n    const addressEnhanced = addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm)\n    if (addressEnhanced.Substrate) {\n      return {\n        eth: '0x0000000000000000000000000000000000000000',\n        sub: addressEnhanced.substratePublicKey,\n      }\n    } else {\n      return {\n        eth: addressEnhanced.address,\n        sub: '0x00',\n      }\n    }\n  },\n  ethCrossAccountIdSafe: (addressInAnyForm: string | object): EthCrossAccountId | null => {\n    try {\n      return extract.ethCrossAccountId(addressInAnyForm)\n    } catch {\n      return null\n    }\n  }\n}\n\nexport const mirror = {\n  substrateToEthereum: addressToEvm,\n  ethereumToSubstrate: evmToAddress,\n}\n\nexport const normalize = {\n  substrateAddress: normalizeSubstrateAddress,\n  ethereumAddress: normalizeEthereumAddress,\n}\n\nexport const compare = {\n  substrateAddresses: compareSubstrateAddresses,\n  ethereumAddresses: compareEthereumAddresses,\n}\n\nexport const substrate = {\n  encode: encodeSubstrateAddress,\n  decode: decodeSubstrateAddress,\n  compare: compareSubstrateAddresses,\n}\n\nexport const Address = {\n  constants,\n  algorithms,\n  is,\n  validate,\n  collection,\n  nesting,\n  extract,\n  mirror,\n  normalize,\n  compare,\n  substrate,\n  utils: {\n    DWORDHexString,\n  }\n}\n","export const STATIC_ADDRESSES = <const>{\r\n  contractHelpers: '0x842899ECF380553E8a4de75bF534cdf6fBF64049',\r\n  collectionHelpers: '0x6C4E9fE1AE37a41E93CEE429e8E1881aBdcbb54F',\r\n}\r\nexport const NESTING_PREFIX = <const>'0xf8238ccfff8ed887463fd5e0'\r\nexport const COLLECTION_ADDRESS_PREFIX = <const>'0x17c4e6453cc49aaaaeaca894e6d9683e'\r\n","import basex from 'base-x'\r\nimport {keccak_256} from '@noble/hashes/sha3'\r\nimport {blake2b} from '@noble/hashes/blake2b'\r\n\r\nconst BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\r\nconst BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\nconst base58 = basex(BASE58_ALPHABET)\r\nconst base64 = basex(BASE64_ALPHABET)\r\n\r\nexport {keccak_256, blake2b, base58, base64, basex}\r\n","function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    exists(this, false);\n    bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n","import { number, exists, output } from './_assert.js';\nimport { Hash, Input, toBytes, u32 } from './utils.js';\n\n// Blake is based on ChaCha permutation.\n\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexport const SIGMA = /* @__PURE__ */ new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\n\nexport type BlakeOpts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected length: number = 0;\n  protected pos: number = 0;\n  protected finished = false;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    opts: BlakeOpts = {},\n    keyLen: number,\n    saltLen: number,\n    persLen: number\n  ) {\n    super();\n    number(blockLen);\n    number(outputLen);\n    number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen)\n      throw new Error(`salt must be ${saltLen} byte long or undefined`);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n      throw new Error(`personalization must be ${persLen} byte long or undefined`);\n    this.buffer32 = u32((this.buffer = new Uint8Array(blockLen)));\n  }\n  update(data: Input) {\n    exists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        this.compress(buffer32, 0, false);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    this.compress(buffer32, 0, true);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = v));\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}\n","import { BLAKE2, BlakeOpts, SIGMA } from './_blake2.js';\nimport u64 from './_u64.js';\nimport { toBytes, u32, wrapConstructorWithOpts } from './utils.js';\n\n// Same as SHA-512 but LE\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n]);\n// Temporary buffer\nconst BUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore\n  let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore\n  let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore\n  let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);\n  (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);\n  (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);\n  (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);\n}\n\nfunction G2(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore\n  let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore\n  let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore\n  let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);\n  (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);\n  (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);\n  (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);\n}\n\nclass BLAKE2b extends BLAKE2<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = IV[0] | 0;\n  private v0h = IV[1] | 0;\n  private v1l = IV[2] | 0;\n  private v1h = IV[3] | 0;\n  private v2l = IV[4] | 0;\n  private v2h = IV[5] | 0;\n  private v3l = IV[6] | 0;\n  private v3h = IV[7] | 0;\n  private v4l = IV[8] | 0;\n  private v4h = IV[9] | 0;\n  private v5l = IV[10] | 0;\n  private v5h = IV[11] | 0;\n  private v6l = IV[12] | 0;\n  private v6h = IV[13] | 0;\n  private v7l = IV[14] | 0;\n  private v7h = IV[15] | 0;\n\n  constructor(opts: BlakeOpts = {}) {\n    super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);\n    const keyLength = opts.key ? opts.key.length : 0;\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (opts.salt) {\n      const salt = u32(toBytes(opts.salt));\n      this.v4l ^= salt[0];\n      this.v4h ^= salt[1];\n      this.v5l ^= salt[2];\n      this.v5h ^= salt[3];\n    }\n    if (opts.personalization) {\n      const pers = u32(toBytes(opts.personalization));\n      this.v6l ^= pers[0];\n      this.v6h ^= pers[1];\n      this.v7l ^= pers[2];\n      this.v7h ^= pers[3];\n    }\n    if (opts.key) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(toBytes(opts.key));\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let {v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h} = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ) {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean) {\n    this.get().forEach((v, i) => (BUF[i] = v)); // First half from state.\n    BUF.set(IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BUF[24] = IV[8] ^ l; // Low word of the offset.\n    BUF[25] = IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BUF[28] = ~BUF[28];\n      BUF[29] = ~BUF[29];\n    }\n    let j = 0;\n    const s = SIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BUF[0] ^ BUF[16];\n    this.v0h ^= BUF[1] ^ BUF[17];\n    this.v1l ^= BUF[2] ^ BUF[18];\n    this.v1h ^= BUF[3] ^ BUF[19];\n    this.v2l ^= BUF[4] ^ BUF[20];\n    this.v2h ^= BUF[5] ^ BUF[21];\n    this.v3l ^= BUF[6] ^ BUF[22];\n    this.v3h ^= BUF[7] ^ BUF[23];\n    this.v4l ^= BUF[8] ^ BUF[24];\n    this.v4h ^= BUF[9] ^ BUF[25];\n    this.v5l ^= BUF[10] ^ BUF[26];\n    this.v5h ^= BUF[11] ^ BUF[27];\n    this.v6l ^= BUF[12] ^ BUF[28];\n    this.v6h ^= BUF[13] ^ BUF[29];\n    this.v7l ^= BUF[14] ^ BUF[30];\n    this.v7h ^= BUF[15] ^ BUF[31];\n    BUF.fill(0);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.buffer32.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, salt, personalization\n */\nexport const blake2b = /* @__PURE__ */ wrapConstructorWithOpts<BLAKE2b, BlakeOpts>(\n  (opts) => new BLAKE2b(opts)\n);\n","import {HexString} from 'utf-helpers'\n\nimport {keccak_256} from \"./imports\"\nimport {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from \"./constants\"\nimport {is, validate} from \"./index\"\n\n\nexport const DWORDHexString = {\n  _checkU32: (num: number): number => {\n    if (typeof num !== 'number') throw new Error(`Passed number is not a number: ${typeof num}, ${num}`)\n    if (isNaN(num)) throw new Error(`Passed number is NaN: ${num}`)\n    if (num < 0) throw new Error(`Passed number is less than 0: ${num}`)\n    if (num > 0xFFFFFFFF) throw new Error(`Passed number is more than 2**32: ${num}`)\n    if (num !== Math.floor(num)) throw new Error(`Passed number is not an integer number: ${num}`)\n\n    return num\n  },\n  fromNumber: (n: number): string => {\n    return DWORDHexString._checkU32(n).toString(16).padStart(8, '0')\n  },\n  toNumber: (s: string): number => {\n    const num: number = parseInt(s, 16)\n\n    if (isNaN(num)) throw new Error(`Passed string is not hexadecimal: ${s}`)\n\n    return DWORDHexString._checkU32(num)\n  }\n}\n\n\nconst unsafeNormalizeEthereumAddress = (address: string) => {\n  const addr = address.toLowerCase().replace(/^0x/i, '')\n  const addressHash = HexString.fromU8a(keccak_256(addr)).replace(/^0x/i, '')\n\n  let checksumAddress = '0x'\n\n  for (let i = 0; i < addr.length; i++) {\n    checksumAddress += (parseInt(addressHash[i], 16) > 7)\n      ? addr[i].toUpperCase()\n      : addr[i]\n  }\n\n  return checksumAddress\n}\nexport const normalizeEthereumAddress = (address: string) => {\n  validate.ethereumAddress(address)\n  return unsafeNormalizeEthereumAddress(address)\n}\n\ntype EthAddressObj = { Ethereum: string }\nexport const compareEthereumAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as EthAddressObj).Ethereum || (address1 as any).ethereum) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as EthAddressObj).Ethereum || (address2 as any).ethereum) as string | undefined\n\n  if (!addr1 || !addr2 || !is.ethereumAddress(addr1) || !is.ethereumAddress(addr2)) {\n    return false\n  }\n  return addr1.toLowerCase() === addr2.toLowerCase()\n\n}\n\nexport const collectionIdToEthAddress = (collectionId: number): string => {\n  validate.collectionId(collectionId)\n  return unsafeNormalizeEthereumAddress(\n    COLLECTION_ADDRESS_PREFIX +\n    DWORDHexString.fromNumber(collectionId)\n  )\n}\nexport const ethAddressToCollectionId = (address: string): number => {\n  validate.collectionAddress(address)\n  return DWORDHexString.toNumber(address.slice(-8))\n}\n\nexport const collectionIdAndTokenIdToNestingAddress = (collectionId: number, tokenId: number): string => {\n  validate.collectionId(collectionId)\n  validate.tokenId(tokenId)\n\n  return unsafeNormalizeEthereumAddress(\n    NESTING_PREFIX +\n    DWORDHexString.fromNumber(collectionId) +\n    DWORDHexString.fromNumber(tokenId)\n  )\n}\n\nexport const nestingAddressToCollectionIdAndTokenId = (address: string): { collectionId: number, tokenId: number } => {\n  validate.nestingAddress(address)\n  return {\n    collectionId: DWORDHexString.toNumber(address.slice(-16, -8)),\n    tokenId: DWORDHexString.toNumber(address.slice(-8)),\n  }\n}\n","import {base58, blake2b} from './imports'\nimport {DecodeSubstrateAddressResult, validate, is} from './index'\nimport {normalizeEthereumAddress} from './ethereum'\nimport {HexString} from 'utf-helpers'\n\nconst blake2AsU8a = (u8a: Uint8Array, dkLen: 8 | 16 | 32 | 48 | 64 = 32): Uint8Array => {\n  return blake2b(u8a, {dkLen})\n}\n\nconst u8aConcat = (u8as: readonly Uint8Array[]): Uint8Array => {\n  let offset = 0\n\n  let length = 0\n\n  for (let i = 0; i < u8as.length; i++) {\n    length += u8as[i].length\n  }\n\n  const result = new Uint8Array(length)\n\n  for (let i = 0; i < u8as.length; i++) {\n    result.set(u8as[i], offset)\n    offset += u8as[i].length\n  }\n\n  return result\n}\n\n// strToU8a('SS58PRE')\nconst SS58_PREFIX = new Uint8Array([83, 83, 53, 56, 80, 82, 69])\n\nconst sshash = (data: Uint8Array): Uint8Array => {\n  return blake2AsU8a(u8aConcat([SS58_PREFIX, data]), 64);\n}\n\nconst checkAddressChecksum = (decoded: Uint8Array, ignoreChecksum: boolean = false): [boolean, number, number, number] => {\n  const ss58Length = (decoded[0] & 0b0100_0000) ? 2 : 1;\n  const ss58Decoded = ss58Length === 1\n    ? decoded[0]\n    : ((decoded[0] & 0x3f) << 2) | (decoded[1] >> 6) | ((decoded[1] & 0x3f) << 8);\n\n  // 32/33 bytes public + 2 bytes checksum + prefix\n  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);\n  const length = decoded.length - (isPublicKey ? 2 : 1);\n\n  let isValid = false\n\n  if (!ignoreChecksum) {\n    // calculate the hash and do the checksum byte checks\n    const hash = sshash(decoded.subarray(0, length));\n    isValid = (decoded[0] & 0x80) === 0 && ![46, 47].includes(decoded[0]) && (\n      isPublicKey\n        ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1]\n        : decoded[decoded.length - 1] === hash[0]\n    )\n  }\n\n  return [isValid, length, ss58Length, ss58Decoded];\n}\n\nexport const normalizeSubstrateAddress = (address: string, prefix: number = 42): string => {\n  return encodeSubstrateAddress(decodeSubstrateAddress(address).u8a, prefix)\n}\n\n\nexport function encodeSubstrateAddress(key: Uint8Array | string | bigint, ss58Format: number = 42): string {\n  const u8a: Uint8Array = typeof key === 'string'\n    ? HexString.toU8a(key)\n    : typeof key === 'bigint'\n      ? HexString.toU8a(key.toString(16))\n      : key\n\n  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {\n    throw new Error(`ss58Format is not valid, received ${typeof ss58Format} \"${ss58Format}\"`)\n  }\n\n  const allowedDecodedLengths = [1, 2, 4, 8, 32, 33]\n  if (!allowedDecodedLengths.includes(u8a.length)) {\n    throw new Error(`key length is not valid, received ${u8a.length}, valid values are ${allowedDecodedLengths.join(', ')}`)\n  }\n\n  const u8aPrefix = ss58Format < 64\n    ? new Uint8Array([ss58Format])\n    : new Uint8Array([\n      ((ss58Format & 0xfc) >> 2) | 0x40,\n      (ss58Format >> 8) | ((ss58Format & 0x03) << 6)\n    ])\n\n  const input = u8aConcat([u8aPrefix, u8a])\n\n  return base58.encode(\n    u8aConcat([\n      input,\n      sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)\n    ])\n  );\n}\n\nexport function decodeSubstrateAddress(address: string, ignoreChecksum?: boolean, ss58Format: number = -1): DecodeSubstrateAddressResult {\n  let realError: Error | null = null\n\n  try {\n    if (is.substratePublicKey(address)) {\n      return {\n        u8a: HexString.toU8a(address),\n        bigint: BigInt(address),\n        hex: address,\n        ss58Prefix: 42,\n      }\n    } else if (address.startsWith('0x')) {\n      throw new Error(`Invalid substrate address, received ${address}. Wrong or mangled public key?`)\n    }\n\n    const decoded = base58.decode(address);\n\n    const allowedEncodedLengths = [3, 4, 6, 10, 35, 36, 37, 38]\n\n    if (!allowedEncodedLengths.includes(decoded.length)) {\n      realError = new Error(`key length is not valid, decoded key length is ${decoded.length}, valid values are ${allowedEncodedLengths.join(', ')}`)\n      throw realError\n    }\n\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded, ignoreChecksum)\n\n    if (!ignoreChecksum && !isValid) {\n      realError = new Error(`Invalid decoded address checksum`)\n      throw realError\n    }\n    if (![-1, ss58Decoded].includes(ss58Format)) {\n      realError = new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`)\n      throw realError\n    }\n\n    const publicKey = decoded.slice(ss58Length, endPos)\n\n    const hex: string = HexString.fromU8a(publicKey)\n    return {\n      u8a: publicKey,\n      hex,\n      bigint: BigInt(hex),\n      ss58Prefix: ss58Decoded,\n    }\n  } catch (error) {\n    throw realError\n      ? realError\n      : new Error(`Decoding ${address}: ${(error as Error).message}`)\n  }\n}\n\ntype SubAddressObj = { Substrate: string }\nexport const compareSubstrateAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as SubAddressObj).Substrate || (address1 as any).substrate) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as SubAddressObj).Substrate || (address2 as any).substrate) as string | undefined\n\n  if (!addr1 || !addr2) {\n    return false\n  }\n\n  try {\n    const decoded1 = decodeSubstrateAddress(addr1)\n    const decoded2 = decodeSubstrateAddress(addr2)\n    return decoded1.bigint === decoded2.bigint\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addressToEvm = (address: string, ignoreChecksum?: boolean): string => {\n  const truncated = decodeSubstrateAddress(address, ignoreChecksum).u8a.subarray(0, 20)\n  return normalizeEthereumAddress(HexString.fromU8a(truncated))\n}\n\n// strToU8a('evm:')\nconst EVM_PREFIX_U8A = new Uint8Array([101, 118, 109, 58])\nexport const evmToAddress = (evmAddress: string, ss58Format: number = 42): string => {\n  validate.ethereumAddress(evmAddress)\n\n  const message = u8aConcat([EVM_PREFIX_U8A, HexString.toU8a(evmAddress)])\n\n  return encodeSubstrateAddress(blake2AsU8a(message), ss58Format)\n}\n","import {normalizeEthereumAddress} from './ethereum'\nimport {normalizeSubstrateAddress, decodeSubstrateAddress} from './substrate'\nimport {CrossAccountId, EnhancedCrossAccountId} from '../types'\nimport {is, mirror, validate} from './index'\n\nexport const guessAddressAndExtractCrossAccountIdUnsafe = (rawAddress: string | object, normalize: boolean = false): CrossAccountId => {\n  const address = rawAddress as any\n\n  if (typeof address === 'object') {\n    if (address.hasOwnProperty('eth') && address.hasOwnProperty('sub')) {\n      // bn.js value extraction for ethers.js\n      const subPublicKey = (address.sub.hasOwnProperty('_hex') && typeof address.sub._hex === 'string')\n        ? address.sub._hex\n        : address.sub\n      if (typeof subPublicKey !== 'string' || !subPublicKey.startsWith('0x')) {\n        throw new Error(`Substrate public key must be a hex string, got ${subPublicKey}`)\n      }\n\n      const subBigInt = BigInt(subPublicKey)\n      const ethBigInt = BigInt(address.eth)\n\n      if (!(Number(subBigInt === 0n) ^ Number(ethBigInt === 0n))) {\n        throw new Error(`One of the addresses must be 0, got eth ${address.eth} and substrate public key ${address.sub}.`)\n      }\n\n      // always normalize addresses from the EthCrossAccountId\n      if (subBigInt === 0n) {\n        return {Ethereum: normalizeEthereumAddress(address.eth)}\n      } else {\n        return {Substrate: normalizeSubstrateAddress(subPublicKey)}\n      }\n    } else if (address.hasOwnProperty('Substrate') || address.hasOwnProperty('substrate')) {\n      const substrateAddress = address.hasOwnProperty('Substrate') ? address.Substrate : address.substrate\n      if (is.substratePublicKey(substrateAddress)) {\n        return {Substrate: normalizeSubstrateAddress(substrateAddress)}\n      } else if (is.substrateAddress(substrateAddress)) {\n        return {Substrate: normalize ? normalizeSubstrateAddress(substrateAddress) : substrateAddress}\n      } else {\n        throw new Error(`Address ${substrateAddress} is not a valid Substrate address`)\n      }\n    } else if (address.hasOwnProperty('Ethereum') || address.hasOwnProperty('ethereum')) {\n      const ethereumAddress = address.hasOwnProperty('Ethereum') ? address.Ethereum : address.ethereum\n      validate.ethereumAddress(ethereumAddress)\n      return {Ethereum: normalize ? normalizeEthereumAddress(ethereumAddress) : ethereumAddress}\n    } else {\n      throw new Error(`Address ${address} is not a valid crossAccountId object (should contain \"Substrate\"/\"substrate\" or \"Ethereum\"/\"ethereum\" field) or EthCrossAccountId (should contain \"eth\" and \"sub\" fields)`)\n    }\n  }\n\n  if (typeof address === 'string') {\n    if (is.substrateAddress(address)) return {Substrate: normalize ? normalizeSubstrateAddress(address) : address}\n    else if (is.ethereumAddress(address)) return {Ethereum: normalize ? normalizeEthereumAddress(address) : address}\n    else if (is.substratePublicKey(address)) return {Substrate: normalizeSubstrateAddress(address)}\n    else {\n      throw new Error(`Address ${address} is not a valid Substrate or Ethereum address`)\n    }\n  }\n\n  throw new Error(`Address ${address} is not a string or object: ${typeof address}`)\n}\n\nexport const guessAddressAndExtractCrossAccountIdSafe = (address: string | object, normalize: boolean = false): CrossAccountId | null => {\n  try {\n    return guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  } catch {\n    return null\n  }\n}\n\nexport const substrateOrMirrorIfEthereum = (address: string | object, normalize: boolean = false): string => {\n  const addressObject = guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  return addressObject.Substrate\n    ? addressObject.Substrate\n    : mirror.ethereumToSubstrate(addressObject.Ethereum as string)\n}\n\nexport const addressInAnyFormToEnhancedCrossAccountId = (address: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n  const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(address)\n\n  if (crossAccountId.Ethereum) {\n    const normalized = normalizeEthereumAddress(crossAccountId.Ethereum)\n    return {\n      ...crossAccountId,\n      address: normalized,\n      addressSS58: normalized,\n      substratePublicKey: normalized,\n      isEthereum: true,\n      isSubstrate: false,\n      type: 'Ethereum',\n    }\n  } else {\n    return {\n      ...crossAccountId,\n      address: normalizeSubstrateAddress(crossAccountId.Substrate as string),\n      addressSS58: normalizeSubstrateAddress(crossAccountId.Substrate as string, ss58Prefix),\n      substratePublicKey: decodeSubstrateAddress(crossAccountId.Substrate as string).hex,\n      isEthereum: false,\n      isSubstrate: true,\n      type: 'Substrate',\n    }\n  }\n}\n","export * from 'coin-format'\n","export const DEFAULT_DECIMALS = 18\n\nconst validateDecimals = (decimals: any): decimals is number => {\n  if (typeof decimals !== 'number') throw new Error('Invalid decimals, must be a number')\n  if (decimals < 1 || decimals > 18) throw new Error('Invalid decimals, must be between 0 and 18')\n  return true\n}\n\nexport const coinToWeiInBigInt = (value: string | number, decimals: number = DEFAULT_DECIMALS): bigint => {\n  value = value.toString()\n\n  //test that value is string of positive number\n  if (!/^\\d+(\\.\\d+)?$/.test(value)) {\n    throw new Error('Invalid value')\n  }\n  validateDecimals(decimals)\n\n  // Define the multiplier as a BigInt\n  const multiplier = 10n ** BigInt(decimals)\n\n  // Convert the integer part and fractional part separately\n  let [integerPart, fractionalPart = ''] = value.split('.')\n\n  // Ensure the fractional part is not longer than decimals digits\n  fractionalPart = fractionalPart.padEnd(decimals, '0').slice(0, decimals)\n\n  // Combine the integer and fractional parts\n  const weiValue = BigInt(integerPart) * multiplier + BigInt(fractionalPart)\n\n  return weiValue\n}\n\nexport const coinToWei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return coinToWeiInBigInt(value, decimals).toString()\n}\n\nexport const weiToCoin = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  validateDecimals(decimals)\n\n  const weiBigInt = BigInt(weiValue)\n  const divisor = 10n ** BigInt(decimals)\n\n  // Divide the Wei amount by the divisor to get the Ether amount\n  const ethAmountBigInt = weiBigInt / divisor\n  const remainder = weiBigInt % divisor\n\n  // Determine how many digits to keep based on the Ether amount\n  // let digits = 0\n  // const ethAmount = Number(ethAmountBigInt) + (remainder > 0 ? Number(remainder) / 10 ** decimals : 0)\n  // if (ethAmount < 0.1) digits = 6\n  // else if (ethAmount < 1) digits = 4\n  // else if (ethAmount < 10) digits = 3\n  // else if (ethAmount < 100) digits = 2\n  // else if (ethAmount < 100000) digits = 1\n  // For amounts >= 100000, digits remain 0 for integer values\n\n  // Format the fractional part based on the determined digits\n  const remainderStr = remainder.toString()\n    .padStart(decimals, '0')\n  // .substring(0, digits)\n\n  // Remove trailing zeros from the remainder\n  const formattedRemainder = remainderStr.replace(/0+$/, '')\n\n  // Combine the integer part and the fractional part\n  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? '.' + formattedRemainder : ''}`\n\n  return formattedEthAmount\n}\n\nexport const dangerouslyWeiToCoinInFloat = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): number =>\n  parseFloat(weiToCoin(weiValue, decimals))\n\nexport const formatNice = (value: string | number, formattingThreshold: number = 100_000): string => {\n  const numStr = typeof value === 'string' ? value : value.toString()\n  const roughNum = parseFloat(numStr)\n  if (isNaN(roughNum)) throw new Error(`Coin.format: Invalid number: ${numStr}`)\n\n  if (formattingThreshold === -1) {\n    return numStr\n  }\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  const integerNum = parseInt(integerPart)\n\n  if (integerNum < formattingThreshold) {\n    if (!fractionalPart) return numStr\n\n    const roughRemainder = parseFloat(`0.${fractionalPart}`)\n    let digits = 0\n    if (roughRemainder < 0.1) digits = 6\n    else if (integerNum < 1) digits = 4\n    else if (integerNum < 10) digits = 3\n    else if (integerNum < 10000) digits = 2\n    else if (integerNum < 100000) digits = 1\n    // For amounts >= 100000, digits remain 0 for integer values\n\n    let fractionalPadded = fractionalPart\n      .substring(0, digits)\n    if (fractionalPadded.length < 2 && digits >= 2) fractionalPadded = fractionalPadded.padEnd(2, '0')\n\n    // if fractional part contains only zeroes, remove it\n    if (fractionalPadded.replace(/0/g, '') === '') return integerPart\n    if (!fractionalPadded) return integerPart\n    return `${integerPart}.${fractionalPadded}`\n  }\n\n  const suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"]\n  const i = integerNum === 0\n    ? 0\n    // 6.907... is Math.log(1000), 4 is max index of suffixes\n    : Math.min(Math.floor(Math.log(integerNum) / 6.907755278982137), 4)\n\n  const [integerPartOfNice, fractionalPartOfNice = ''] = (integerNum / Math.pow(1000, i)).toString().split('.')\n  const formatted = integerPartOfNice +\n    (fractionalPartOfNice.length > 0 ? '.' + fractionalPartOfNice.slice(0, 3) : '')\n\n  return `${formatted}${suffixes[i]}`\n}\n\nexport const formatFixed = (value: string | number, precision: number = 3): string => {\n  const numStr = value.toString()\n  if (precision === -1) return numStr\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  if (!fractionalPart) return numStr\n\n  return `${integerPart}.${fractionalPart.substring(0, precision).padEnd(precision, '0')}`\n}\n\nexport const weiFormatNice = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, formattingThreshold = 100_000): string => {\n  return formatNice(weiToCoin(weiValue, decimals), formattingThreshold)\n}\n\nexport const weiFormatFixed = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, precision: number = 3): string => {\n  return formatFixed(weiToCoin(weiValue, decimals), precision)\n}\n\nexport const weiToGwei = (gwei: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const weiBigInt = BigInt(gwei)\n  if (weiBigInt < 0n) throw new Error('Invalid gwei value')\n  const divisor = 10n ** (BigInt(decimals) / 2n)\n  const [integerPart, fractionalPart = ''] = [\n    (weiBigInt / divisor).toString(),\n    (weiBigInt % divisor).toString().padStart(decimals / 2, '0').replace(/0+$/, '')\n  ]\n  if (!fractionalPart) return integerPart\n  return `${integerPart}.${fractionalPart}`\n}\n\nexport const gweiToWei = (gwei: string | number | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const multiplier = 10n ** (BigInt(decimals) / 2n)\n\n  const [integerPart, fractionalPart = ''] = gwei.toString().split('.')\n  if (BigInt(integerPart) < 0n) throw new Error('Invalid gwei value - must be positive')\n  const gweiIntegerPartInWei = BigInt(integerPart) * multiplier\n  if (!fractionalPart) return gweiIntegerPartInWei.toString()\n\n  const fractionalPartStr = fractionalPart.padEnd(decimals / 2, '0').slice(0, decimals / 2)\n\n  const weiValue = gweiIntegerPartInWei + BigInt(fractionalPartStr)\n  return weiValue.toString()\n}\n\nexport const coinToGwei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToGwei(coinToWei(value, decimals), decimals)\n}\n\nexport const gweiToCoin = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToCoin(gweiToWei(value, decimals), decimals)\n}\n\nexport const cleanUpCoinsValue = (value: string | number): string => {\n  return value.toString().trim().replace(/\\.?0+$/, '')\n}\n\nexport const Coin = (\n  currency: string,\n  decimals: number = DEFAULT_DECIMALS,\n  precision: number = 3,\n  formattingThreshold: number = 100_000\n) => {\n  if (typeof currency as any !== 'string') throw new Error('Invalid currency, must be a string')\n  validateDecimals(decimals)\n  const paddedCurrency = currency.trim() === '' ? '' : ` ${currency.trim()}`\n\n  return {\n    coinToWeiInBigInt: (value: string): bigint => coinToWeiInBigInt(value, decimals),\n    coinToWei: (value: string): string => coinToWei(value, decimals),\n    weiToCoin: (value: string | bigint): string => weiToCoin(value, decimals),\n\n    dangerouslyWeiToCoinInFloat: (value: string | bigint): number => dangerouslyWeiToCoinInFloat(value, decimals),\n\n    formatNice: (value: string): string => formatNice(value, formattingThreshold) + paddedCurrency,\n    formatMetric: (value: string): string => formatNice(value, formattingThreshold),\n    formatFixed: (value: string | number, _precision = precision): string => formatFixed(value, _precision) + paddedCurrency,\n    formatFixedClean: (value: string | number, _precision = precision): string => formatFixed(value, _precision),\n    weiFormatNice: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold) + paddedCurrency,\n    weiFormatMetric: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold),\n    weiFormatFixed: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision) + paddedCurrency,\n    weiFormatFixedClean: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision),\n\n    gwei: {\n      gweiToWei: (value: string | number | bigint): string => gweiToWei(value, decimals),\n      weiToGwei: (value: string | bigint): string => weiToGwei(value, decimals),\n      gweiToCoin: (value: string | number): string => gweiToCoin(value, decimals),\n      coinToGwei: (value: string | number): string => coinToGwei(value, decimals),\n    },\n\n    inAllFormats: (value: string | number, _precision = precision): ICoinFormats => {\n      const wei = coinToWei(value, decimals)\n      const coins = cleanUpCoinsValue(value)\n      const metric = formatNice(value, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: formatFixed(value, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei,\n      }\n    },\n\n    weiInAllFormats: (wei: string | bigint, _precision = precision): ICoinFormats => {\n      const coins = weiToCoin(wei, decimals)\n      const metric = weiFormatNice(wei, decimals, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: weiFormatFixed(wei, decimals, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei: wei.toString(),\n      }\n    }\n  }\n}\n\nexport type ICoinFormats = {\n  value: string\n  metric: string\n  nice: string\n  fixed: string\n  exact: string\n  currency: string\n  wei: string\n}\n\nexport type ICoin = ReturnType<typeof Coin>\n"],"mappings":"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","names":["i","j","__export","HexString","Utf16","Utf8","__toCommonJS","bytes","HexString","basex","isBytes","isBytes","bytes","basex","import_utf_helpers","normalize","HexString"]}