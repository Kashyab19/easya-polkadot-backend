import basex from 'base-x';
import { keccak_256 } from '@noble/hashes/sha3';
import { blake2b } from '@noble/hashes/blake2b';
import * as utfHelpers from 'utf-helpers';
export { utfHelpers as StringUtils };
import * as coinFormat from 'coin-format';
export { Coin, ICoin, ICoinFormats } from 'coin-format';

function _mergeNamespaces(n, m) {
  m.forEach(function (e) {
    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
      if (k !== 'default' && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  });
  return Object.freeze(n);
}

declare function encodeSubstrateAddress(key: Uint8Array | string | bigint, ss58Format?: number): string;
declare function decodeSubstrateAddress(address: string, ignoreChecksum?: boolean, ss58Format?: number): DecodeSubstrateAddressResult;

type SubAddressObj = {
    Substrate: string;
};
type SubAddressObjUncapitalized = {
    substrate: string;
};
type EthAddressObj = {
    Ethereum: string;
};
type EthAddressObjUncapitalized = {
    ethereum: string;
};
type CrossAccountId = SubAddressObj & {
    Ethereum?: never;
} | EthAddressObj & {
    Substrate?: never;
};
type AddressType = 'Ethereum' | 'Substrate';
type EnhancedCrossAccountId = CrossAccountId & {
    address: string;
    addressSS58: string;
    type: AddressType;
    isEthereum: boolean;
    isSubstrate: boolean;
    substratePublicKey: string;
};
type CrossAccountIdUncapitalized = SubAddressObjUncapitalized & {
    ethereum?: never;
} | EthAddressObjUncapitalized & {
    substrate?: never;
};
type CrossAccountIdOrString = CrossAccountId | string;
type CrossAccountIdUncapitalizedOrString = CrossAccountIdUncapitalized | string;
type EthCrossAccountId = {
    eth: string;
    sub: string;
};

declare const base58: basex.BaseConverter;
declare const base64: basex.BaseConverter;

declare const algorithms_base58: typeof base58;
declare const algorithms_base64: typeof base64;
declare const algorithms_basex: typeof basex;
declare const algorithms_blake2b: typeof blake2b;
declare const algorithms_keccak_256: typeof keccak_256;
declare namespace algorithms {
  export { algorithms_base58 as base58, algorithms_base64 as base64, algorithms_basex as basex, algorithms_blake2b as blake2b, algorithms_keccak_256 as keccak_256 };
}

declare const STATIC_ADDRESSES: {
    readonly contractHelpers: "0x842899ECF380553E8a4de75bF534cdf6fBF64049";
    readonly collectionHelpers: "0x6C4E9fE1AE37a41E93CEE429e8E1881aBdcbb54F";
};
declare const NESTING_PREFIX: "0xf8238ccfff8ed887463fd5e0";
declare const COLLECTION_ADDRESS_PREFIX: "0x17c4e6453cc49aaaaeaca894e6d9683e";

declare const constants_COLLECTION_ADDRESS_PREFIX: typeof COLLECTION_ADDRESS_PREFIX;
declare const constants_NESTING_PREFIX: typeof NESTING_PREFIX;
declare const constants_STATIC_ADDRESSES: typeof STATIC_ADDRESSES;
declare namespace constants {
  export { constants_COLLECTION_ADDRESS_PREFIX as COLLECTION_ADDRESS_PREFIX, constants_NESTING_PREFIX as NESTING_PREFIX, constants_STATIC_ADDRESSES as STATIC_ADDRESSES };
}

type DecodeSubstrateAddressResult = {
    u8a: Uint8Array;
    hex: string;
    bigint: bigint;
    ss58Prefix: number;
};
declare const validate: {
    substrateAddress: (address: string) => boolean;
    ethereumAddress: (address: string) => boolean;
    substratePublicKey: (address: string) => boolean;
    collectionAddress: (address: string) => boolean;
    nestingAddress: (address: string) => boolean;
    collectionId: (collectionId: number) => boolean;
    tokenId: (tokenId: number) => boolean;
};
declare const is: {
    substrateAddress: (address: string) => boolean;
    ethereumAddress: (address: string) => boolean;
    substratePublicKey: (address: string) => boolean;
    collectionAddress: (address: string) => boolean;
    nestingAddress: (address: string) => boolean;
    collectionId: (collectionId: number) => boolean;
    tokenId: (tokenId: number) => boolean;
    crossAccountId(obj: any): obj is CrossAccountId;
    crossAccountIdUncapitalized(obj: any): obj is CrossAccountIdUncapitalized;
    substrateAddressObject(obj: any): obj is SubAddressObj;
    ethereumAddressObject(obj: any): obj is EthAddressObj;
    substrateAddressObjectUncapitalized(obj: any): obj is SubAddressObjUncapitalized;
    ethereumAddressObjectUncapitalized(obj: any): obj is EthAddressObjUncapitalized;
    substrateAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized;
    ethereumAddressInAnyForm(address: any): address is string | EthAddressObj | EthAddressObjUncapitalized;
    validAddressInAnyForm(address: any): address is string | SubAddressObj | EthAddressObj | SubAddressObjUncapitalized | EthAddressObjUncapitalized;
};
declare const collection: {
    idToAddress: (collectionId: number) => string;
    addressToId: (address: string) => number;
};
declare const nesting: {
    idsToAddress: (collectionId: number, tokenId: number) => string;
    addressToIds: (address: string) => {
        collectionId: number;
        tokenId: number;
    };
};
declare const extract: {
    address: (addressOrCrossAccountId: string | object) => string;
    addressSafe: (addressOrCrossAccountId: string | object) => string | null;
    addressNormalized: (addressOrCrossAccountId: string | object) => string;
    addressNormalizedSafe: (addressOrCrossAccountId: string | object) => string | null;
    addressForScanNormalized: (addressOrCrossAccountId: string | object) => string;
    addressForScanNormalizedSafe: (addressOrCrossAccountId: string | object) => string | null;
    crossAccountId: (addressOrCrossAccountId: string | object) => CrossAccountId;
    crossAccountIdSafe: (addressOrCrossAccountId: string | object) => CrossAccountId | null;
    crossAccountIdNormalized: (addressOrCrossAccountId: string | object) => CrossAccountId;
    crossAccountIdNormalizedSafe: (addressOrCrossAccountId: string | object) => CrossAccountId | null;
    crossAccountIdUncapitalized: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized;
    crossAccountIdUncapitalizedSafe: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized | null;
    crossAccountIdUncapitalizedNormalized: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized;
    crossAccountIdUncapitalizedNormalizedSafe: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized | null;
    substrateOrMirrorIfEthereum: (addressOrCrossAccountId: string | object) => string;
    substrateOrMirrorIfEthereumSafe: (addressOrCrossAccountId: string | object) => string | null;
    substrateOrMirrorIfEthereumNormalized: (addressOrCrossAccountId: string | object) => string;
    substrateOrMirrorIfEthereumNormalizedSafe: (addressOrCrossAccountId: string | object) => string | null;
    substratePublicKey: (addressOrCrossAccountId: string | object) => string;
    substratePublicKeySafe: (addressOrCrossAccountId: string | object) => string | null;
    enhancedCrossAccountId: (addressInAnyForm: string | object, ss58Prefix?: number) => EnhancedCrossAccountId;
    enhancedCrossAccountIdSafe: (addressInAnyForm: string | object, ss58Prefix?: number) => EnhancedCrossAccountId | null;
    ethCrossAccountId: (addressInAnyForm: string | object) => EthCrossAccountId;
    ethCrossAccountIdSafe: (addressInAnyForm: string | object) => EthCrossAccountId | null;
};
declare const mirror: {
    substrateToEthereum: (address: string, ignoreChecksum?: boolean | undefined) => string;
    ethereumToSubstrate: (evmAddress: string, ss58Format?: number) => string;
};
declare const normalize: {
    substrateAddress: (address: string, prefix?: number) => string;
    ethereumAddress: (address: string) => string;
};
declare const compare: {
    substrateAddresses: (address1: string | object, address2: string | object) => boolean;
    ethereumAddresses: (address1: string | object, address2: string | object) => boolean;
};
declare const substrate: {
    encode: typeof encodeSubstrateAddress;
    decode: typeof decodeSubstrateAddress;
    compare: (address1: string | object, address2: string | object) => boolean;
};
declare const Address: {
    constants: typeof constants;
    algorithms: typeof algorithms;
    is: {
        substrateAddress: (address: string) => boolean;
        ethereumAddress: (address: string) => boolean;
        substratePublicKey: (address: string) => boolean;
        collectionAddress: (address: string) => boolean;
        nestingAddress: (address: string) => boolean;
        collectionId: (collectionId: number) => boolean;
        tokenId: (tokenId: number) => boolean;
        crossAccountId(obj: any): obj is CrossAccountId;
        crossAccountIdUncapitalized(obj: any): obj is CrossAccountIdUncapitalized;
        substrateAddressObject(obj: any): obj is SubAddressObj;
        ethereumAddressObject(obj: any): obj is EthAddressObj;
        substrateAddressObjectUncapitalized(obj: any): obj is SubAddressObjUncapitalized;
        ethereumAddressObjectUncapitalized(obj: any): obj is EthAddressObjUncapitalized;
        substrateAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized;
        ethereumAddressInAnyForm(address: any): address is string | EthAddressObj | EthAddressObjUncapitalized;
        validAddressInAnyForm(address: any): address is string | SubAddressObj | EthAddressObj | SubAddressObjUncapitalized | EthAddressObjUncapitalized;
    };
    validate: {
        substrateAddress: (address: string) => boolean;
        ethereumAddress: (address: string) => boolean;
        substratePublicKey: (address: string) => boolean;
        collectionAddress: (address: string) => boolean;
        nestingAddress: (address: string) => boolean;
        collectionId: (collectionId: number) => boolean;
        tokenId: (tokenId: number) => boolean;
    };
    collection: {
        idToAddress: (collectionId: number) => string;
        addressToId: (address: string) => number;
    };
    nesting: {
        idsToAddress: (collectionId: number, tokenId: number) => string;
        addressToIds: (address: string) => {
            collectionId: number;
            tokenId: number;
        };
    };
    extract: {
        address: (addressOrCrossAccountId: string | object) => string;
        addressSafe: (addressOrCrossAccountId: string | object) => string | null;
        addressNormalized: (addressOrCrossAccountId: string | object) => string;
        addressNormalizedSafe: (addressOrCrossAccountId: string | object) => string | null;
        addressForScanNormalized: (addressOrCrossAccountId: string | object) => string;
        addressForScanNormalizedSafe: (addressOrCrossAccountId: string | object) => string | null;
        crossAccountId: (addressOrCrossAccountId: string | object) => CrossAccountId;
        crossAccountIdSafe: (addressOrCrossAccountId: string | object) => CrossAccountId | null;
        crossAccountIdNormalized: (addressOrCrossAccountId: string | object) => CrossAccountId;
        crossAccountIdNormalizedSafe: (addressOrCrossAccountId: string | object) => CrossAccountId | null;
        crossAccountIdUncapitalized: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized;
        crossAccountIdUncapitalizedSafe: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized | null;
        crossAccountIdUncapitalizedNormalized: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized;
        crossAccountIdUncapitalizedNormalizedSafe: (addressOrCrossAccountId: string | object) => CrossAccountIdUncapitalized | null;
        substrateOrMirrorIfEthereum: (addressOrCrossAccountId: string | object) => string;
        substrateOrMirrorIfEthereumSafe: (addressOrCrossAccountId: string | object) => string | null;
        substrateOrMirrorIfEthereumNormalized: (addressOrCrossAccountId: string | object) => string;
        substrateOrMirrorIfEthereumNormalizedSafe: (addressOrCrossAccountId: string | object) => string | null;
        substratePublicKey: (addressOrCrossAccountId: string | object) => string;
        substratePublicKeySafe: (addressOrCrossAccountId: string | object) => string | null;
        enhancedCrossAccountId: (addressInAnyForm: string | object, ss58Prefix?: number) => EnhancedCrossAccountId;
        enhancedCrossAccountIdSafe: (addressInAnyForm: string | object, ss58Prefix?: number) => EnhancedCrossAccountId | null;
        ethCrossAccountId: (addressInAnyForm: string | object) => EthCrossAccountId;
        ethCrossAccountIdSafe: (addressInAnyForm: string | object) => EthCrossAccountId | null;
    };
    mirror: {
        substrateToEthereum: (address: string, ignoreChecksum?: boolean | undefined) => string;
        ethereumToSubstrate: (evmAddress: string, ss58Format?: number) => string;
    };
    normalize: {
        substrateAddress: (address: string, prefix?: number) => string;
        ethereumAddress: (address: string) => string;
    };
    compare: {
        substrateAddresses: (address1: string | object, address2: string | object) => boolean;
        ethereumAddresses: (address1: string | object, address2: string | object) => boolean;
    };
    substrate: {
        encode: typeof encodeSubstrateAddress;
        decode: typeof decodeSubstrateAddress;
        compare: (address1: string | object, address2: string | object) => boolean;
    };
    utils: {
        DWORDHexString: {
            _checkU32: (num: number) => number;
            fromNumber: (n: number) => string;
            toNumber: (s: string) => number;
        };
    };
};

declare const index_Address: typeof Address;
type index_DecodeSubstrateAddressResult = DecodeSubstrateAddressResult;
declare const index_algorithms: typeof algorithms;
declare const index_collection: typeof collection;
declare const index_compare: typeof compare;
declare const index_constants: typeof constants;
declare const index_extract: typeof extract;
declare const index_is: typeof is;
declare const index_mirror: typeof mirror;
declare const index_nesting: typeof nesting;
declare const index_normalize: typeof normalize;
declare const index_substrate: typeof substrate;
declare const index_validate: typeof validate;
declare namespace index {
  export { index_Address as Address, type index_DecodeSubstrateAddressResult as DecodeSubstrateAddressResult, index_algorithms as algorithms, index_collection as collection, index_compare as compare, index_constants as constants, index_extract as extract, index_is as is, index_mirror as mirror, index_nesting as nesting, index_normalize as normalize, index_substrate as substrate, index_validate as validate };
}

var coin = /*#__PURE__*/_mergeNamespaces({
  __proto__: null
}, [coinFormat]);

declare const HexString: {
    fromArray: (bytes: number[] | Uint8Array) => string;
    fromU8a: (bytes: number[] | Uint8Array) => string;
    toArray(hexString: string): number[];
    toU8a: (hexString: string) => Uint8Array;
};
declare const Utf8: {
    stringToU8a(str: string): Uint8Array;
    stringToNumberArray(str: string): number[];
    u8aToString(u8a: Uint8Array): string;
    numberArrayToString(arr: number[] | Uint8Array): string;
    stringToHexString(str: string): string;
    hexStringToString(hexString: string): string;
    lengthInBytes(str: string): number;
};
declare const Utf16: {
    stringToU16a(str: string): Uint16Array;
    stringToNumberArray(str: string): number[];
    numberArrayToString(arr: number[] | Uint16Array): string;
    u16aToString(arr: number[] | Uint16Array): string;
    lengthInBytes(str: string): number;
};
declare const HexUtils: {
    fromArray: (bytes: number[] | Uint8Array) => string;
    fromU8a: (bytes: number[] | Uint8Array) => string;
    toArray(hexString: string): number[];
    toU8a: (hexString: string) => Uint8Array;
};

export { index as Address, type AddressType, coin as CoinUtils, type CrossAccountId, type CrossAccountIdOrString, type CrossAccountIdUncapitalized, type CrossAccountIdUncapitalizedOrString, type EnhancedCrossAccountId, type EthAddressObj, type EthAddressObjUncapitalized, type EthCrossAccountId, HexString, HexUtils, type SubAddressObj, type SubAddressObjUncapitalized, Utf16, Utf8, constants };
