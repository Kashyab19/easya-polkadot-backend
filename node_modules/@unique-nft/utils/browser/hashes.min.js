"use strict";
var UniqueHashes = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/utf-helpers/index.js
  var require_utf_helpers = __commonJS({
    "node_modules/utf-helpers/index.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var utf_helpers_exports = {};
      __export2(utf_helpers_exports, {
        HexString: () => HexString2,
        Utf16: () => Utf16,
        Utf8: () => Utf82,
        UtfHelpers: () => UtfHelpers
      });
      module.exports = __toCommonJS2(utf_helpers_exports);
      var HexString2 = {
        fromArray: (bytes) => {
          if (!(bytes instanceof Uint8Array) && !Array.isArray(bytes)) {
            throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes}, ${bytes}`);
          }
          const arr = bytes instanceof Uint8Array ? Array.from(bytes) : bytes;
          return "0x" + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
        },
        fromU8a: (bytes) => HexString2.fromArray(bytes),
        toArray(hexString) {
          if (typeof hexString !== "string") {
            throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`);
          }
          const str = hexString.startsWith("0x") ? hexString.slice(2) : hexString;
          const pairs = str.match(/.{1,2}/g) || [];
          return pairs.map((byte) => parseInt(byte, 16));
        },
        toU8a: (hexString) => Uint8Array.from(HexString2.toArray(hexString))
      };
      var Utf82 = {
        stringToU8a(str) {
          const u8a = new Uint8Array(Utf82.lengthInBytes(str));
          let offset = 0;
          const start = offset;
          let c1 = 0;
          let c2 = 0;
          let i = 0;
          while (i < str.length) {
            c1 = str.charCodeAt(i);
            if (c1 < 128) {
              u8a[offset++] = c1;
            } else if (c1 < 2048) {
              u8a[offset++] = c1 >> 6 | 192;
              u8a[offset++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = str.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              ++i;
              u8a[offset++] = c1 >> 18 | 240;
              u8a[offset++] = c1 >> 12 & 63 | 128;
              u8a[offset++] = c1 >> 6 & 63 | 128;
              u8a[offset++] = c1 & 63 | 128;
            } else {
              u8a[offset++] = c1 >> 12 | 224;
              u8a[offset++] = c1 >> 6 & 63 | 128;
              u8a[offset++] = c1 & 63 | 128;
            }
            i += 1;
          }
          const diff = offset - start;
          return u8a;
        },
        stringToNumberArray(str) {
          return Array.from(Utf82.stringToU8a(str));
        },
        u8aToString(u8a) {
          let start = 0;
          let end = u8a.length;
          if (end - start < 1) {
            return "";
          }
          let str = "";
          let i = start;
          while (i < end) {
            const t = u8a[i++];
            if (t <= 127) {
              str += String.fromCharCode(t);
            } else if (t >= 192 && t < 224) {
              str += String.fromCharCode((t & 31) << 6 | u8a[i++] & 63);
            } else if (t >= 224 && t < 240) {
              str += String.fromCharCode((t & 15) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63);
            } else if (t >= 240) {
              const t2 = ((t & 7) << 18 | (u8a[i++] & 63) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63) - 65536;
              str += String.fromCharCode(55296 + (t2 >> 10));
              str += String.fromCharCode(56320 + (t2 & 1023));
            }
          }
          return str;
        },
        numberArrayToString(arr) {
          return Utf82.u8aToString(Uint8Array.from(arr));
        },
        stringToHexString(str) {
          return HexString2.fromU8a(Utf82.stringToU8a(str));
        },
        hexStringToString(hexString) {
          return Utf82.u8aToString(HexString2.toU8a(hexString));
        },
        lengthInBytes(str) {
          let len = 0;
          let c = 0;
          let i = 0;
          while (i < str.length) {
            c = str.charCodeAt(i);
            if (c < 128) {
              len += 1;
            } else if (c < 2048) {
              len += 2;
            } else if ((c & 64512) === 55296 && (str.charCodeAt(i + 1) & 64512) === 56320) {
              ++i;
              len += 4;
            } else {
              len += 3;
            }
            i += 1;
          }
          return len;
        }
      };
      var Utf16 = {
        stringToU16a(str) {
          const u16arr = new Uint16Array(Utf16.lengthInBytes(str));
          let i = 0;
          while (i < str.length) {
            let cp = str.codePointAt(i);
            if (cp <= 65535) {
              u16arr[i++] = cp;
            } else {
              cp -= 65536;
              u16arr[i++] = (cp >> 10) + 55296;
              u16arr[i++] = cp % 1024 + 56320;
            }
          }
          return u16arr;
        },
        stringToNumberArray(str) {
          return Array.from(Utf16.stringToU16a(str));
        },
        numberArrayToString(arr) {
          let i = 0;
          const len = arr.length;
          let s = "";
          while (i < len - 1) {
            const c1 = arr[i];
            const c2 = arr[i + 1];
            if (c1 >= 55296 && c1 <= 57343) {
              if (c2 >= 56320 && c2 <= 57343) {
                s += String.fromCodePoint((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                i += 2;
              } else {
                throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`);
              }
            } else {
              s += String.fromCodePoint(c1);
              i += 1;
            }
          }
          if (i < len) {
            s += String.fromCodePoint(arr[len - 1]);
          }
          return s;
        },
        u16aToString(arr) {
          return Utf16.numberArrayToString(arr);
        },
        lengthInBytes(str) {
          let i = 0;
          while (i < str.length) {
            i += str.codePointAt(i) <= 65535 ? 1 : 2;
          }
          return i;
        }
      };
      var UtfHelpers = {
        HexString: HexString2,
        Utf8: Utf82,
        Utf16
      };
    }
  });

  // src/Hashes/index.ts
  var Hashes_exports = {};
  __export(Hashes_exports, {
    Xxhash: () => xxhash_exports,
    encodeSubstrateStorageKey: () => encodeSubstrateStorageKey2
  });

  // src/Hashes/xxhash.ts
  var xxhash_exports = {};
  __export(xxhash_exports, {
    encodeSubstrateStorageKey: () => encodeSubstrateStorageKey,
    u8aConcat: () => u8aConcat,
    xxhash64: () => xxhash64,
    xxhashOfU8a: () => xxhashOfU8a,
    xxhashOfU8aAsHex: () => xxhashOfU8aAsHex
  });
  var import_utf_helpers = __toESM(require_utf_helpers());
  function u8aConcat(u8as, length = 0) {
    const count = u8as.length;
    let offset = 0;
    if (!length) {
      for (let i = 0; i < count; i++) {
        length += u8as[i].length;
      }
    }
    const result = new Uint8Array(length);
    for (let i = 0; i < count; i++) {
      result.set(u8as[i], offset);
      offset += u8as[i].length;
    }
    return result;
  }
  var P64_1 = BigInt("11400714785074694791");
  var P64_2 = BigInt("14029467366897019727");
  var P64_3 = BigInt("1609587929392839161");
  var P64_4 = BigInt("9650029242287828579");
  var P64_5 = BigInt("2870177450012600261");
  var U64 = BigInt("0xffffffffffffffff");
  var _0n = 0n;
  var _1n = 1n;
  var _7n = 7n;
  var _11n = 11n;
  var _12n = 12n;
  var _16n = 16n;
  var _18n = 18n;
  var _23n = 23n;
  var _27n = 27n;
  var _29n = 29n;
  var _31n = 31n;
  var _32n = 32n;
  var _33n = 33n;
  var _64n = 64n;
  var _256n = 256n;
  function rotl(a, b) {
    const c = a & U64;
    return (c << b | c >> _64n - b) & U64;
  }
  function fromU8a(u8a, p, count) {
    const bigints = new Array(count);
    let offset = 0;
    for (let i = 0; i < count; i++, offset += 2) {
      bigints[i] = BigInt(u8a[p + offset] | u8a[p + 1 + offset] << 8);
    }
    let result = _0n;
    for (let i = count - 1; i >= 0; i--) {
      result = (result << _16n) + bigints[i];
    }
    return result;
  }
  function init(seed, input) {
    const state = {
      seed,
      u8a: new Uint8Array(32),
      u8asize: 0,
      v1: seed + P64_1 + P64_2,
      v2: seed + P64_2,
      v3: seed,
      v4: seed - P64_1
    };
    if (input.length < 32) {
      state.u8a.set(input);
      state.u8asize = input.length;
      return state;
    }
    const limit = input.length - 32;
    let p = 0;
    if (limit >= 0) {
      const adjustV = (v) => P64_1 * rotl(v + P64_2 * fromU8a(input, p, 4), _31n);
      do {
        state.v1 = adjustV(state.v1);
        p += 8;
        state.v2 = adjustV(state.v2);
        p += 8;
        state.v3 = adjustV(state.v3);
        p += 8;
        state.v4 = adjustV(state.v4);
        p += 8;
      } while (p <= limit);
    }
    if (p < input.length) {
      state.u8a.set(input.subarray(p, input.length));
      state.u8asize = input.length - p;
    }
    return state;
  }
  function xxhash64(input, initSeed) {
    const { seed, u8a, u8asize, v1, v2, v3, v4 } = init(BigInt(initSeed), input);
    let p = 0;
    let h64 = U64 & BigInt(input.length) + (input.length >= 32 ? ((((rotl(v1, _1n) + rotl(v2, _7n) + rotl(v3, _12n) + rotl(v4, _18n) ^ P64_1 * rotl(v1 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v2 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v3 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v4 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);
    while (p <= u8asize - 8) {
      h64 = U64 & P64_4 + P64_1 * rotl(h64 ^ P64_1 * rotl(P64_2 * fromU8a(u8a, p, 4), _31n), _27n);
      p += 8;
    }
    if (p + 4 <= u8asize) {
      h64 = U64 & P64_3 + P64_2 * rotl(h64 ^ P64_1 * fromU8a(u8a, p, 2), _23n);
      p += 4;
    }
    while (p < u8asize) {
      h64 = U64 & P64_1 * rotl(h64 ^ P64_5 * BigInt(u8a[p++]), _11n);
    }
    h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);
    h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);
    h64 = U64 & (h64 ^ h64 >> _32n);
    const result = new Uint8Array(8);
    for (let i = 7; i >= 0; i--) {
      result[i] = Number(h64 % _256n);
      h64 = h64 / _256n;
    }
    return result;
  }
  function xxhashOfU8a(data, bitLength = 64) {
    const rounds = Math.ceil(bitLength / 64);
    const result = new Uint8Array(rounds * 8);
    for (let seed = 0; seed < rounds; seed++) {
      result.set(xxhash64(data, seed).reverse(), seed * 8);
    }
    return result;
  }
  var xxhashOfU8aAsHex = (data, bitLength = 64) => import_utf_helpers.HexString.fromU8a(xxhashOfU8a(data, bitLength));
  var encodeSubstrateStorageKey = (entries) => {
    const hashes = entries.map((entry) => xxhashOfU8a(import_utf_helpers.Utf8.stringToU8a(entry), 128));
    return import_utf_helpers.HexString.fromU8a(u8aConcat(hashes));
  };

  // src/Hashes/index.ts
  var encodeSubstrateStorageKey2 = encodeSubstrateStorageKey;
  return __toCommonJS(Hashes_exports);
})();
//# sourceMappingURL=hashes.min.js.map