"use strict";
var ChainLens = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports, module) {
      "use strict";
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode(source) {
          if (source instanceof Uint8Array) {
          } else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size - it4));
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode
        };
      }
      module.exports = base;
    }
  });

  // node_modules/utf-helpers/index.js
  var require_utf_helpers = __commonJS({
    "node_modules/utf-helpers/index.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var utf_helpers_exports = {};
      __export2(utf_helpers_exports, {
        HexString: () => HexString6,
        Utf16: () => Utf163,
        Utf8: () => Utf83,
        UtfHelpers: () => UtfHelpers
      });
      module.exports = __toCommonJS2(utf_helpers_exports);
      var HexString6 = {
        fromArray: (bytes2) => {
          if (!(bytes2 instanceof Uint8Array) && !Array.isArray(bytes2)) {
            throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes2}, ${bytes2}`);
          }
          const arr = bytes2 instanceof Uint8Array ? Array.from(bytes2) : bytes2;
          return "0x" + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
        },
        fromU8a: (bytes2) => HexString6.fromArray(bytes2),
        toArray(hexString) {
          if (typeof hexString !== "string") {
            throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`);
          }
          const str = hexString.startsWith("0x") ? hexString.slice(2) : hexString;
          const pairs = str.match(/.{1,2}/g) || [];
          return pairs.map((byte) => parseInt(byte, 16));
        },
        toU8a: (hexString) => Uint8Array.from(HexString6.toArray(hexString))
      };
      var Utf83 = {
        stringToU8a(str) {
          const u8a = new Uint8Array(Utf83.lengthInBytes(str));
          let offset = 0;
          const start = offset;
          let c1 = 0;
          let c2 = 0;
          let i = 0;
          while (i < str.length) {
            c1 = str.charCodeAt(i);
            if (c1 < 128) {
              u8a[offset++] = c1;
            } else if (c1 < 2048) {
              u8a[offset++] = c1 >> 6 | 192;
              u8a[offset++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = str.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              ++i;
              u8a[offset++] = c1 >> 18 | 240;
              u8a[offset++] = c1 >> 12 & 63 | 128;
              u8a[offset++] = c1 >> 6 & 63 | 128;
              u8a[offset++] = c1 & 63 | 128;
            } else {
              u8a[offset++] = c1 >> 12 | 224;
              u8a[offset++] = c1 >> 6 & 63 | 128;
              u8a[offset++] = c1 & 63 | 128;
            }
            i += 1;
          }
          const diff = offset - start;
          return u8a;
        },
        stringToNumberArray(str) {
          return Array.from(Utf83.stringToU8a(str));
        },
        u8aToString(u8a) {
          let start = 0;
          let end = u8a.length;
          if (end - start < 1) {
            return "";
          }
          let str = "";
          let i = start;
          while (i < end) {
            const t = u8a[i++];
            if (t <= 127) {
              str += String.fromCharCode(t);
            } else if (t >= 192 && t < 224) {
              str += String.fromCharCode((t & 31) << 6 | u8a[i++] & 63);
            } else if (t >= 224 && t < 240) {
              str += String.fromCharCode((t & 15) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63);
            } else if (t >= 240) {
              const t2 = ((t & 7) << 18 | (u8a[i++] & 63) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63) - 65536;
              str += String.fromCharCode(55296 + (t2 >> 10));
              str += String.fromCharCode(56320 + (t2 & 1023));
            }
          }
          return str;
        },
        numberArrayToString(arr) {
          return Utf83.u8aToString(Uint8Array.from(arr));
        },
        stringToHexString(str) {
          return HexString6.fromU8a(Utf83.stringToU8a(str));
        },
        hexStringToString(hexString) {
          return Utf83.u8aToString(HexString6.toU8a(hexString));
        },
        lengthInBytes(str) {
          let len = 0;
          let c = 0;
          let i = 0;
          while (i < str.length) {
            c = str.charCodeAt(i);
            if (c < 128) {
              len += 1;
            } else if (c < 2048) {
              len += 2;
            } else if ((c & 64512) === 55296 && (str.charCodeAt(i + 1) & 64512) === 56320) {
              ++i;
              len += 4;
            } else {
              len += 3;
            }
            i += 1;
          }
          return len;
        }
      };
      var Utf163 = {
        stringToU16a(str) {
          const u16arr = new Uint16Array(Utf163.lengthInBytes(str));
          let i = 0;
          while (i < str.length) {
            let cp = str.codePointAt(i);
            if (cp <= 65535) {
              u16arr[i++] = cp;
            } else {
              cp -= 65536;
              u16arr[i++] = (cp >> 10) + 55296;
              u16arr[i++] = cp % 1024 + 56320;
            }
          }
          return u16arr;
        },
        stringToNumberArray(str) {
          return Array.from(Utf163.stringToU16a(str));
        },
        numberArrayToString(arr) {
          let i = 0;
          const len = arr.length;
          let s = "";
          while (i < len - 1) {
            const c1 = arr[i];
            const c2 = arr[i + 1];
            if (c1 >= 55296 && c1 <= 57343) {
              if (c2 >= 56320 && c2 <= 57343) {
                s += String.fromCodePoint((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                i += 2;
              } else {
                throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`);
              }
            } else {
              s += String.fromCodePoint(c1);
              i += 1;
            }
          }
          if (i < len) {
            s += String.fromCodePoint(arr[len - 1]);
          }
          return s;
        },
        u16aToString(arr) {
          return Utf163.numberArrayToString(arr);
        },
        lengthInBytes(str) {
          let i = 0;
          while (i < str.length) {
            i += str.codePointAt(i) <= 65535 ? 1 : 2;
          }
          return i;
        }
      };
      var UtfHelpers = {
        HexString: HexString6,
        Utf8: Utf83,
        Utf16: Utf163
      };
    }
  });

  // src/ChainLens/index.ts
  var ChainLens_exports = {};
  __export(ChainLens_exports, {
    ChainLenses: () => ChainLenses,
    constants: () => constants,
    default: () => ChainLens_default,
    generateChainLens: () => generateChainLens
  });

  // src/Address/index.ts
  var Address_exports = {};
  __export(Address_exports, {
    Address: () => Address,
    algorithms: () => imports_exports,
    collection: () => collection,
    compare: () => compare,
    constants: () => constants_exports,
    extract: () => extract,
    is: () => is,
    mirror: () => mirror,
    nesting: () => nesting,
    normalize: () => normalize,
    substrate: () => substrate,
    validate: () => validate
  });

  // src/Address/constants.ts
  var constants_exports = {};
  __export(constants_exports, {
    COLLECTION_ADDRESS_PREFIX: () => COLLECTION_ADDRESS_PREFIX,
    NESTING_PREFIX: () => NESTING_PREFIX,
    STATIC_ADDRESSES: () => STATIC_ADDRESSES
  });
  var STATIC_ADDRESSES = {
    contractHelpers: "0x842899ECF380553E8a4de75bF534cdf6fBF64049",
    collectionHelpers: "0x6C4E9fE1AE37a41E93CEE429e8E1881aBdcbb54F"
  };
  var NESTING_PREFIX = "0xf8238ccfff8ed887463fd5e0";
  var COLLECTION_ADDRESS_PREFIX = "0x17c4e6453cc49aaaaeaca894e6d9683e";

  // src/Address/imports.ts
  var imports_exports = {};
  __export(imports_exports, {
    base58: () => base58,
    base64: () => base64,
    basex: () => import_base_x.default,
    blake2b: () => blake2b,
    keccak_256: () => keccak_256
  });
  var import_base_x = __toESM(require_src());

  // node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  function bytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }

  // node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  var shrSH = (h, _l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H = (_h, l) => l;
  var rotr32L = (h, _l) => h;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var u64_default = u64;

  // node_modules/@noble/hashes/esm/utils.js
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  function isBytes2(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!isBytes2(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }

  // node_modules/@noble/hashes/esm/sha3.js
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var Keccak = class _Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

  // node_modules/@noble/hashes/esm/_blake2.js
  var SIGMA = /* @__PURE__ */ new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ]);
  var BLAKE2 = class extends Hash {
    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.length = 0;
      this.pos = 0;
      this.finished = false;
      this.destroyed = false;
      number(blockLen);
      number(outputLen);
      number(keyLen);
      if (outputLen < 0 || outputLen > keyLen)
        throw new Error("outputLen bigger than keyLen");
      if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
        throw new Error(`key must be up 1..${keyLen} byte long or undefined`);
      if (opts.salt !== void 0 && opts.salt.length !== saltLen)
        throw new Error(`salt must be ${saltLen} byte long or undefined`);
      if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
        throw new Error(`personalization must be ${persLen} byte long or undefined`);
      this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));
    }
    update(data) {
      exists(this);
      const { blockLen, buffer, buffer32 } = this;
      data = toBytes(data);
      const len = data.length;
      const offset = data.byteOffset;
      const buf = data.buffer;
      for (let pos = 0; pos < len; ) {
        if (this.pos === blockLen) {
          this.compress(buffer32, 0, false);
          this.pos = 0;
        }
        const take = Math.min(blockLen - this.pos, len - pos);
        const dataOffset = offset + pos;
        if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
          const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
          for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
            this.length += blockLen;
            this.compress(data32, pos32, false);
          }
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        this.length += take;
        pos += take;
      }
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      const { pos, buffer32 } = this;
      this.finished = true;
      this.buffer.subarray(pos).fill(0);
      this.compress(buffer32, 0, true);
      const out32 = u32(out);
      this.get().forEach((v, i) => out32[i] = v);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      const { buffer, length, finished, destroyed, outputLen, pos } = this;
      to || (to = new this.constructor({ dkLen: outputLen }));
      to.set(...this.get());
      to.length = length;
      to.finished = finished;
      to.destroyed = destroyed;
      to.outputLen = outputLen;
      to.buffer.set(buffer);
      to.pos = pos;
      return to;
    }
  };

  // node_modules/@noble/hashes/esm/blake2b.js
  var IV = /* @__PURE__ */ new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  var BUF = /* @__PURE__ */ new Uint32Array(32);
  function G1(a, b, c, d, msg, x) {
    const Xl = msg[x], Xh = msg[x + 1];
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
    let ll = u64_default.add3L(Al, Bl, Xl);
    Ah = u64_default.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64_default.rotr32H(Dh, Dl), Dl: u64_default.rotr32L(Dh, Dl) });
    ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64_default.rotrSH(Bh, Bl, 24), Bl: u64_default.rotrSL(Bh, Bl, 24) });
    BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
    BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
    BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
    BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
  }
  function G2(a, b, c, d, msg, x) {
    const Xl = msg[x], Xh = msg[x + 1];
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
    let ll = u64_default.add3L(Al, Bl, Xl);
    Ah = u64_default.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64_default.rotrSH(Dh, Dl, 16), Dl: u64_default.rotrSL(Dh, Dl, 16) });
    ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64_default.rotrBH(Bh, Bl, 63), Bl: u64_default.rotrBL(Bh, Bl, 63) });
    BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
    BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
    BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
    BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
  }
  var BLAKE2b = class extends BLAKE2 {
    constructor(opts = {}) {
      super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
      this.v0l = IV[0] | 0;
      this.v0h = IV[1] | 0;
      this.v1l = IV[2] | 0;
      this.v1h = IV[3] | 0;
      this.v2l = IV[4] | 0;
      this.v2h = IV[5] | 0;
      this.v3l = IV[6] | 0;
      this.v3h = IV[7] | 0;
      this.v4l = IV[8] | 0;
      this.v4h = IV[9] | 0;
      this.v5l = IV[10] | 0;
      this.v5h = IV[11] | 0;
      this.v6l = IV[12] | 0;
      this.v6h = IV[13] | 0;
      this.v7l = IV[14] | 0;
      this.v7h = IV[15] | 0;
      const keyLength = opts.key ? opts.key.length : 0;
      this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
      if (opts.salt) {
        const salt = u32(toBytes(opts.salt));
        this.v4l ^= salt[0];
        this.v4h ^= salt[1];
        this.v5l ^= salt[2];
        this.v5h ^= salt[3];
      }
      if (opts.personalization) {
        const pers = u32(toBytes(opts.personalization));
        this.v6l ^= pers[0];
        this.v6h ^= pers[1];
        this.v7l ^= pers[2];
        this.v7h ^= pers[3];
      }
      if (opts.key) {
        const tmp = new Uint8Array(this.blockLen);
        tmp.set(toBytes(opts.key));
        this.update(tmp);
      }
    }
    // prettier-ignore
    get() {
      let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
      return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
      this.v0l = v0l | 0;
      this.v0h = v0h | 0;
      this.v1l = v1l | 0;
      this.v1h = v1h | 0;
      this.v2l = v2l | 0;
      this.v2h = v2h | 0;
      this.v3l = v3l | 0;
      this.v3h = v3h | 0;
      this.v4l = v4l | 0;
      this.v4h = v4h | 0;
      this.v5l = v5l | 0;
      this.v5h = v5h | 0;
      this.v6l = v6l | 0;
      this.v6h = v6h | 0;
      this.v7l = v7l | 0;
      this.v7h = v7h | 0;
    }
    compress(msg, offset, isLast) {
      this.get().forEach((v, i) => BUF[i] = v);
      BUF.set(IV, 16);
      let { h, l } = u64_default.fromBig(BigInt(this.length));
      BUF[24] = IV[8] ^ l;
      BUF[25] = IV[9] ^ h;
      if (isLast) {
        BUF[28] = ~BUF[28];
        BUF[29] = ~BUF[29];
      }
      let j = 0;
      const s = SIGMA;
      for (let i = 0; i < 12; i++) {
        G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);
        G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
        G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);
        G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
        G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);
        G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
        G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);
        G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
        G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);
        G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
        G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);
        G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
        G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);
        G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
        G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);
        G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      }
      this.v0l ^= BUF[0] ^ BUF[16];
      this.v0h ^= BUF[1] ^ BUF[17];
      this.v1l ^= BUF[2] ^ BUF[18];
      this.v1h ^= BUF[3] ^ BUF[19];
      this.v2l ^= BUF[4] ^ BUF[20];
      this.v2h ^= BUF[5] ^ BUF[21];
      this.v3l ^= BUF[6] ^ BUF[22];
      this.v3h ^= BUF[7] ^ BUF[23];
      this.v4l ^= BUF[8] ^ BUF[24];
      this.v4h ^= BUF[9] ^ BUF[25];
      this.v5l ^= BUF[10] ^ BUF[26];
      this.v5h ^= BUF[11] ^ BUF[27];
      this.v6l ^= BUF[12] ^ BUF[28];
      this.v6h ^= BUF[13] ^ BUF[29];
      this.v7l ^= BUF[14] ^ BUF[30];
      this.v7h ^= BUF[15] ^ BUF[31];
      BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer32.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var blake2b = /* @__PURE__ */ wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

  // src/Address/imports.ts
  var BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var base58 = (0, import_base_x.default)(BASE58_ALPHABET);
  var base64 = (0, import_base_x.default)(BASE64_ALPHABET);

  // src/Address/ethereum.ts
  var import_utf_helpers = __toESM(require_utf_helpers());
  var DWORDHexString = {
    _checkU32: (num) => {
      if (typeof num !== "number")
        throw new Error(`Passed number is not a number: ${typeof num}, ${num}`);
      if (isNaN(num))
        throw new Error(`Passed number is NaN: ${num}`);
      if (num < 0)
        throw new Error(`Passed number is less than 0: ${num}`);
      if (num > 4294967295)
        throw new Error(`Passed number is more than 2**32: ${num}`);
      if (num !== Math.floor(num))
        throw new Error(`Passed number is not an integer number: ${num}`);
      return num;
    },
    fromNumber: (n) => {
      return DWORDHexString._checkU32(n).toString(16).padStart(8, "0");
    },
    toNumber: (s) => {
      const num = parseInt(s, 16);
      if (isNaN(num))
        throw new Error(`Passed string is not hexadecimal: ${s}`);
      return DWORDHexString._checkU32(num);
    }
  };
  var unsafeNormalizeEthereumAddress = (address) => {
    const addr = address.toLowerCase().replace(/^0x/i, "");
    const addressHash = import_utf_helpers.HexString.fromU8a(keccak_256(addr)).replace(/^0x/i, "");
    let checksumAddress = "0x";
    for (let i = 0; i < addr.length; i++) {
      checksumAddress += parseInt(addressHash[i], 16) > 7 ? addr[i].toUpperCase() : addr[i];
    }
    return checksumAddress;
  };
  var normalizeEthereumAddress = (address) => {
    validate.ethereumAddress(address);
    return unsafeNormalizeEthereumAddress(address);
  };
  var compareEthereumAddresses = (address1, address2) => {
    const addr1 = typeof address1 === "string" ? address1 : address1.Ethereum || address1.ethereum;
    const addr2 = typeof address2 === "string" ? address2 : address2.Ethereum || address2.ethereum;
    if (!addr1 || !addr2 || !is.ethereumAddress(addr1) || !is.ethereumAddress(addr2)) {
      return false;
    }
    return addr1.toLowerCase() === addr2.toLowerCase();
  };
  var collectionIdToEthAddress = (collectionId) => {
    validate.collectionId(collectionId);
    return unsafeNormalizeEthereumAddress(
      COLLECTION_ADDRESS_PREFIX + DWORDHexString.fromNumber(collectionId)
    );
  };
  var ethAddressToCollectionId = (address) => {
    validate.collectionAddress(address);
    return DWORDHexString.toNumber(address.slice(-8));
  };
  var collectionIdAndTokenIdToNestingAddress = (collectionId, tokenId) => {
    validate.collectionId(collectionId);
    validate.tokenId(tokenId);
    return unsafeNormalizeEthereumAddress(
      NESTING_PREFIX + DWORDHexString.fromNumber(collectionId) + DWORDHexString.fromNumber(tokenId)
    );
  };
  var nestingAddressToCollectionIdAndTokenId = (address) => {
    validate.nestingAddress(address);
    return {
      collectionId: DWORDHexString.toNumber(address.slice(-16, -8)),
      tokenId: DWORDHexString.toNumber(address.slice(-8))
    };
  };

  // src/Address/substrate.ts
  var import_utf_helpers2 = __toESM(require_utf_helpers());
  var blake2AsU8a = (u8a, dkLen = 32) => {
    return blake2b(u8a, { dkLen });
  };
  var u8aConcat = (u8as) => {
    let offset = 0;
    let length = 0;
    for (let i = 0; i < u8as.length; i++) {
      length += u8as[i].length;
    }
    const result = new Uint8Array(length);
    for (let i = 0; i < u8as.length; i++) {
      result.set(u8as[i], offset);
      offset += u8as[i].length;
    }
    return result;
  };
  var SS58_PREFIX = new Uint8Array([83, 83, 53, 56, 80, 82, 69]);
  var sshash = (data) => {
    return blake2AsU8a(u8aConcat([SS58_PREFIX, data]), 64);
  };
  var checkAddressChecksum = (decoded, ignoreChecksum = false) => {
    const ss58Length = decoded[0] & 64 ? 2 : 1;
    const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;
    const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
    const length = decoded.length - (isPublicKey ? 2 : 1);
    let isValid = false;
    if (!ignoreChecksum) {
      const hash = sshash(decoded.subarray(0, length));
      isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
    }
    return [isValid, length, ss58Length, ss58Decoded];
  };
  var normalizeSubstrateAddress = (address, prefix = 42) => {
    return encodeSubstrateAddress(decodeSubstrateAddress(address).u8a, prefix);
  };
  function encodeSubstrateAddress(key, ss58Format = 42) {
    const u8a = typeof key === "string" ? import_utf_helpers2.HexString.toU8a(key) : typeof key === "bigint" ? import_utf_helpers2.HexString.toU8a(key.toString(16)) : key;
    if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {
      throw new Error(`ss58Format is not valid, received ${typeof ss58Format} "${ss58Format}"`);
    }
    const allowedDecodedLengths = [1, 2, 4, 8, 32, 33];
    if (!allowedDecodedLengths.includes(u8a.length)) {
      throw new Error(`key length is not valid, received ${u8a.length}, valid values are ${allowedDecodedLengths.join(", ")}`);
    }
    const u8aPrefix = ss58Format < 64 ? new Uint8Array([ss58Format]) : new Uint8Array([
      (ss58Format & 252) >> 2 | 64,
      ss58Format >> 8 | (ss58Format & 3) << 6
    ]);
    const input = u8aConcat([u8aPrefix, u8a]);
    return base58.encode(
      u8aConcat([
        input,
        sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)
      ])
    );
  }
  function decodeSubstrateAddress(address, ignoreChecksum, ss58Format = -1) {
    let realError = null;
    try {
      if (is.substratePublicKey(address)) {
        return {
          u8a: import_utf_helpers2.HexString.toU8a(address),
          bigint: BigInt(address),
          hex: address,
          ss58Prefix: 42
        };
      } else if (address.startsWith("0x")) {
        throw new Error(`Invalid substrate address, received ${address}. Wrong or mangled public key?`);
      }
      const decoded = base58.decode(address);
      const allowedEncodedLengths = [3, 4, 6, 10, 35, 36, 37, 38];
      if (!allowedEncodedLengths.includes(decoded.length)) {
        realError = new Error(`key length is not valid, decoded key length is ${decoded.length}, valid values are ${allowedEncodedLengths.join(", ")}`);
        throw realError;
      }
      const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded, ignoreChecksum);
      if (!ignoreChecksum && !isValid) {
        realError = new Error(`Invalid decoded address checksum`);
        throw realError;
      }
      if (![-1, ss58Decoded].includes(ss58Format)) {
        realError = new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
        throw realError;
      }
      const publicKey = decoded.slice(ss58Length, endPos);
      const hex = import_utf_helpers2.HexString.fromU8a(publicKey);
      return {
        u8a: publicKey,
        hex,
        bigint: BigInt(hex),
        ss58Prefix: ss58Decoded
      };
    } catch (error) {
      throw realError ? realError : new Error(`Decoding ${address}: ${error.message}`);
    }
  }
  var compareSubstrateAddresses = (address1, address2) => {
    const addr1 = typeof address1 === "string" ? address1 : address1.Substrate || address1.substrate;
    const addr2 = typeof address2 === "string" ? address2 : address2.Substrate || address2.substrate;
    if (!addr1 || !addr2) {
      return false;
    }
    try {
      const decoded1 = decodeSubstrateAddress(addr1);
      const decoded2 = decodeSubstrateAddress(addr2);
      return decoded1.bigint === decoded2.bigint;
    } catch (e) {
      return false;
    }
  };
  var addressToEvm = (address, ignoreChecksum) => {
    const truncated = decodeSubstrateAddress(address, ignoreChecksum).u8a.subarray(0, 20);
    return normalizeEthereumAddress(import_utf_helpers2.HexString.fromU8a(truncated));
  };
  var EVM_PREFIX_U8A = new Uint8Array([101, 118, 109, 58]);
  var evmToAddress = (evmAddress, ss58Format = 42) => {
    validate.ethereumAddress(evmAddress);
    const message = u8aConcat([EVM_PREFIX_U8A, import_utf_helpers2.HexString.toU8a(evmAddress)]);
    return encodeSubstrateAddress(blake2AsU8a(message), ss58Format);
  };

  // src/Address/crossAccountId.ts
  var guessAddressAndExtractCrossAccountIdUnsafe = (rawAddress, normalize2 = false) => {
    const address = rawAddress;
    if (typeof address === "object") {
      if (address.hasOwnProperty("eth") && address.hasOwnProperty("sub")) {
        const subPublicKey = address.sub.hasOwnProperty("_hex") && typeof address.sub._hex === "string" ? address.sub._hex : address.sub;
        if (typeof subPublicKey !== "string" || !subPublicKey.startsWith("0x")) {
          throw new Error(`Substrate public key must be a hex string, got ${subPublicKey}`);
        }
        const subBigInt = BigInt(subPublicKey);
        const ethBigInt = BigInt(address.eth);
        if (!(Number(subBigInt === 0n) ^ Number(ethBigInt === 0n))) {
          throw new Error(`One of the addresses must be 0, got eth ${address.eth} and substrate public key ${address.sub}.`);
        }
        if (subBigInt === 0n) {
          return { Ethereum: normalizeEthereumAddress(address.eth) };
        } else {
          return { Substrate: normalizeSubstrateAddress(subPublicKey) };
        }
      } else if (address.hasOwnProperty("Substrate") || address.hasOwnProperty("substrate")) {
        const substrateAddress = address.hasOwnProperty("Substrate") ? address.Substrate : address.substrate;
        if (is.substratePublicKey(substrateAddress)) {
          return { Substrate: normalizeSubstrateAddress(substrateAddress) };
        } else if (is.substrateAddress(substrateAddress)) {
          return { Substrate: normalize2 ? normalizeSubstrateAddress(substrateAddress) : substrateAddress };
        } else {
          throw new Error(`Address ${substrateAddress} is not a valid Substrate address`);
        }
      } else if (address.hasOwnProperty("Ethereum") || address.hasOwnProperty("ethereum")) {
        const ethereumAddress = address.hasOwnProperty("Ethereum") ? address.Ethereum : address.ethereum;
        validate.ethereumAddress(ethereumAddress);
        return { Ethereum: normalize2 ? normalizeEthereumAddress(ethereumAddress) : ethereumAddress };
      } else {
        throw new Error(`Address ${address} is not a valid crossAccountId object (should contain "Substrate"/"substrate" or "Ethereum"/"ethereum" field) or EthCrossAccountId (should contain "eth" and "sub" fields)`);
      }
    }
    if (typeof address === "string") {
      if (is.substrateAddress(address))
        return { Substrate: normalize2 ? normalizeSubstrateAddress(address) : address };
      else if (is.ethereumAddress(address))
        return { Ethereum: normalize2 ? normalizeEthereumAddress(address) : address };
      else if (is.substratePublicKey(address))
        return { Substrate: normalizeSubstrateAddress(address) };
      else {
        throw new Error(`Address ${address} is not a valid Substrate or Ethereum address`);
      }
    }
    throw new Error(`Address ${address} is not a string or object: ${typeof address}`);
  };
  var guessAddressAndExtractCrossAccountIdSafe = (address, normalize2 = false) => {
    try {
      return guessAddressAndExtractCrossAccountIdUnsafe(address, normalize2);
    } catch {
      return null;
    }
  };
  var substrateOrMirrorIfEthereum = (address, normalize2 = false) => {
    const addressObject = guessAddressAndExtractCrossAccountIdUnsafe(address, normalize2);
    return addressObject.Substrate ? addressObject.Substrate : mirror.ethereumToSubstrate(addressObject.Ethereum);
  };
  var addressInAnyFormToEnhancedCrossAccountId = (address, ss58Prefix = 42) => {
    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(address);
    if (crossAccountId.Ethereum) {
      const normalized = normalizeEthereumAddress(crossAccountId.Ethereum);
      return {
        ...crossAccountId,
        address: normalized,
        addressSS58: normalized,
        substratePublicKey: normalized,
        isEthereum: true,
        isSubstrate: false,
        type: "Ethereum"
      };
    } else {
      return {
        ...crossAccountId,
        address: normalizeSubstrateAddress(crossAccountId.Substrate),
        addressSS58: normalizeSubstrateAddress(crossAccountId.Substrate, ss58Prefix),
        substratePublicKey: decodeSubstrateAddress(crossAccountId.Substrate).hex,
        isEthereum: false,
        isSubstrate: true,
        type: "Substrate"
      };
    }
  };

  // src/Address/index.ts
  var ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
  var SUB_PUBLIC_KEY_REGEX = /^0x[a-fA-F0-9]{64}$/;
  var validate = {
    substrateAddress: (address) => {
      decodeSubstrateAddress(address);
      return true;
    },
    ethereumAddress: (address) => {
      if (!is.ethereumAddress(address)) {
        throw new Error(`address "${address}" is not valid ethereum address`);
      }
      return true;
    },
    substratePublicKey: (address) => {
      if (!is.substratePublicKey(address)) {
        throw new Error(`address "${address}" is not valid substrate public key`);
      }
      return true;
    },
    collectionAddress: (address) => {
      if (!is.collectionAddress(address)) {
        throw new Error(`address ${address} is not a collection address`);
      }
      return true;
    },
    nestingAddress: (address) => {
      if (!is.nestingAddress(address)) {
        throw new Error(`address ${address} is not a nesting address`);
      }
      return true;
    },
    collectionId: (collectionId) => {
      if (!is.collectionId(collectionId)) {
        throw new Error(`collectionId should be a number between 0 and 0xffffffff`);
      }
      return true;
    },
    tokenId: (tokenId) => {
      if (!is.tokenId(tokenId)) {
        throw new Error(`collectionId should be a number between 0 and 0xffffffff`);
      }
      return true;
    }
  };
  var is = {
    substrateAddress: (address) => {
      try {
        decodeSubstrateAddress(address);
        return !is.substratePublicKey(address);
      } catch {
        return false;
      }
    },
    ethereumAddress: (address) => {
      return typeof address === "string" && address.length === 42 && !!address.match(ETH_ADDRESS_REGEX);
    },
    substratePublicKey: (address) => {
      return typeof address === "string" && address.length === 66 && !!address.match(SUB_PUBLIC_KEY_REGEX);
    },
    collectionAddress: (address) => {
      return is.ethereumAddress(address) && address.toLowerCase().startsWith(COLLECTION_ADDRESS_PREFIX);
    },
    nestingAddress: (address) => {
      return is.ethereumAddress(address) && address.toLowerCase().startsWith(NESTING_PREFIX);
    },
    collectionId: (collectionId) => {
      return !(typeof collectionId !== "number" || isNaN(collectionId) || collectionId < 0 || collectionId > 4294967295);
    },
    tokenId: (tokenId) => {
      return !(typeof tokenId !== "number" || isNaN(tokenId) || tokenId < 0 || tokenId > 4294967295);
    },
    crossAccountId(obj) {
      return is.substrateAddressObject(obj) || is.ethereumAddressObject(obj);
    },
    crossAccountIdUncapitalized(obj) {
      return is.substrateAddressObjectUncapitalized(obj) || is.ethereumAddressObjectUncapitalized(obj);
    },
    substrateAddressObject(obj) {
      return typeof obj === "object" && typeof obj?.Substrate === "string" && is.substrateAddress(obj.Substrate);
    },
    ethereumAddressObject(obj) {
      return typeof obj === "object" && typeof obj?.Ethereum === "string" && is.ethereumAddress(obj.Ethereum);
    },
    substrateAddressObjectUncapitalized(obj) {
      return typeof obj === "object" && typeof obj?.substrate === "string" && is.substrateAddress(obj.substrate);
    },
    ethereumAddressObjectUncapitalized(obj) {
      return typeof obj === "object" && typeof obj?.ethereum === "string" && is.ethereumAddress(obj.ethereum);
    },
    substrateAddressInAnyForm(address) {
      return typeof address === "string" ? is.substrateAddress(address) : typeof address === "object" && !!address && (is.substrateAddressObject(address) || is.substrateAddressObjectUncapitalized(address));
    },
    ethereumAddressInAnyForm(address) {
      return typeof address === "string" ? is.ethereumAddress(address) : typeof address === "object" && !!address && (is.ethereumAddressObject(address) || is.ethereumAddressObjectUncapitalized(address));
    },
    validAddressInAnyForm(address) {
      return is.ethereumAddressInAnyForm(address) || is.substrateAddressInAnyForm(address);
    }
  };
  var collection = {
    idToAddress: collectionIdToEthAddress,
    addressToId: ethAddressToCollectionId
  };
  var nesting = {
    idsToAddress: collectionIdAndTokenIdToNestingAddress,
    addressToIds: nestingAddressToCollectionIdAndTokenId
  };
  var extract = {
    address: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);
      return crossAccountId.Substrate || crossAccountId.Ethereum;
    },
    addressSafe: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId);
      return crossAccountId ? crossAccountId.Substrate || crossAccountId.Ethereum : null;
    },
    addressNormalized: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);
      return crossAccountId.Substrate || crossAccountId.Ethereum;
    },
    addressNormalizedSafe: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true);
      return crossAccountId ? crossAccountId.Substrate || crossAccountId.Ethereum : null;
    },
    addressForScanNormalized: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);
      return crossAccountId.Substrate || crossAccountId.Ethereum.toLowerCase();
    },
    addressForScanNormalizedSafe: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true);
      return crossAccountId ? crossAccountId.Substrate || crossAccountId.Ethereum.toLowerCase() : null;
    },
    crossAccountId: (addressOrCrossAccountId) => {
      return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);
    },
    crossAccountIdSafe: (addressOrCrossAccountId) => {
      return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId);
    },
    crossAccountIdNormalized: (addressOrCrossAccountId) => {
      return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);
    },
    crossAccountIdNormalizedSafe: (addressOrCrossAccountId) => {
      return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true);
    },
    crossAccountIdUncapitalized: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);
      return crossAccountId.Substrate ? { substrate: crossAccountId.Substrate } : { ethereum: crossAccountId.Ethereum };
    },
    crossAccountIdUncapitalizedSafe: (addressOrCrossAccountId) => {
      try {
        return extract.crossAccountIdUncapitalized(addressOrCrossAccountId);
      } catch {
        return null;
      }
    },
    crossAccountIdUncapitalizedNormalized: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);
      return crossAccountId.Substrate ? { substrate: crossAccountId.Substrate } : { ethereum: crossAccountId.Ethereum };
    },
    crossAccountIdUncapitalizedNormalizedSafe: (addressOrCrossAccountId) => {
      try {
        return extract.crossAccountIdUncapitalizedNormalized(addressOrCrossAccountId);
      } catch {
        return null;
      }
    },
    substrateOrMirrorIfEthereum: (addressOrCrossAccountId) => {
      return substrateOrMirrorIfEthereum(addressOrCrossAccountId);
    },
    substrateOrMirrorIfEthereumSafe: (addressOrCrossAccountId) => {
      try {
        return substrateOrMirrorIfEthereum(addressOrCrossAccountId);
      } catch {
        return null;
      }
    },
    substrateOrMirrorIfEthereumNormalized: (addressOrCrossAccountId) => {
      return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true);
    },
    substrateOrMirrorIfEthereumNormalizedSafe: (addressOrCrossAccountId) => {
      try {
        return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true);
      } catch {
        return null;
      }
    },
    substratePublicKey: (addressOrCrossAccountId) => {
      const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);
      if (!crossAccountId.Substrate) {
        throw new Error("Address is not a substrate address");
      }
      return substrate.decode(crossAccountId.Substrate).hex;
    },
    substratePublicKeySafe: (addressOrCrossAccountId) => {
      try {
        return extract.substratePublicKey(addressOrCrossAccountId);
      } catch {
        return null;
      }
    },
    enhancedCrossAccountId: (addressInAnyForm, ss58Prefix = 42) => {
      return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix);
    },
    enhancedCrossAccountIdSafe: (addressInAnyForm, ss58Prefix = 42) => {
      try {
        return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix);
      } catch {
        return null;
      }
    },
    ethCrossAccountId: (addressInAnyForm) => {
      const addressEnhanced = addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm);
      if (addressEnhanced.Substrate) {
        return {
          eth: "0x0000000000000000000000000000000000000000",
          sub: addressEnhanced.substratePublicKey
        };
      } else {
        return {
          eth: addressEnhanced.address,
          sub: "0x00"
        };
      }
    },
    ethCrossAccountIdSafe: (addressInAnyForm) => {
      try {
        return extract.ethCrossAccountId(addressInAnyForm);
      } catch {
        return null;
      }
    }
  };
  var mirror = {
    substrateToEthereum: addressToEvm,
    ethereumToSubstrate: evmToAddress
  };
  var normalize = {
    substrateAddress: normalizeSubstrateAddress,
    ethereumAddress: normalizeEthereumAddress
  };
  var compare = {
    substrateAddresses: compareSubstrateAddresses,
    ethereumAddresses: compareEthereumAddresses
  };
  var substrate = {
    encode: encodeSubstrateAddress,
    decode: decodeSubstrateAddress,
    compare: compareSubstrateAddresses
  };
  var Address = {
    constants: constants_exports,
    algorithms: imports_exports,
    is,
    validate,
    collection,
    nesting,
    extract,
    mirror,
    normalize,
    compare,
    substrate,
    utils: {
      DWORDHexString
    }
  };

  // src/index.ts
  var StringUtils = __toESM(require_utf_helpers());
  var {
    HexString: HexString4,
    Utf8,
    Utf16
  } = StringUtils;

  // src/ChainLens/ChainLens.ts
  var import_utf_helpers3 = __toESM(require_utf_helpers());
  var UNIQUE_RPCs = {
    quartz: "https://rpc-quartz.unique.network/",
    opal: "https://rpc-opal.unique.network/",
    unique: "https://rpc.unique.network/",
    sapphire: "https://rpc-sapphire.unique.network/",
    rc: "https://rpc-rc.unique.network/"
  };
  var requestRPCFactory = (rpcUrl) => async (method, params) => {
    const fetch = globalThis.fetch;
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ jsonrpc: "2.0", id: 1, method, params })
    });
    const result = await response.json();
    return result.result;
  };
  var decodeTPPArray = (arr) => {
    return arr.map(({ key, permission }) => {
      return {
        key: import_utf_helpers3.Utf8.numberArrayToString(key),
        keyHex: import_utf_helpers3.HexString.fromArray(key),
        permission
      };
    });
  };
  var decodeCollectionProperties = (arr) => {
    const properties = [];
    const propertiesMap = {};
    for (const elem of arr) {
      const { key, value } = elem;
      const decoded = {
        key: import_utf_helpers3.Utf8.numberArrayToString(key),
        keyHex: import_utf_helpers3.HexString.fromArray(key),
        value: import_utf_helpers3.Utf8.numberArrayToString(value),
        valueHex: import_utf_helpers3.HexString.fromArray(value)
      };
      properties.push(decoded);
      propertiesMap[decoded.key] = decoded;
    }
    return {
      properties,
      propertiesMap
    };
  };
  var decodeTokenProperties = (arr, tpps) => {
    const { properties, propertiesMap } = decodeCollectionProperties(arr);
    for (const property of properties) {
      const tppValue = tpps.find((tpp) => tpp.keyHex === property.keyHex).permission;
      property.tokenPropertyPermission = tppValue;
      propertiesMap[property.key].tokenPropertyPermission = tppValue;
    }
    return {
      properties,
      propertiesMap
    };
  };
  var requestCollection = async (requestRPC, collectionId, ss58Prefix) => {
    const rawCollection = await requestRPC("unique_collectionById", [collectionId]);
    if (!rawCollection)
      return null;
    const { properties, propertiesMap } = decodeCollectionProperties(rawCollection.properties);
    const [
      adminListResult,
      effectiveLimits,
      lastTokenId
    ] = await Promise.all([
      requestRPC("unique_adminlist", [collectionId]),
      requestRPC("unique_effectiveCollectionLimits", [collectionId]),
      requestRPC("unique_lastTokenId", [collectionId])
    ]);
    const adminList = adminListResult.map((crossAccountId) => Address_exports.extract.enhancedCrossAccountId(crossAccountId, ss58Prefix));
    const decodedLimits = Object.entries(effectiveLimits).reduce((acc, elem) => {
      const [key, value] = elem;
      acc[key] = {
        key,
        value,
        isDefaultValue: rawCollection.limits[key] === null
      };
      return acc;
    }, {});
    const isNFT = rawCollection.mode === "NFT";
    const isRFT = rawCollection.mode === "ReFungible";
    const isFT = typeof rawCollection.mode === "object" && typeof rawCollection.mode?.Fungible === "number";
    const decodedSponsorship = {
      enabled: typeof rawCollection.sponsorship !== "string",
      confirmed: !!rawCollection.sponsorship?.Confirmed,
      sponsor: typeof rawCollection.sponsorship === "object" && !!rawCollection.sponsorship ? rawCollection.sponsorship.Confirmed ? Address_exports.extract.enhancedCrossAccountId(rawCollection.sponsorship.Confirmed, ss58Prefix) : Address_exports.extract.enhancedCrossAccountId(rawCollection.sponsorship.Unconfirmed, ss58Prefix) : null
    };
    const collection2 = {
      ...rawCollection,
      collectionId,
      collectionAddress: Address_exports.collection.idToAddress(collectionId),
      owner: Address_exports.extract.enhancedCrossAccountId(rawCollection.owner, ss58Prefix),
      adminList,
      mode: rawCollection.mode,
      name: import_utf_helpers3.Utf16.numberArrayToString(rawCollection.name),
      description: import_utf_helpers3.Utf16.numberArrayToString(rawCollection.description),
      tokenPrefix: import_utf_helpers3.Utf8.numberArrayToString(rawCollection.token_prefix),
      sponsorship: rawCollection.sponsorship,
      decodedSponsorship,
      lastTokenId,
      limits: rawCollection.limits,
      decodedLimits,
      permissions: rawCollection.permissions,
      tokenPropertyPermissions: decodeTPPArray(rawCollection.token_property_permissions),
      properties,
      propertiesMap,
      readOnly: rawCollection.read_only,
      additionalInfo: {
        isNFT,
        isRFT,
        isFT,
        type: isRFT ? "RFT" : isFT ? "FT" : "NFT"
      },
      flags: rawCollection.flags || void 0
    };
    return collection2;
  };
  var requestNftToken = async (requestRPC, collectionId, tokenId, ss58Prefix) => {
    const [rawCollection, rawToken] = await Promise.all([
      requestRPC("unique_collectionById", [collectionId]),
      requestRPC("unique_tokenData", [collectionId, tokenId])
    ]);
    if (!rawCollection || rawCollection.mode !== "NFT" || !rawToken || !rawToken.owner) {
      return null;
    }
    const { properties, propertiesMap } = decodeTokenProperties(
      rawToken.properties,
      decodeTPPArray(rawCollection.token_property_permissions)
    );
    const nftToken = {
      collectionId,
      tokenId,
      collectionAddress: Address_exports.collection.idToAddress(collectionId),
      tokenAddress: Address_exports.nesting.idsToAddress(collectionId, tokenId),
      owner: Address_exports.extract.enhancedCrossAccountId(rawToken.owner, ss58Prefix),
      properties,
      propertiesMap
    };
    return nftToken;
  };
  var requestRftToken = async (requestRPC, collectionId, tokenId, ss58Prefix) => {
    const [rawCollection, rawToken] = await Promise.all([
      requestRPC("unique_collectionById", [collectionId]),
      requestRPC("unique_tokenData", [collectionId, tokenId])
    ]);
    if (!rawCollection || rawCollection.mode !== "ReFungible" || !rawToken || typeof rawToken.pieces !== "number") {
      return null;
    }
    let owners = [];
    let allOwnersAreKnown = true;
    if (rawToken.owner) {
      owners = [Address_exports.extract.enhancedCrossAccountId(rawToken.owner, ss58Prefix)];
    } else {
      owners = (await requestRPC("unique_tokenOwners", [collectionId, tokenId])).map((crossAccountId) => Address_exports.extract.enhancedCrossAccountId(crossAccountId, ss58Prefix));
      allOwnersAreKnown = owners.length < 10;
    }
    const { properties, propertiesMap } = decodeTokenProperties(
      rawToken.properties,
      decodeTPPArray(rawCollection.token_property_permissions)
    );
    const rftToken = {
      collectionId,
      tokenId,
      collectionAddress: Address_exports.collection.idToAddress(collectionId),
      tokenAddress: Address_exports.nesting.idsToAddress(collectionId, tokenId),
      owners,
      allOwnersAreKnown,
      isOnlyOneOwner: !!rawToken.owner,
      pieces: rawToken.pieces,
      properties,
      propertiesMap
    };
    return rftToken;
  };
  var collectionIdOrAddressToCollectionId = (collectionIdOrAddress) => {
    return typeof collectionIdOrAddress === "string" ? Address_exports.collection.addressToId(collectionIdOrAddress) : collectionIdOrAddress;
  };
  var generateChainLens = (rpcBaseUrlOrRequestRPC, options = { ss58Prefix: 42 }) => {
    const requestRPC = typeof rpcBaseUrlOrRequestRPC === "string" ? requestRPCFactory(rpcBaseUrlOrRequestRPC) : rpcBaseUrlOrRequestRPC;
    const ss58Prefix = options.ss58Prefix;
    return {
      get ss58Prefix() {
        return ss58Prefix;
      },
      requestRPC: async (method, params) => {
        return requestRPC(method, params);
      },
      requestCollection: async (collectionIdOrAddress) => {
        const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress);
        return requestCollection(requestRPC, collectionId, ss58Prefix);
      },
      requestNftToken: async (collectionIdOrAddress, tokenId) => {
        const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress);
        return requestNftToken(requestRPC, collectionId, tokenId, ss58Prefix);
      },
      requestNftTokenByAddress: async (tokenAddress) => {
        const { collectionId, tokenId } = Address_exports.nesting.addressToIds(tokenAddress);
        return requestNftToken(requestRPC, collectionId, tokenId, ss58Prefix);
      },
      requestRftToken: async (collectionIdOrAddress, tokenId) => {
        const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress);
        return requestRftToken(requestRPC, collectionId, tokenId, ss58Prefix);
      },
      requestRftTokenByAddress: async (tokenAddress) => {
        const { collectionId, tokenId } = Address_exports.nesting.addressToIds(tokenAddress);
        return requestRftToken(requestRPC, collectionId, tokenId, ss58Prefix);
      }
    };
  };
  var ChainLenses = {
    unique: generateChainLens(UNIQUE_RPCs.unique, { ss58Prefix: 7391 }),
    quartz: generateChainLens(UNIQUE_RPCs.quartz, { ss58Prefix: 255 }),
    opal: generateChainLens(UNIQUE_RPCs.opal, { ss58Prefix: 42 }),
    sapphire: generateChainLens(UNIQUE_RPCs.sapphire, { ss58Prefix: 8883 }),
    rc: generateChainLens(UNIQUE_RPCs.rc, { ss58Prefix: 42 })
  };

  // src/ChainLens/index.ts
  var constants = {
    maxRefungiblePieces: 1000000000000000000000n,
    collectionCreationPrice: 2
  };
  var ChainLens_default = ChainLenses;
  return __toCommonJS(ChainLens_exports);
})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chainLens.min.js.map