declare enum RoyaltyType {
    DEFAULT = "DEFAULT",
    PRIMARY_ONLY = "PRIMARY_ONLY"
}
interface UniqueRoyaltyPart {
    version: number;
    royaltyType: RoyaltyType | `${RoyaltyType}`;
    decimals: number;
    value: bigint;
    address: string;
}
type UniqueRoyaltyPartToEncode = {
    version?: number;
    royaltyType?: RoyaltyType | `${RoyaltyType}`;
    decimals?: number;
    value: bigint;
    address: string;
};
type RoyaltyAmount = {
    address: string;
    amount: bigint;
};
type LibPart = {
    account: string;
    value: bigint;
};
type IV2Royalty = {
    address: string;
    percent: number;
    isPrimaryOnly?: boolean;
};

declare const ROYALTIES_PROPERTY = "royalties";
declare const get42Zeros: () => string;
declare const splitStringEvery: (str: string, every: number) => string[];
declare const encodeAddress: (address: string) => [boolean, string];
declare const toLibPart: (part: UniqueRoyaltyPart) => LibPart;
declare const parseRoyaltyPart: (part: UniqueRoyaltyPartToEncode) => UniqueRoyaltyPart;
declare const parseRoyalties: (parts: UniqueRoyaltyPartToEncode[]) => UniqueRoyaltyPart[];

declare const utils_ROYALTIES_PROPERTY: typeof ROYALTIES_PROPERTY;
declare const utils_encodeAddress: typeof encodeAddress;
declare const utils_get42Zeros: typeof get42Zeros;
declare const utils_parseRoyalties: typeof parseRoyalties;
declare const utils_parseRoyaltyPart: typeof parseRoyaltyPart;
declare const utils_splitStringEvery: typeof splitStringEvery;
declare const utils_toLibPart: typeof toLibPart;
declare namespace utils {
  export { utils_ROYALTIES_PROPERTY as ROYALTIES_PROPERTY, utils_encodeAddress as encodeAddress, utils_get42Zeros as get42Zeros, utils_parseRoyalties as parseRoyalties, utils_parseRoyaltyPart as parseRoyaltyPart, utils_splitStringEvery as splitStringEvery, utils_toLibPart as toLibPart };
}

declare const Royalties: {
    part: {
        calculate: (part: UniqueRoyaltyPartToEncode, sellPrice: bigint) => RoyaltyAmount;
        decode: (encoded: string) => UniqueRoyaltyPart;
        encode: (royaltyPart: UniqueRoyaltyPartToEncode) => string;
        validate: (part: UniqueRoyaltyPartToEncode) => part is UniqueRoyaltyPart;
    };
    calculate: (royalties: UniqueRoyaltyPartToEncode[], isPrimarySale: boolean, sellPrice: bigint) => RoyaltyAmount[];
    decode: (encoded: string) => UniqueRoyaltyPart[];
    encode: (parts: UniqueRoyaltyPartToEncode[]) => string;
    validate: (royalties: UniqueRoyaltyPartToEncode[]) => royalties is UniqueRoyaltyPart[];
    uniqueV2: {
        decode: (encoded: string) => IV2Royalty[];
        encode: (royalties: IV2Royalty[]) => string;
    };
    utils: typeof utils;
};

export { type IV2Royalty, type LibPart, Royalties, type RoyaltyAmount, RoyaltyType, type UniqueRoyaltyPart, type UniqueRoyaltyPartToEncode };
