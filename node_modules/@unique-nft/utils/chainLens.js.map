{"version":3,"sources":["../src/ChainLens/index.ts","../src/Address/index.ts","../src/Address/constants.ts","../src/Address/imports.ts","../src/Address/ethereum.ts","../src/Address/substrate.ts","../src/Address/crossAccountId.ts","../src/index.ts","../src/Utils/coin.ts","../src/ChainLens/ChainLens.ts"],"sourcesContent":["import {ChainLenses, generateChainLens} from './ChainLens'\n\nconst constants = {\n  maxRefungiblePieces: 1000000000000000000000n,\n  collectionCreationPrice: 2,\n}\n\nexport {ChainLenses, constants, generateChainLens}\nexport default ChainLenses\n\nexport type {\n  DecodedProperty,\n  UNIQUE_CHAINS,\n  IChainLens,\n  INftToken,\n  IRftToken,\n  ICollection,\n  CollectionType,\n  DecodedPropertiesMap,\n  DecodedCollectionLimits,\n  CollectionLimits,\n  CollectionEffectiveLimits,\n  CollectionPermissions,\n  TokenPropertyPermission,\n  TokenPropertyPermissionValue,\n} from './ChainLens'\n\n","import {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from './constants'\n\nimport {\n  addressToEvm, compareSubstrateAddresses,\n  decodeSubstrateAddress, encodeSubstrateAddress,\n  evmToAddress,\n  normalizeSubstrateAddress\n} from './substrate'\n\nimport {\n  collectionIdAndTokenIdToNestingAddress,\n  collectionIdToEthAddress, compareEthereumAddresses, DWORDHexString,\n  ethAddressToCollectionId,\n  nestingAddressToCollectionIdAndTokenId,\n  normalizeEthereumAddress\n} from './ethereum'\nimport {\n  CrossAccountId, CrossAccountIdUncapitalized,\n  EthAddressObj, EthAddressObjUncapitalized,\n  SubAddressObj, SubAddressObjUncapitalized,\n  EnhancedCrossAccountId, EthCrossAccountId,\n} from '../types'\nimport {\n  addressInAnyFormToEnhancedCrossAccountId,\n  guessAddressAndExtractCrossAccountIdSafe,\n  guessAddressAndExtractCrossAccountIdUnsafe,\n  substrateOrMirrorIfEthereum\n} from './crossAccountId'\n\nimport * as algorithms from './imports'\nimport * as constants from './constants'\n\nexport {constants, algorithms}\n\nconst ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nconst SUB_PUBLIC_KEY_REGEX = /^0x[a-fA-F0-9]{64}$/\n\nexport type DecodeSubstrateAddressResult = {\n  u8a: Uint8Array\n  hex: string\n  bigint: bigint\n  ss58Prefix: number\n}\n\nexport const validate = {\n  substrateAddress: (address: string) => {\n    decodeSubstrateAddress(address)\n    return true\n  },\n  ethereumAddress: (address: string) => {\n    if (!is.ethereumAddress(address)) {\n      throw new Error(`address \"${address}\" is not valid ethereum address`)\n    }\n    return true\n  },\n  substratePublicKey: (address: string) => {\n    if (!is.substratePublicKey(address)) {\n      throw new Error(`address \"${address}\" is not valid substrate public key`)\n    }\n    return true\n  },\n  collectionAddress: (address: string) => {\n    if (!is.collectionAddress(address)) {\n      throw new Error(`address ${address} is not a collection address`)\n    }\n    return true\n  },\n  nestingAddress: (address: string) => {\n    if (!is.nestingAddress(address)) {\n      throw new Error(`address ${address} is not a nesting address`)\n    }\n    return true\n  },\n  collectionId: (collectionId: number) => {\n    if (!is.collectionId(collectionId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n  tokenId: (tokenId: number) => {\n    if (!is.tokenId(tokenId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n}\n\nexport const is = {\n  substrateAddress: (address: string): boolean => {\n    try {\n      decodeSubstrateAddress(address)\n      return !is.substratePublicKey(address)\n    } catch {\n      return false\n    }\n  },\n  ethereumAddress: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 42 && !!address.match(ETH_ADDRESS_REGEX)\n  },\n  substratePublicKey: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 66 && !!address.match(SUB_PUBLIC_KEY_REGEX)\n  },\n\n  collectionAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(COLLECTION_ADDRESS_PREFIX)\n  },\n  nestingAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(NESTING_PREFIX)\n  },\n\n  collectionId: (collectionId: number): boolean => {\n    return !(typeof collectionId !== 'number' || isNaN(collectionId) || collectionId < 0 || collectionId > 0xffffffff)\n  },\n  tokenId: (tokenId: number): boolean => {\n    return !(typeof tokenId !== 'number' || isNaN(tokenId) || tokenId < 0 || tokenId > 0xffffffff)\n  },\n\n  crossAccountId(obj: any): obj is CrossAccountId {\n    return is.substrateAddressObject(obj) || is.ethereumAddressObject(obj)\n  },\n  crossAccountIdUncapitalized(obj: any): obj is CrossAccountIdUncapitalized {\n    return is.substrateAddressObjectUncapitalized(obj) || is.ethereumAddressObjectUncapitalized(obj)\n  },\n  substrateAddressObject(obj: any): obj is SubAddressObj {\n    return typeof obj === 'object' && typeof obj?.Substrate === 'string' && is.substrateAddress(obj.Substrate)\n  },\n  ethereumAddressObject(obj: any): obj is EthAddressObj {\n    return typeof obj === 'object' && typeof obj?.Ethereum === 'string' && is.ethereumAddress(obj.Ethereum)\n  },\n  substrateAddressObjectUncapitalized(obj: any): obj is SubAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.substrate === 'string' && is.substrateAddress(obj.substrate)\n  },\n  ethereumAddressObjectUncapitalized(obj: any): obj is EthAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.ethereum === 'string' && is.ethereumAddress(obj.ethereum)\n  },\n  substrateAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.substrateAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.substrateAddressObject(address) || is.substrateAddressObjectUncapitalized(address))\n      )\n  },\n  ethereumAddressInAnyForm(address: any): address is string | EthAddressObj | EthAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.ethereumAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.ethereumAddressObject(address) || is.ethereumAddressObjectUncapitalized(address))\n      )\n  },\n  validAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized | EthAddressObj | EthAddressObjUncapitalized {\n    return is.ethereumAddressInAnyForm(address) || is.substrateAddressInAnyForm(address)\n  }\n}\n\nexport const collection = {\n  idToAddress: collectionIdToEthAddress,\n  addressToId: ethAddressToCollectionId,\n}\nexport const nesting = {\n  idsToAddress: collectionIdAndTokenIdToNestingAddress,\n  addressToIds: nestingAddressToCollectionIdAndTokenId,\n}\n\nexport const extract = {\n  address: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressForScanNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string\n  },\n  addressForScanNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string : null\n  },\n\n\n  crossAccountId: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n  },\n  crossAccountIdSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n  },\n\n  crossAccountIdNormalized: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n  },\n  crossAccountIdNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n  },\n\n  crossAccountIdUncapitalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n  crossAccountIdUncapitalizedNormalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalizedNormalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n\n  substrateOrMirrorIfEthereum: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n  },\n  substrateOrMirrorIfEthereumSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  substrateOrMirrorIfEthereumNormalized: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n  },\n  substrateOrMirrorIfEthereumNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n    } catch {\n      return null\n    }\n  },\n\n  substratePublicKey: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    if (!crossAccountId.Substrate) {\n      throw new Error('Address is not a substrate address')\n    }\n    return substrate.decode(crossAccountId.Substrate).hex\n  },\n  substratePublicKeySafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return extract.substratePublicKey(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  enhancedCrossAccountId: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n    return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n  },\n  enhancedCrossAccountIdSafe: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId | null => {\n    try {\n      return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n    } catch {\n      return null\n    }\n  },\n\n  ethCrossAccountId: (addressInAnyForm: string | object): EthCrossAccountId => {\n    const addressEnhanced = addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm)\n    if (addressEnhanced.Substrate) {\n      return {\n        eth: '0x0000000000000000000000000000000000000000',\n        sub: addressEnhanced.substratePublicKey,\n      }\n    } else {\n      return {\n        eth: addressEnhanced.address,\n        sub: '0x00',\n      }\n    }\n  },\n  ethCrossAccountIdSafe: (addressInAnyForm: string | object): EthCrossAccountId | null => {\n    try {\n      return extract.ethCrossAccountId(addressInAnyForm)\n    } catch {\n      return null\n    }\n  }\n}\n\nexport const mirror = {\n  substrateToEthereum: addressToEvm,\n  ethereumToSubstrate: evmToAddress,\n}\n\nexport const normalize = {\n  substrateAddress: normalizeSubstrateAddress,\n  ethereumAddress: normalizeEthereumAddress,\n}\n\nexport const compare = {\n  substrateAddresses: compareSubstrateAddresses,\n  ethereumAddresses: compareEthereumAddresses,\n}\n\nexport const substrate = {\n  encode: encodeSubstrateAddress,\n  decode: decodeSubstrateAddress,\n  compare: compareSubstrateAddresses,\n}\n\nexport const Address = {\n  constants,\n  algorithms,\n  is,\n  validate,\n  collection,\n  nesting,\n  extract,\n  mirror,\n  normalize,\n  compare,\n  substrate,\n  utils: {\n    DWORDHexString,\n  }\n}\n","export const STATIC_ADDRESSES = <const>{\r\n  contractHelpers: '0x842899ECF380553E8a4de75bF534cdf6fBF64049',\r\n  collectionHelpers: '0x6C4E9fE1AE37a41E93CEE429e8E1881aBdcbb54F',\r\n}\r\nexport const NESTING_PREFIX = <const>'0xf8238ccfff8ed887463fd5e0'\r\nexport const COLLECTION_ADDRESS_PREFIX = <const>'0x17c4e6453cc49aaaaeaca894e6d9683e'\r\n","import basex from 'base-x'\r\nimport {keccak_256} from '@noble/hashes/sha3'\r\nimport {blake2b} from '@noble/hashes/blake2b'\r\n\r\nconst BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\r\nconst BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\nconst base58 = basex(BASE58_ALPHABET)\r\nconst base64 = basex(BASE64_ALPHABET)\r\n\r\nexport {keccak_256, blake2b, base58, base64, basex}\r\n","import {HexString} from 'utf-helpers'\n\nimport {keccak_256} from \"./imports\"\nimport {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from \"./constants\"\nimport {is, validate} from \"./index\"\n\n\nexport const DWORDHexString = {\n  _checkU32: (num: number): number => {\n    if (typeof num !== 'number') throw new Error(`Passed number is not a number: ${typeof num}, ${num}`)\n    if (isNaN(num)) throw new Error(`Passed number is NaN: ${num}`)\n    if (num < 0) throw new Error(`Passed number is less than 0: ${num}`)\n    if (num > 0xFFFFFFFF) throw new Error(`Passed number is more than 2**32: ${num}`)\n    if (num !== Math.floor(num)) throw new Error(`Passed number is not an integer number: ${num}`)\n\n    return num\n  },\n  fromNumber: (n: number): string => {\n    return DWORDHexString._checkU32(n).toString(16).padStart(8, '0')\n  },\n  toNumber: (s: string): number => {\n    const num: number = parseInt(s, 16)\n\n    if (isNaN(num)) throw new Error(`Passed string is not hexadecimal: ${s}`)\n\n    return DWORDHexString._checkU32(num)\n  }\n}\n\n\nconst unsafeNormalizeEthereumAddress = (address: string) => {\n  const addr = address.toLowerCase().replace(/^0x/i, '')\n  const addressHash = HexString.fromU8a(keccak_256(addr)).replace(/^0x/i, '')\n\n  let checksumAddress = '0x'\n\n  for (let i = 0; i < addr.length; i++) {\n    checksumAddress += (parseInt(addressHash[i], 16) > 7)\n      ? addr[i].toUpperCase()\n      : addr[i]\n  }\n\n  return checksumAddress\n}\nexport const normalizeEthereumAddress = (address: string) => {\n  validate.ethereumAddress(address)\n  return unsafeNormalizeEthereumAddress(address)\n}\n\ntype EthAddressObj = { Ethereum: string }\nexport const compareEthereumAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as EthAddressObj).Ethereum || (address1 as any).ethereum) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as EthAddressObj).Ethereum || (address2 as any).ethereum) as string | undefined\n\n  if (!addr1 || !addr2 || !is.ethereumAddress(addr1) || !is.ethereumAddress(addr2)) {\n    return false\n  }\n  return addr1.toLowerCase() === addr2.toLowerCase()\n\n}\n\nexport const collectionIdToEthAddress = (collectionId: number): string => {\n  validate.collectionId(collectionId)\n  return unsafeNormalizeEthereumAddress(\n    COLLECTION_ADDRESS_PREFIX +\n    DWORDHexString.fromNumber(collectionId)\n  )\n}\nexport const ethAddressToCollectionId = (address: string): number => {\n  validate.collectionAddress(address)\n  return DWORDHexString.toNumber(address.slice(-8))\n}\n\nexport const collectionIdAndTokenIdToNestingAddress = (collectionId: number, tokenId: number): string => {\n  validate.collectionId(collectionId)\n  validate.tokenId(tokenId)\n\n  return unsafeNormalizeEthereumAddress(\n    NESTING_PREFIX +\n    DWORDHexString.fromNumber(collectionId) +\n    DWORDHexString.fromNumber(tokenId)\n  )\n}\n\nexport const nestingAddressToCollectionIdAndTokenId = (address: string): { collectionId: number, tokenId: number } => {\n  validate.nestingAddress(address)\n  return {\n    collectionId: DWORDHexString.toNumber(address.slice(-16, -8)),\n    tokenId: DWORDHexString.toNumber(address.slice(-8)),\n  }\n}\n","import {base58, blake2b} from './imports'\nimport {DecodeSubstrateAddressResult, validate, is} from './index'\nimport {normalizeEthereumAddress} from './ethereum'\nimport {HexString} from 'utf-helpers'\n\nconst blake2AsU8a = (u8a: Uint8Array, dkLen: 8 | 16 | 32 | 48 | 64 = 32): Uint8Array => {\n  return blake2b(u8a, {dkLen})\n}\n\nconst u8aConcat = (u8as: readonly Uint8Array[]): Uint8Array => {\n  let offset = 0\n\n  let length = 0\n\n  for (let i = 0; i < u8as.length; i++) {\n    length += u8as[i].length\n  }\n\n  const result = new Uint8Array(length)\n\n  for (let i = 0; i < u8as.length; i++) {\n    result.set(u8as[i], offset)\n    offset += u8as[i].length\n  }\n\n  return result\n}\n\n// strToU8a('SS58PRE')\nconst SS58_PREFIX = new Uint8Array([83, 83, 53, 56, 80, 82, 69])\n\nconst sshash = (data: Uint8Array): Uint8Array => {\n  return blake2AsU8a(u8aConcat([SS58_PREFIX, data]), 64);\n}\n\nconst checkAddressChecksum = (decoded: Uint8Array, ignoreChecksum: boolean = false): [boolean, number, number, number] => {\n  const ss58Length = (decoded[0] & 0b0100_0000) ? 2 : 1;\n  const ss58Decoded = ss58Length === 1\n    ? decoded[0]\n    : ((decoded[0] & 0x3f) << 2) | (decoded[1] >> 6) | ((decoded[1] & 0x3f) << 8);\n\n  // 32/33 bytes public + 2 bytes checksum + prefix\n  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);\n  const length = decoded.length - (isPublicKey ? 2 : 1);\n\n  let isValid = false\n\n  if (!ignoreChecksum) {\n    // calculate the hash and do the checksum byte checks\n    const hash = sshash(decoded.subarray(0, length));\n    isValid = (decoded[0] & 0x80) === 0 && ![46, 47].includes(decoded[0]) && (\n      isPublicKey\n        ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1]\n        : decoded[decoded.length - 1] === hash[0]\n    )\n  }\n\n  return [isValid, length, ss58Length, ss58Decoded];\n}\n\nexport const normalizeSubstrateAddress = (address: string, prefix: number = 42): string => {\n  return encodeSubstrateAddress(decodeSubstrateAddress(address).u8a, prefix)\n}\n\n\nexport function encodeSubstrateAddress(key: Uint8Array | string | bigint, ss58Format: number = 42): string {\n  const u8a: Uint8Array = typeof key === 'string'\n    ? HexString.toU8a(key)\n    : typeof key === 'bigint'\n      ? HexString.toU8a(key.toString(16))\n      : key\n\n  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {\n    throw new Error(`ss58Format is not valid, received ${typeof ss58Format} \"${ss58Format}\"`)\n  }\n\n  const allowedDecodedLengths = [1, 2, 4, 8, 32, 33]\n  if (!allowedDecodedLengths.includes(u8a.length)) {\n    throw new Error(`key length is not valid, received ${u8a.length}, valid values are ${allowedDecodedLengths.join(', ')}`)\n  }\n\n  const u8aPrefix = ss58Format < 64\n    ? new Uint8Array([ss58Format])\n    : new Uint8Array([\n      ((ss58Format & 0xfc) >> 2) | 0x40,\n      (ss58Format >> 8) | ((ss58Format & 0x03) << 6)\n    ])\n\n  const input = u8aConcat([u8aPrefix, u8a])\n\n  return base58.encode(\n    u8aConcat([\n      input,\n      sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)\n    ])\n  );\n}\n\nexport function decodeSubstrateAddress(address: string, ignoreChecksum?: boolean, ss58Format: number = -1): DecodeSubstrateAddressResult {\n  let realError: Error | null = null\n\n  try {\n    if (is.substratePublicKey(address)) {\n      return {\n        u8a: HexString.toU8a(address),\n        bigint: BigInt(address),\n        hex: address,\n        ss58Prefix: 42,\n      }\n    } else if (address.startsWith('0x')) {\n      throw new Error(`Invalid substrate address, received ${address}. Wrong or mangled public key?`)\n    }\n\n    const decoded = base58.decode(address);\n\n    const allowedEncodedLengths = [3, 4, 6, 10, 35, 36, 37, 38]\n\n    if (!allowedEncodedLengths.includes(decoded.length)) {\n      realError = new Error(`key length is not valid, decoded key length is ${decoded.length}, valid values are ${allowedEncodedLengths.join(', ')}`)\n      throw realError\n    }\n\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded, ignoreChecksum)\n\n    if (!ignoreChecksum && !isValid) {\n      realError = new Error(`Invalid decoded address checksum`)\n      throw realError\n    }\n    if (![-1, ss58Decoded].includes(ss58Format)) {\n      realError = new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`)\n      throw realError\n    }\n\n    const publicKey = decoded.slice(ss58Length, endPos)\n\n    const hex: string = HexString.fromU8a(publicKey)\n    return {\n      u8a: publicKey,\n      hex,\n      bigint: BigInt(hex),\n      ss58Prefix: ss58Decoded,\n    }\n  } catch (error) {\n    throw realError\n      ? realError\n      : new Error(`Decoding ${address}: ${(error as Error).message}`)\n  }\n}\n\ntype SubAddressObj = { Substrate: string }\nexport const compareSubstrateAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as SubAddressObj).Substrate || (address1 as any).substrate) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as SubAddressObj).Substrate || (address2 as any).substrate) as string | undefined\n\n  if (!addr1 || !addr2) {\n    return false\n  }\n\n  try {\n    const decoded1 = decodeSubstrateAddress(addr1)\n    const decoded2 = decodeSubstrateAddress(addr2)\n    return decoded1.bigint === decoded2.bigint\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addressToEvm = (address: string, ignoreChecksum?: boolean): string => {\n  const truncated = decodeSubstrateAddress(address, ignoreChecksum).u8a.subarray(0, 20)\n  return normalizeEthereumAddress(HexString.fromU8a(truncated))\n}\n\n// strToU8a('evm:')\nconst EVM_PREFIX_U8A = new Uint8Array([101, 118, 109, 58])\nexport const evmToAddress = (evmAddress: string, ss58Format: number = 42): string => {\n  validate.ethereumAddress(evmAddress)\n\n  const message = u8aConcat([EVM_PREFIX_U8A, HexString.toU8a(evmAddress)])\n\n  return encodeSubstrateAddress(blake2AsU8a(message), ss58Format)\n}\n","import {normalizeEthereumAddress} from './ethereum'\nimport {normalizeSubstrateAddress, decodeSubstrateAddress} from './substrate'\nimport {CrossAccountId, EnhancedCrossAccountId} from '../types'\nimport {is, mirror, validate} from './index'\n\nexport const guessAddressAndExtractCrossAccountIdUnsafe = (rawAddress: string | object, normalize: boolean = false): CrossAccountId => {\n  const address = rawAddress as any\n\n  if (typeof address === 'object') {\n    if (address.hasOwnProperty('eth') && address.hasOwnProperty('sub')) {\n      // bn.js value extraction for ethers.js\n      const subPublicKey = (address.sub.hasOwnProperty('_hex') && typeof address.sub._hex === 'string')\n        ? address.sub._hex\n        : address.sub\n      if (typeof subPublicKey !== 'string' || !subPublicKey.startsWith('0x')) {\n        throw new Error(`Substrate public key must be a hex string, got ${subPublicKey}`)\n      }\n\n      const subBigInt = BigInt(subPublicKey)\n      const ethBigInt = BigInt(address.eth)\n\n      if (!(Number(subBigInt === 0n) ^ Number(ethBigInt === 0n))) {\n        throw new Error(`One of the addresses must be 0, got eth ${address.eth} and substrate public key ${address.sub}.`)\n      }\n\n      // always normalize addresses from the EthCrossAccountId\n      if (subBigInt === 0n) {\n        return {Ethereum: normalizeEthereumAddress(address.eth)}\n      } else {\n        return {Substrate: normalizeSubstrateAddress(subPublicKey)}\n      }\n    } else if (address.hasOwnProperty('Substrate') || address.hasOwnProperty('substrate')) {\n      const substrateAddress = address.hasOwnProperty('Substrate') ? address.Substrate : address.substrate\n      if (is.substratePublicKey(substrateAddress)) {\n        return {Substrate: normalizeSubstrateAddress(substrateAddress)}\n      } else if (is.substrateAddress(substrateAddress)) {\n        return {Substrate: normalize ? normalizeSubstrateAddress(substrateAddress) : substrateAddress}\n      } else {\n        throw new Error(`Address ${substrateAddress} is not a valid Substrate address`)\n      }\n    } else if (address.hasOwnProperty('Ethereum') || address.hasOwnProperty('ethereum')) {\n      const ethereumAddress = address.hasOwnProperty('Ethereum') ? address.Ethereum : address.ethereum\n      validate.ethereumAddress(ethereumAddress)\n      return {Ethereum: normalize ? normalizeEthereumAddress(ethereumAddress) : ethereumAddress}\n    } else {\n      throw new Error(`Address ${address} is not a valid crossAccountId object (should contain \"Substrate\"/\"substrate\" or \"Ethereum\"/\"ethereum\" field) or EthCrossAccountId (should contain \"eth\" and \"sub\" fields)`)\n    }\n  }\n\n  if (typeof address === 'string') {\n    if (is.substrateAddress(address)) return {Substrate: normalize ? normalizeSubstrateAddress(address) : address}\n    else if (is.ethereumAddress(address)) return {Ethereum: normalize ? normalizeEthereumAddress(address) : address}\n    else if (is.substratePublicKey(address)) return {Substrate: normalizeSubstrateAddress(address)}\n    else {\n      throw new Error(`Address ${address} is not a valid Substrate or Ethereum address`)\n    }\n  }\n\n  throw new Error(`Address ${address} is not a string or object: ${typeof address}`)\n}\n\nexport const guessAddressAndExtractCrossAccountIdSafe = (address: string | object, normalize: boolean = false): CrossAccountId | null => {\n  try {\n    return guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  } catch {\n    return null\n  }\n}\n\nexport const substrateOrMirrorIfEthereum = (address: string | object, normalize: boolean = false): string => {\n  const addressObject = guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  return addressObject.Substrate\n    ? addressObject.Substrate\n    : mirror.ethereumToSubstrate(addressObject.Ethereum as string)\n}\n\nexport const addressInAnyFormToEnhancedCrossAccountId = (address: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n  const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(address)\n\n  if (crossAccountId.Ethereum) {\n    const normalized = normalizeEthereumAddress(crossAccountId.Ethereum)\n    return {\n      ...crossAccountId,\n      address: normalized,\n      addressSS58: normalized,\n      substratePublicKey: normalized,\n      isEthereum: true,\n      isSubstrate: false,\n      type: 'Ethereum',\n    }\n  } else {\n    return {\n      ...crossAccountId,\n      address: normalizeSubstrateAddress(crossAccountId.Substrate as string),\n      addressSS58: normalizeSubstrateAddress(crossAccountId.Substrate as string, ss58Prefix),\n      substratePublicKey: decodeSubstrateAddress(crossAccountId.Substrate as string).hex,\n      isEthereum: false,\n      isSubstrate: true,\n      type: 'Substrate',\n    }\n  }\n}\n","import * as Address from './Address'\nimport * as constants from './Address/constants'\nimport * as StringUtils from 'utf-helpers'\nimport * as CoinUtils from './Utils/coin'\n\nexport {\n  Address,\n  StringUtils,\n  constants,\n  CoinUtils,\n}\n\nexport const {\n  HexString,\n  Utf8,\n  Utf16,\n} = StringUtils\n\nexport const HexUtils = StringUtils.HexString\n\nexport {Coin} from './Utils/coin'\nexport type {ICoin, ICoinFormats} from './Utils/coin'\n\nexport * from './types'\n","export * from 'coin-format'\n","import {Address, CrossAccountIdUncapitalized, EnhancedCrossAccountId} from '../index'\n\nimport {Utf8, Utf16, HexString} from 'utf-helpers'\n\ntype MakeFieldsNullable<Ob> = { [K in keyof Ob]: Ob[K] | null }\n\nexport enum UNIQUE_CHAINS {\n  unique = 'unique',\n  quartz = 'quartz',\n  opal = 'opal',\n  sapphire = 'sapphire',\n  rc = 'rc',\n}\n\nconst UNIQUE_RPCs: { [K in UNIQUE_CHAINS]: string } = {\n  quartz: 'https://rpc-quartz.unique.network/',\n  opal: 'https://rpc-opal.unique.network/',\n  unique: 'https://rpc.unique.network/',\n  sapphire: 'https://rpc-sapphire.unique.network/',\n  rc: 'https://rpc-rc.unique.network/',\n}\n\ntype RequestRPC = <T = any>(method: string, params: unknown[]) => Promise<T>\n\nconst requestRPCFactory = (rpcUrl: string): RequestRPC => async (method, params) => {\n  const fetch = globalThis.fetch\n  const response = await fetch(rpcUrl, {\n    method: 'POST',\n    headers: {'Content-Type': 'application/json'},\n    body: JSON.stringify({jsonrpc: \"2.0\", id: 1, method, params}),\n  })\n  const result = await response.json()\n  return result.result\n}\n\nexport type TokenPropertyPermissionValue = {\n  mutable: boolean\n  collection_admin: boolean\n  token_owner: boolean\n}\nexport type TokenPropertyPermission = {\n  key: string\n  keyHex: string\n  permission: TokenPropertyPermissionValue\n}\n\nconst decodeTPPArray = (arr: Array<{ key: number[], permission: any }>): TokenPropertyPermission[] => {\n  return arr.map(({key, permission}) => {\n    return {\n      key: Utf8.numberArrayToString(key),\n      keyHex: HexString.fromArray(key),\n      permission: permission as TokenPropertyPermissionValue,\n    }\n  })\n}\n\nexport interface DecodedProperty {\n  key: string\n  value: string\n  keyHex: string\n  valueHex: string\n}\n\nexport interface DecodedPropertyWithTokenPropertyPermission extends DecodedProperty {\n  tokenPropertyPermission: TokenPropertyPermissionValue\n}\n\nexport type DecodedPropertiesMap = Record<string, DecodedProperty>\nexport type DecodedPropertiesWithTokenPropertyPermissionsMap = Record<string, DecodedPropertyWithTokenPropertyPermission>\n\nconst decodeCollectionProperties = (arr: Array<{ key: number[], value: number[] }>): { properties: DecodedProperty[], propertiesMap: DecodedPropertiesMap } => {\n  const properties: DecodedProperty[] = []\n  const propertiesMap: Record<string, DecodedProperty> = {}\n\n  for (const elem of arr) {\n    const {key, value} = elem\n    const decoded: DecodedProperty = {\n      key: Utf8.numberArrayToString(key),\n      keyHex: HexString.fromArray(key),\n      value: Utf8.numberArrayToString(value),\n      valueHex: HexString.fromArray(value),\n    }\n    properties.push(decoded)\n    propertiesMap[decoded.key] = decoded\n  }\n  return {\n    properties,\n    propertiesMap,\n  }\n}\n\nconst decodeTokenProperties = (arr: Array<{ key: number[], value: number[] }>, tpps: TokenPropertyPermission[]): { properties: DecodedPropertyWithTokenPropertyPermission[], propertiesMap: DecodedPropertiesWithTokenPropertyPermissionsMap } => {\n  const {properties, propertiesMap} = decodeCollectionProperties(arr) as {\n    properties: DecodedPropertyWithTokenPropertyPermission[]\n    propertiesMap: DecodedPropertiesWithTokenPropertyPermissionsMap\n  }\n\n  for (const property of properties) {\n    const tppValue = tpps.find(tpp => tpp.keyHex === property.keyHex)!.permission\n    property.tokenPropertyPermission = tppValue\n    propertiesMap[property.key].tokenPropertyPermission = tppValue\n  }\n\n  return {\n    properties,\n    propertiesMap,\n  }\n}\n\nexport interface CollectionEffectiveLimits {                                  // default value\n  account_token_ownership_limit: number                                // 100000\n  owner_can_destroy: boolean                                           // true\n  owner_can_transfer: boolean                                          // false\n  sponsor_approve_timeout: number                                      // 5\n  sponsor_transfer_timeout: number                                     // 5\n  sponsored_data_rate_limit: 'SponsoringDisabled' | { Blocks: number } // \"SponsoringDisabled\"\n  sponsored_data_size: number                                          // 2048\n  token_limit: number                                                  // 4294967295\n  transfers_enabled: boolean                                           // true\n}\n\nexport type CollectionLimits = MakeFieldsNullable<CollectionEffectiveLimits>\n\nexport type DecodedCollectionLimits = {\n  [K in keyof CollectionEffectiveLimits]: {\n    key: K\n    value: CollectionEffectiveLimits[K]\n    isDefaultValue: boolean\n  }\n}\n\nexport interface CollectionPermissions {                                             // default value\n  access: 'Normal' | 'AllowList'                                              // 'Normal'\n  mint_mode: boolean                                                          // false\n  nesting: {\n    token_owner: boolean                                                      // false\n    collection_admin: boolean                                                 // false\n    restricted: null | number[]                                               // null\n  }\n}\n\nexport type CollectionType = 'NFT' | 'RFT' | 'FT'\n\nexport interface ICollection {\n  collectionId: number\n  collectionAddress: string\n  owner: EnhancedCrossAccountId\n  adminList: EnhancedCrossAccountId[]\n  mode: 'NFT' | 'ReFungible' | { Fungible: number }\n  name: string\n  description: string\n  tokenPrefix: string\n  sponsorship: 'Disabled' | { Confirmed: string } | { Unconfirmed: string }\n  decodedSponsorship: {\n    enabled: boolean\n    confirmed: boolean\n    sponsor: EnhancedCrossAccountId | null\n  }\n  lastTokenId: number\n  limits: CollectionLimits\n  decodedLimits: DecodedCollectionLimits\n  permissions: CollectionPermissions\n  tokenPropertyPermissions: TokenPropertyPermission[]\n  properties: DecodedProperty[]\n  propertiesMap: DecodedPropertiesMap\n  readOnly: boolean\n  additionalInfo: {\n    isNFT: boolean\n    isRFT: boolean\n    isFT: boolean\n    type: CollectionType\n  }\n  flags?: {foreign: boolean, erc721metadata: boolean}\n}\n\nexport interface INftToken {\n  collectionId: number\n  tokenId: number\n  collectionAddress: string\n  tokenAddress: string\n  owner: EnhancedCrossAccountId\n\n  properties: DecodedPropertyWithTokenPropertyPermission[]\n  propertiesMap: DecodedPropertiesWithTokenPropertyPermissionsMap\n}\n\nexport interface IRftToken {\n  collectionId: number\n  tokenId: number\n  collectionAddress: string\n  tokenAddress: string\n\n  pieces: number\n\n  owners: EnhancedCrossAccountId[]\n  allOwnersAreKnown: boolean\n  isOnlyOneOwner: boolean\n\n  properties: DecodedPropertyWithTokenPropertyPermission[]\n  propertiesMap: DecodedPropertiesWithTokenPropertyPermissionsMap\n}\n\n\nexport const requestCollection = async (requestRPC: RequestRPC, collectionId: number, ss58Prefix: number): Promise<ICollection | null> => {\n  const rawCollection = await requestRPC(\"unique_collectionById\", [collectionId])\n  if (!rawCollection) return null\n\n  const {properties, propertiesMap} = decodeCollectionProperties(rawCollection.properties)\n\n  const [\n    adminListResult,\n    effectiveLimits,\n    lastTokenId,\n  ] = await Promise.all([\n    requestRPC('unique_adminlist', [collectionId]) as Promise<CrossAccountIdUncapitalized[]>,\n    requestRPC('unique_effectiveCollectionLimits', [collectionId]) as Promise<CollectionEffectiveLimits>,\n    requestRPC('unique_lastTokenId', [collectionId]) as Promise<number>,\n  ])\n\n  const adminList = adminListResult.map(crossAccountId => Address.extract.enhancedCrossAccountId(crossAccountId, ss58Prefix))\n\n  const decodedLimits = Object.entries(effectiveLimits).reduce((acc, elem) => {\n    const [key, value] = elem as [keyof CollectionEffectiveLimits, CollectionEffectiveLimits[keyof CollectionEffectiveLimits]]\n\n    acc[key] = {\n      key,\n      value,\n      isDefaultValue: rawCollection.limits[key] === null\n    } as any\n\n    return acc\n  }, {} as DecodedCollectionLimits)\n\n  const isNFT = rawCollection.mode === 'NFT'\n  const isRFT = rawCollection.mode === 'ReFungible'\n  const isFT = typeof rawCollection.mode === 'object' && typeof rawCollection.mode?.Fungible === 'number'\n\n  const decodedSponsorship: ICollection['decodedSponsorship'] = {\n    enabled: typeof rawCollection.sponsorship !== 'string',\n    confirmed: !!rawCollection.sponsorship?.Confirmed,\n    sponsor: typeof rawCollection.sponsorship === 'object' && !!rawCollection.sponsorship\n      ? rawCollection.sponsorship.Confirmed\n        ? Address.extract.enhancedCrossAccountId(rawCollection.sponsorship.Confirmed, ss58Prefix)\n        : Address.extract.enhancedCrossAccountId(rawCollection.sponsorship.Unconfirmed, ss58Prefix)\n      : null\n  }\n\n  const collection: ICollection = {\n    ...rawCollection,\n    collectionId,\n    collectionAddress: Address.collection.idToAddress(collectionId),\n    owner: Address.extract.enhancedCrossAccountId(rawCollection.owner, ss58Prefix),\n    adminList,\n    mode: rawCollection.mode,\n    name: Utf16.numberArrayToString(rawCollection.name),\n    description: Utf16.numberArrayToString(rawCollection.description),\n    tokenPrefix: Utf8.numberArrayToString(rawCollection.token_prefix),\n    sponsorship: rawCollection.sponsorship,\n    decodedSponsorship,\n    lastTokenId,\n    limits: rawCollection.limits,\n    decodedLimits,\n    permissions: rawCollection.permissions,\n    tokenPropertyPermissions: decodeTPPArray(rawCollection.token_property_permissions),\n    properties,\n    propertiesMap,\n    readOnly: rawCollection.read_only as boolean,\n    additionalInfo: {\n      isNFT, isRFT, isFT,\n      type: isRFT ? 'RFT' : isFT ? 'FT' : 'NFT'\n    },\n    flags: rawCollection.flags || undefined\n  }\n  return collection\n}\n\nexport const requestNftToken = async (requestRPC: RequestRPC, collectionId: number, tokenId: number, ss58Prefix: number): Promise<INftToken | null> => {\n  const [rawCollection, rawToken] = await Promise.all([\n    requestRPC(\"unique_collectionById\", [collectionId]),\n    requestRPC(\"unique_tokenData\", [collectionId, tokenId]),\n  ])\n\n  if (!rawCollection || rawCollection.mode !== 'NFT' || !rawToken || !rawToken.owner) {\n    return null\n  }\n\n  const {properties, propertiesMap} = decodeTokenProperties(\n    rawToken.properties,\n    decodeTPPArray(rawCollection.token_property_permissions)\n  )\n\n  const nftToken: INftToken = {\n    collectionId,\n    tokenId,\n    collectionAddress: Address.collection.idToAddress(collectionId),\n    tokenAddress: Address.nesting.idsToAddress(collectionId, tokenId),\n\n    owner: Address.extract.enhancedCrossAccountId(rawToken.owner, ss58Prefix),\n\n    properties,\n    propertiesMap,\n  }\n  return nftToken\n}\n\n\nexport const requestRftToken = async (requestRPC: RequestRPC, collectionId: number, tokenId: number, ss58Prefix: number): Promise<IRftToken | null> => {\n  const [rawCollection, rawToken] = await Promise.all([\n    requestRPC(\"unique_collectionById\", [collectionId]),\n    requestRPC(\"unique_tokenData\", [collectionId, tokenId]),\n  ])\n\n  if (!rawCollection || rawCollection.mode !== 'ReFungible' || !rawToken || typeof rawToken.pieces !== 'number') { // protects from NFT/FT collections and from chains below 929030\n    return null\n  }\n\n  let owners: EnhancedCrossAccountId[] = []\n  let allOwnersAreKnown = true\n\n  if (rawToken.owner) {\n    owners = [Address.extract.enhancedCrossAccountId(rawToken.owner, ss58Prefix)]\n  } else {\n    owners = (await requestRPC<CrossAccountIdUncapitalized[]>('unique_tokenOwners', [collectionId, tokenId]))\n      .map(crossAccountId => Address.extract.enhancedCrossAccountId(crossAccountId, ss58Prefix))\n    allOwnersAreKnown = owners.length < 10\n  }\n\n  const {properties, propertiesMap} = decodeTokenProperties(\n    rawToken.properties,\n    decodeTPPArray(rawCollection.token_property_permissions)\n  )\n\n  const rftToken: IRftToken = {\n    collectionId,\n    tokenId,\n    collectionAddress: Address.collection.idToAddress(collectionId),\n    tokenAddress: Address.nesting.idsToAddress(collectionId, tokenId),\n\n    owners,\n    allOwnersAreKnown,\n    isOnlyOneOwner: !!rawToken.owner,\n\n    pieces: rawToken.pieces,\n\n    properties,\n    propertiesMap,\n  }\n  return rftToken\n}\n\nconst collectionIdOrAddressToCollectionId = (collectionIdOrAddress: number | string): number => {\n  return typeof collectionIdOrAddress === 'string'\n    ? Address.collection.addressToId(collectionIdOrAddress)\n    : collectionIdOrAddress\n}\n\nexport interface ChainLensOptions {\n  ss58Prefix: number\n}\n\nexport const generateChainLens = (rpcBaseUrlOrRequestRPC: string | RequestRPC, options: ChainLensOptions = {ss58Prefix: 42}) => {\n  const requestRPC = typeof rpcBaseUrlOrRequestRPC === 'string' ? requestRPCFactory(rpcBaseUrlOrRequestRPC) : rpcBaseUrlOrRequestRPC\n\n  const ss58Prefix = options.ss58Prefix\n\n  return {\n    get ss58Prefix() {\n      return ss58Prefix\n    },\n    requestRPC: async <T = any>(method: string, params: unknown[]): Promise<T> => {\n      return requestRPC(method, params)\n    },\n    requestCollection: async (collectionIdOrAddress: number | string) => {\n      const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress)\n\n      return requestCollection(requestRPC, collectionId, ss58Prefix)\n    },\n    requestNftToken: async (collectionIdOrAddress: number | string, tokenId: number) => {\n      const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress)\n\n      return requestNftToken(requestRPC, collectionId, tokenId, ss58Prefix)\n    },\n    requestNftTokenByAddress: async (tokenAddress: string) => {\n      const {collectionId, tokenId} = Address.nesting.addressToIds(tokenAddress)\n\n      return requestNftToken(requestRPC, collectionId, tokenId, ss58Prefix)\n    },\n    requestRftToken: async (collectionIdOrAddress: number | string, tokenId: number) => {\n      const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress)\n\n      return requestRftToken(requestRPC, collectionId, tokenId, ss58Prefix)\n    },\n    requestRftTokenByAddress: async (tokenAddress: string) => {\n      const {collectionId, tokenId} = Address.nesting.addressToIds(tokenAddress)\n\n      return requestRftToken(requestRPC, collectionId, tokenId, ss58Prefix)\n    },\n  }\n}\n\nexport type IChainLens = ReturnType<typeof generateChainLens>\n\nexport const ChainLenses: { [K in UNIQUE_CHAINS]: IChainLens } = {\n  unique: generateChainLens(UNIQUE_RPCs.unique, {ss58Prefix: 7391}),\n  quartz: generateChainLens(UNIQUE_RPCs.quartz, {ss58Prefix: 255}),\n  opal: generateChainLens(UNIQUE_RPCs.opal, {ss58Prefix: 42}),\n  sapphire: generateChainLens(UNIQUE_RPCs.sapphire, {ss58Prefix: 8883}),\n  rc: generateChainLens(UNIQUE_RPCs.rc, {ss58Prefix: 42}),\n}\n"],"mappings":"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","names":["basex","import_utf_helpers","normalize","HexString","import_utf_helpers","collection"]}