import "./chunk-N4PTXCJY.mjs";
import {
  Address_exports
} from "./chunk-6B63RM6C.mjs";
import "./chunk-SMH5LAMQ.mjs";

// src/ChainLens/ChainLens.ts
import { Utf8, Utf16, HexString } from "utf-helpers";
var UNIQUE_RPCs = {
  quartz: "https://rpc-quartz.unique.network/",
  opal: "https://rpc-opal.unique.network/",
  unique: "https://rpc.unique.network/",
  sapphire: "https://rpc-sapphire.unique.network/",
  rc: "https://rpc-rc.unique.network/"
};
var requestRPCFactory = (rpcUrl) => async (method, params) => {
  const fetch = globalThis.fetch;
  const response = await fetch(rpcUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ jsonrpc: "2.0", id: 1, method, params })
  });
  const result = await response.json();
  return result.result;
};
var decodeTPPArray = (arr) => {
  return arr.map(({ key, permission }) => {
    return {
      key: Utf8.numberArrayToString(key),
      keyHex: HexString.fromArray(key),
      permission
    };
  });
};
var decodeCollectionProperties = (arr) => {
  const properties = [];
  const propertiesMap = {};
  for (const elem of arr) {
    const { key, value } = elem;
    const decoded = {
      key: Utf8.numberArrayToString(key),
      keyHex: HexString.fromArray(key),
      value: Utf8.numberArrayToString(value),
      valueHex: HexString.fromArray(value)
    };
    properties.push(decoded);
    propertiesMap[decoded.key] = decoded;
  }
  return {
    properties,
    propertiesMap
  };
};
var decodeTokenProperties = (arr, tpps) => {
  const { properties, propertiesMap } = decodeCollectionProperties(arr);
  for (const property of properties) {
    const tppValue = tpps.find((tpp) => tpp.keyHex === property.keyHex).permission;
    property.tokenPropertyPermission = tppValue;
    propertiesMap[property.key].tokenPropertyPermission = tppValue;
  }
  return {
    properties,
    propertiesMap
  };
};
var requestCollection = async (requestRPC, collectionId, ss58Prefix) => {
  const rawCollection = await requestRPC("unique_collectionById", [collectionId]);
  if (!rawCollection)
    return null;
  const { properties, propertiesMap } = decodeCollectionProperties(rawCollection.properties);
  const [
    adminListResult,
    effectiveLimits,
    lastTokenId
  ] = await Promise.all([
    requestRPC("unique_adminlist", [collectionId]),
    requestRPC("unique_effectiveCollectionLimits", [collectionId]),
    requestRPC("unique_lastTokenId", [collectionId])
  ]);
  const adminList = adminListResult.map((crossAccountId) => Address_exports.extract.enhancedCrossAccountId(crossAccountId, ss58Prefix));
  const decodedLimits = Object.entries(effectiveLimits).reduce((acc, elem) => {
    const [key, value] = elem;
    acc[key] = {
      key,
      value,
      isDefaultValue: rawCollection.limits[key] === null
    };
    return acc;
  }, {});
  const isNFT = rawCollection.mode === "NFT";
  const isRFT = rawCollection.mode === "ReFungible";
  const isFT = typeof rawCollection.mode === "object" && typeof rawCollection.mode?.Fungible === "number";
  const decodedSponsorship = {
    enabled: typeof rawCollection.sponsorship !== "string",
    confirmed: !!rawCollection.sponsorship?.Confirmed,
    sponsor: typeof rawCollection.sponsorship === "object" && !!rawCollection.sponsorship ? rawCollection.sponsorship.Confirmed ? Address_exports.extract.enhancedCrossAccountId(rawCollection.sponsorship.Confirmed, ss58Prefix) : Address_exports.extract.enhancedCrossAccountId(rawCollection.sponsorship.Unconfirmed, ss58Prefix) : null
  };
  const collection = {
    ...rawCollection,
    collectionId,
    collectionAddress: Address_exports.collection.idToAddress(collectionId),
    owner: Address_exports.extract.enhancedCrossAccountId(rawCollection.owner, ss58Prefix),
    adminList,
    mode: rawCollection.mode,
    name: Utf16.numberArrayToString(rawCollection.name),
    description: Utf16.numberArrayToString(rawCollection.description),
    tokenPrefix: Utf8.numberArrayToString(rawCollection.token_prefix),
    sponsorship: rawCollection.sponsorship,
    decodedSponsorship,
    lastTokenId,
    limits: rawCollection.limits,
    decodedLimits,
    permissions: rawCollection.permissions,
    tokenPropertyPermissions: decodeTPPArray(rawCollection.token_property_permissions),
    properties,
    propertiesMap,
    readOnly: rawCollection.read_only,
    additionalInfo: {
      isNFT,
      isRFT,
      isFT,
      type: isRFT ? "RFT" : isFT ? "FT" : "NFT"
    },
    flags: rawCollection.flags || void 0
  };
  return collection;
};
var requestNftToken = async (requestRPC, collectionId, tokenId, ss58Prefix) => {
  const [rawCollection, rawToken] = await Promise.all([
    requestRPC("unique_collectionById", [collectionId]),
    requestRPC("unique_tokenData", [collectionId, tokenId])
  ]);
  if (!rawCollection || rawCollection.mode !== "NFT" || !rawToken || !rawToken.owner) {
    return null;
  }
  const { properties, propertiesMap } = decodeTokenProperties(
    rawToken.properties,
    decodeTPPArray(rawCollection.token_property_permissions)
  );
  const nftToken = {
    collectionId,
    tokenId,
    collectionAddress: Address_exports.collection.idToAddress(collectionId),
    tokenAddress: Address_exports.nesting.idsToAddress(collectionId, tokenId),
    owner: Address_exports.extract.enhancedCrossAccountId(rawToken.owner, ss58Prefix),
    properties,
    propertiesMap
  };
  return nftToken;
};
var requestRftToken = async (requestRPC, collectionId, tokenId, ss58Prefix) => {
  const [rawCollection, rawToken] = await Promise.all([
    requestRPC("unique_collectionById", [collectionId]),
    requestRPC("unique_tokenData", [collectionId, tokenId])
  ]);
  if (!rawCollection || rawCollection.mode !== "ReFungible" || !rawToken || typeof rawToken.pieces !== "number") {
    return null;
  }
  let owners = [];
  let allOwnersAreKnown = true;
  if (rawToken.owner) {
    owners = [Address_exports.extract.enhancedCrossAccountId(rawToken.owner, ss58Prefix)];
  } else {
    owners = (await requestRPC("unique_tokenOwners", [collectionId, tokenId])).map((crossAccountId) => Address_exports.extract.enhancedCrossAccountId(crossAccountId, ss58Prefix));
    allOwnersAreKnown = owners.length < 10;
  }
  const { properties, propertiesMap } = decodeTokenProperties(
    rawToken.properties,
    decodeTPPArray(rawCollection.token_property_permissions)
  );
  const rftToken = {
    collectionId,
    tokenId,
    collectionAddress: Address_exports.collection.idToAddress(collectionId),
    tokenAddress: Address_exports.nesting.idsToAddress(collectionId, tokenId),
    owners,
    allOwnersAreKnown,
    isOnlyOneOwner: !!rawToken.owner,
    pieces: rawToken.pieces,
    properties,
    propertiesMap
  };
  return rftToken;
};
var collectionIdOrAddressToCollectionId = (collectionIdOrAddress) => {
  return typeof collectionIdOrAddress === "string" ? Address_exports.collection.addressToId(collectionIdOrAddress) : collectionIdOrAddress;
};
var generateChainLens = (rpcBaseUrlOrRequestRPC, options = { ss58Prefix: 42 }) => {
  const requestRPC = typeof rpcBaseUrlOrRequestRPC === "string" ? requestRPCFactory(rpcBaseUrlOrRequestRPC) : rpcBaseUrlOrRequestRPC;
  const ss58Prefix = options.ss58Prefix;
  return {
    get ss58Prefix() {
      return ss58Prefix;
    },
    requestRPC: async (method, params) => {
      return requestRPC(method, params);
    },
    requestCollection: async (collectionIdOrAddress) => {
      const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress);
      return requestCollection(requestRPC, collectionId, ss58Prefix);
    },
    requestNftToken: async (collectionIdOrAddress, tokenId) => {
      const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress);
      return requestNftToken(requestRPC, collectionId, tokenId, ss58Prefix);
    },
    requestNftTokenByAddress: async (tokenAddress) => {
      const { collectionId, tokenId } = Address_exports.nesting.addressToIds(tokenAddress);
      return requestNftToken(requestRPC, collectionId, tokenId, ss58Prefix);
    },
    requestRftToken: async (collectionIdOrAddress, tokenId) => {
      const collectionId = collectionIdOrAddressToCollectionId(collectionIdOrAddress);
      return requestRftToken(requestRPC, collectionId, tokenId, ss58Prefix);
    },
    requestRftTokenByAddress: async (tokenAddress) => {
      const { collectionId, tokenId } = Address_exports.nesting.addressToIds(tokenAddress);
      return requestRftToken(requestRPC, collectionId, tokenId, ss58Prefix);
    }
  };
};
var ChainLenses = {
  unique: generateChainLens(UNIQUE_RPCs.unique, { ss58Prefix: 7391 }),
  quartz: generateChainLens(UNIQUE_RPCs.quartz, { ss58Prefix: 255 }),
  opal: generateChainLens(UNIQUE_RPCs.opal, { ss58Prefix: 42 }),
  sapphire: generateChainLens(UNIQUE_RPCs.sapphire, { ss58Prefix: 8883 }),
  rc: generateChainLens(UNIQUE_RPCs.rc, { ss58Prefix: 42 })
};

// src/ChainLens/index.ts
var constants = {
  maxRefungiblePieces: 1000000000000000000000n,
  collectionCreationPrice: 2
};
var ChainLens_default = ChainLenses;
export {
  ChainLenses,
  constants,
  ChainLens_default as default,
  generateChainLens
};
//# sourceMappingURL=chainLens.mjs.map