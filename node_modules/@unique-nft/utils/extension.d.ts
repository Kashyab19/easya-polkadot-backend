import * as ethers from 'ethers';
import { ContractReceipt, Event } from 'ethers';

type KeypairType = 'ed25519' | 'sr25519' | 'ecdsa' | 'ethereum';
interface InjectedAccount {
    address: string;
    genesisHash?: string | null;
    name?: string;
    type?: KeypairType;
}
interface InjectedWallet {
    accounts: {
        get(): Promise<InjectedAccount[]>;
    };
    metadata?: any;
    provider?: any;
    signer: Signer;
}
interface SignerPayloadJSON {
    address: string;
    blockHash: string;
    blockNumber: string;
    era: string;
    genesisHash: string;
    method: string;
    nonce: string;
    specVersion: string;
    tip: string;
    transactionVersion: string;
    signedExtensions: string[];
    version: number;
}
type SignerPayloadJSONWithAddressOptional = Omit<SignerPayloadJSON, 'address'> & {
    address?: string;
};
interface SignerPayloadRaw {
    data: string;
    address: string;
    type: 'bytes' | 'payload';
}
type SignerPayloadRawWithAddressAndTypeOptional = {
    data: string;
    address?: SignerPayloadRaw['address'];
    type?: SignerPayloadRaw['type'];
};
interface SignerResult {
    id: number;
    signature: string;
}
interface Signer {
    signPayload: (payload: SignerPayloadJSON) => Promise<SignerResult>;
    signRaw: (raw: SignerPayloadRaw) => Promise<SignerResult>;
    update?: (id: number, status: any) => void;
}
interface UNIQUE_SDK_UnsignedTxPayloadBody {
    signerPayloadJSON: SignerPayloadJSON;
    signerPayloadRaw: SignerPayloadRaw;
    signerPayloadHex: string;
}
interface UNIQUE_SDK_SignTxResultResponse {
    signature: string;
    signatureType: KeypairType;
}
interface IPolkadotExtensionWalletInfo {
    name: string;
    version: string;
    isEnabled: boolean | undefined;
    prettyName: string;
    logo: {
        ipfsCid: string;
        url: string;
    };
}
interface IPolkadotExtensionWallet extends IPolkadotExtensionWalletInfo, Omit<InjectedWallet, 'accounts'> {
    accounts: IPolkadotExtensionAccount[];
}
interface IPolkadotExtensionAccount extends Omit<Signer, 'signRaw'> {
    name: string;
    address: string;
    addressShort: string;
    id: string;
    wallet: IPolkadotExtensionWalletInfo;
    signRaw: (raw: SignerPayloadRawWithAddressAndTypeOptional | string) => Promise<SignerResult>;
    signer: {
        address: string;
        sign: (unsignedTxPayload: UNIQUE_SDK_UnsignedTxPayloadBody) => Promise<UNIQUE_SDK_SignTxResultResponse>;
    };
    meta: {
        genesisHash: string | null;
        name: string;
        source: string;
    };
    type: KeypairType;
}
type IPolkadotExtensionGenericInfo = Pick<IPolkadotExtensionWalletInfo, 'name' | 'prettyName' | 'logo'> & {
    webpage: string;
};
interface IPolkadotExtensionListWalletsResult {
    wallets: IPolkadotExtensionWalletInfo[];
    info: {
        extensionFound: boolean;
        enabledWalletsNumber: number;
    };
}
type IPolkadotExtensionLoadWalletByNameResultSafe = {
    result: IPolkadotExtensionWallet;
    error: null;
} | {
    result: null;
    error: Error;
};
type IPolkadotExtensionLoadWalletsError = Error & {
    extensionNotFound: boolean;
    accountsNotFound: boolean;
    userHasWalletsButHasNoAccounts: boolean;
    userHasBlockedAllWallets: boolean;
};
interface IPolkadotExtensionLoadWalletsResult {
    wallets: IPolkadotExtensionWallet[];
    accounts: IPolkadotExtensionAccount[];
    rejectedWallets: Array<IPolkadotExtensionWalletInfo & {
        error: Error;
        isBlockedByUser: boolean;
    }>;
}
type IPolkadotExtensionLoadWalletsResultSafe = {
    result: IPolkadotExtensionLoadWalletsResult;
    error: null;
} | {
    result: null;
    error: IPolkadotExtensionLoadWalletsError;
};
declare const Polkadot: {
    listWallets: () => Promise<IPolkadotExtensionListWalletsResult>;
    enableAndLoadAllWallets: () => Promise<IPolkadotExtensionLoadWalletsResult>;
    loadEnabledWallets: () => Promise<IPolkadotExtensionLoadWalletsResult>;
    enableAndLoadAllWalletsSafe: () => Promise<IPolkadotExtensionLoadWalletsResultSafe>;
    loadEnabledWalletsSafe: () => Promise<IPolkadotExtensionLoadWalletsResultSafe>;
    loadWalletByName: (walletName: string) => Promise<IPolkadotExtensionWallet>;
    loadWalletByNameSafe: (walletName: string) => Promise<IPolkadotExtensionLoadWalletByNameResultSafe>;
    constants: {
        knownPolkadotExtensions: IPolkadotExtensionGenericInfo[];
        extensionNames: {
            polkadot: string;
            subwallet: string;
            talisman: string;
        };
    };
};

interface AddEthereumChainParameter {
    chainId: string;
    chainName: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: 18;
    };
    rpcUrls: string[];
    blockExplorerUrls?: string[];
    iconUrls?: string[];
}
type UNIQUE_CHAIN = 'unique' | 'quartz' | 'opal' | 'sapphire';
type IEthereumExtensionResult = {
    address: string;
    chainId: number;
};
type IEthereumExtensionError = Error & {
    extensionNotFound: boolean;
    userRejected: boolean;
    needToRequestAccess: boolean;
    chainId: number | null;
};
type IEthereumExtensionResultSafe = {
    result: IEthereumExtensionResult;
    error: null;
} | {
    result: null;
    error: IEthereumExtensionError;
};
type UpdateReason = 'account' | 'chain';

declare const Ethereum: {
    getOrRequestAccounts: (requestInsteadOfGet?: boolean) => Promise<IEthereumExtensionResult>;
    getOrRequestAccountsSafe: (requestInsteadOfGet?: boolean) => Promise<IEthereumExtensionResultSafe>;
    requestAccounts: () => Promise<IEthereumExtensionResult>;
    getAccounts: () => Promise<IEthereumExtensionResult>;
    requestAccountsSafe: () => Promise<IEthereumExtensionResultSafe>;
    getAccountsSafe: () => Promise<IEthereumExtensionResultSafe>;
    subscribeOnChanges: (cb: (result: {
        reason: UpdateReason;
        chainId: number;
        address: string;
    }) => void) => (() => void);
    chainNameToChainId: Record<UNIQUE_CHAIN, number>;
    chainIdToChainName: Record<number, UNIQUE_CHAIN>;
    currentChainIs: Record<UNIQUE_CHAIN, () => boolean> & {
        anyUniqueChain: (chainId: string | number) => boolean;
        byName: (chainName: string) => boolean;
    };
    addChain: Record<UNIQUE_CHAIN, () => Promise<void>> & {
        anyChain: (chainData: AddEthereumChainParameter) => Promise<void>;
        byName: (chainName: string) => Promise<void>;
    };
    switchChainTo: Record<UNIQUE_CHAIN, () => Promise<void>> & {
        anyChain: (chainId: number | string) => Promise<void>;
        byName: (chainName: string) => Promise<void>;
    };
    UNIQUE_CHAINS_DATA_FOR_EXTENSIONS: Record<UNIQUE_CHAIN, AddEthereumChainParameter>;
    UNIQUE_CHAINS: UNIQUE_CHAIN[];
    UNIQUE_CHAIN_IDS: number[];
    UniqueChainName: Record<UNIQUE_CHAIN, UNIQUE_CHAIN>;
    parseEthersTxReceipt: <ParsedEvents = any>(tx: ContractReceipt, options?: {
        decimals: number;
    }) => {
        readonly tx: ContractReceipt;
        from: string;
        to: string;
        rawPrice: bigint;
        price: number;
        rawEvents: Event[];
        events: ParsedEvents;
        gasUsed: bigint;
        cumulativeGasUsed: bigint;
        effectiveGasPrice: bigint;
    };
};

declare const ExtensionTools: {
    Ethereum: {
        getOrRequestAccounts: (requestInsteadOfGet?: boolean) => Promise<IEthereumExtensionResult>;
        getOrRequestAccountsSafe: (requestInsteadOfGet?: boolean) => Promise<IEthereumExtensionResultSafe>;
        requestAccounts: () => Promise<IEthereumExtensionResult>;
        getAccounts: () => Promise<IEthereumExtensionResult>;
        requestAccountsSafe: () => Promise<IEthereumExtensionResultSafe>;
        getAccountsSafe: () => Promise<IEthereumExtensionResultSafe>;
        subscribeOnChanges: (cb: (result: {
            reason: UpdateReason;
            chainId: number;
            address: string;
        }) => void) => () => void;
        chainNameToChainId: Record<UNIQUE_CHAIN, number>;
        chainIdToChainName: Record<number, UNIQUE_CHAIN>;
        currentChainIs: Record<UNIQUE_CHAIN, () => boolean> & {
            anyUniqueChain: (chainId: string | number) => boolean;
            byName: (chainName: string) => boolean;
        };
        addChain: Record<UNIQUE_CHAIN, () => Promise<void>> & {
            anyChain: (chainData: AddEthereumChainParameter) => Promise<void>;
            byName: (chainName: string) => Promise<void>;
        };
        switchChainTo: Record<UNIQUE_CHAIN, () => Promise<void>> & {
            anyChain: (chainId: string | number) => Promise<void>;
            byName: (chainName: string) => Promise<void>;
        };
        UNIQUE_CHAINS_DATA_FOR_EXTENSIONS: Record<UNIQUE_CHAIN, AddEthereumChainParameter>;
        UNIQUE_CHAINS: UNIQUE_CHAIN[];
        UNIQUE_CHAIN_IDS: number[];
        UniqueChainName: Record<UNIQUE_CHAIN, UNIQUE_CHAIN>;
        parseEthersTxReceipt: <ParsedEvents = any>(tx: ethers.ContractReceipt, options?: {
            decimals: number;
        }) => {
            readonly tx: ethers.ContractReceipt;
            from: string;
            to: string;
            rawPrice: bigint;
            price: number;
            rawEvents: ethers.Event[];
            events: ParsedEvents;
            gasUsed: bigint;
            cumulativeGasUsed: bigint;
            effectiveGasPrice: bigint;
        };
    };
    Polkadot: {
        listWallets: () => Promise<IPolkadotExtensionListWalletsResult>;
        enableAndLoadAllWallets: () => Promise<IPolkadotExtensionLoadWalletsResult>;
        loadEnabledWallets: () => Promise<IPolkadotExtensionLoadWalletsResult>;
        enableAndLoadAllWalletsSafe: () => Promise<IPolkadotExtensionLoadWalletsResultSafe>;
        loadEnabledWalletsSafe: () => Promise<IPolkadotExtensionLoadWalletsResultSafe>;
        loadWalletByName: (walletName: string) => Promise<IPolkadotExtensionWallet>;
        loadWalletByNameSafe: (walletName: string) => Promise<IPolkadotExtensionLoadWalletByNameResultSafe>;
        constants: {
            knownPolkadotExtensions: IPolkadotExtensionGenericInfo[];
            extensionNames: {
                polkadot: string;
                subwallet: string;
                talisman: string;
            };
        };
    };
};
declare const UniqueChainName: Record<UNIQUE_CHAIN, UNIQUE_CHAIN>;

export { type AddEthereumChainParameter, Ethereum, ExtensionTools, type IEthereumExtensionError, type IEthereumExtensionResult, type IEthereumExtensionResultSafe, type IPolkadotExtensionAccount, type IPolkadotExtensionGenericInfo, type IPolkadotExtensionListWalletsResult, type IPolkadotExtensionLoadWalletByNameResultSafe, type IPolkadotExtensionLoadWalletsError, type IPolkadotExtensionLoadWalletsResult, type IPolkadotExtensionLoadWalletsResultSafe, type IPolkadotExtensionWallet, type IPolkadotExtensionWalletInfo, Polkadot, type SignerPayloadJSON, type SignerPayloadJSONWithAddressOptional, type SignerPayloadRaw, type SignerPayloadRawWithAddressAndTypeOptional, type SignerResult, type UNIQUE_CHAIN, UniqueChainName, type UpdateReason, ExtensionTools as default };
