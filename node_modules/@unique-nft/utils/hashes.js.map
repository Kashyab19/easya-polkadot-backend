{"version":3,"sources":["../src/Hashes/index.ts","../src/Hashes/xxhash.ts"],"sourcesContent":["import * as Xxhash from './xxhash'\n\nexport const encodeSubstrateStorageKey = Xxhash.encodeSubstrateStorageKey\n\nexport {Xxhash}\n","// Adapted from https://github.com/pierrec/js-xxhash/blob/0504e76f3d31a21ae8528a7f590c7289c9e431d2/lib/xxhash64.js\n//\n// xxHash64 implementation in pure Javascript\n// Copyright (C) 2016, Pierre Curto\n// MIT license\n//\n// Changes made:\n//   - converted to TypeScript\n//   - uses native JS BigInt (no external dependencies)\n//   - support only for Uint8Array inputs\n//   - no constructor function, straight fill & digest\n//   - update code removed, only called once, no streams\n//   - inline single-use functions\n\n// Original implementation from\n// https://github.com/polkadot-js/common/blob/master/packages/util-crypto/src/xxhash/asU8a.ts\n\n\nimport {HexString, Utf8} from 'utf-helpers'\n\nexport function u8aConcat (u8as: readonly Uint8Array[], length = 0): Uint8Array {\n  const count = u8as.length;\n  let offset = 0;\n\n  if (!length) {\n    for (let i = 0; i < count; i++) {\n      length += u8as[i].length;\n    }\n  }\n\n  const result = new Uint8Array(length);\n\n  for (let i = 0; i < count; i++) {\n    result.set(u8as[i], offset);\n    offset += u8as[i].length;\n  }\n\n  return result;\n}\n\n\ninterface State {\n  seed: bigint\n  u8a: Uint8Array\n  u8asize: number\n  v1: bigint\n  v2: bigint\n  v3: bigint\n  v4: bigint\n}\n\nconst P64_1 = BigInt('11400714785074694791')\nconst P64_2 = BigInt('14029467366897019727')\nconst P64_3 = BigInt('1609587929392839161')\nconst P64_4 = BigInt('9650029242287828579')\nconst P64_5 = BigInt('2870177450012600261')\n\n// mask for a u64, all bits set\nconst U64 = BigInt('0xffffffffffffffff')\n\n// various constants\n/*const _0n = BigInt(0)\nconst _1n = BigInt(1)\nconst _7n = BigInt(7)\nconst _11n = BigInt(11)\nconst _12n = BigInt(12)\nconst _16n = BigInt(16)\nconst _18n = BigInt(18)\nconst _23n = BigInt(23)\nconst _27n = BigInt(27)\nconst _29n = BigInt(29)\nconst _31n = BigInt(31)\nconst _32n = BigInt(32)\nconst _33n = BigInt(33)\nconst _64n = BigInt(64)\nconst _256n = BigInt(256)*/\n\nconst _0n = 0n\nconst _1n = 1n\nconst _7n = 7n\nconst _11n = 11n\nconst _12n = 12n\nconst _16n = 16n\nconst _18n = 18n\nconst _23n = 23n\nconst _27n = 27n\nconst _29n = 29n\nconst _31n = 31n\nconst _32n = 32n\nconst _33n = 33n\nconst _64n = 64n\nconst _256n = 256n\n\nfunction rotl (a: bigint, b: bigint): bigint {\n  const c = a & U64\n\n  return ((c << b) | (c >> (_64n - b))) & U64\n}\n\nfunction fromU8a (u8a: Uint8Array, p: number, count: 2 | 4): bigint {\n  const bigints = new Array<bigint>(count)\n  let offset = 0\n\n  for (let i = 0; i < count; i++, offset += 2) {\n    bigints[i] = BigInt(u8a[p + offset] | (u8a[p + 1 + offset] << 8))\n  }\n\n  let result = _0n\n\n  for (let i = count - 1; i >= 0; i--) {\n    result = (result << _16n) + bigints[i]\n  }\n\n  return result\n}\n\nfunction init (seed: bigint, input: Uint8Array): State {\n  const state = {\n    seed,\n    u8a: new Uint8Array(32),\n    u8asize: 0,\n    v1: seed + P64_1 + P64_2,\n    v2: seed + P64_2,\n    v3: seed,\n    v4: seed - P64_1\n  }\n\n  if (input.length < 32) {\n    state.u8a.set(input)\n    state.u8asize = input.length\n\n    return state\n  }\n\n  const limit = input.length - 32\n  let p = 0\n\n  if (limit >= 0) {\n    const adjustV = (v: bigint) =>\n      P64_1 * rotl(v + P64_2 * fromU8a(input, p, 4), _31n)\n\n    do {\n      state.v1 = adjustV(state.v1)\n      p += 8\n      state.v2 = adjustV(state.v2)\n      p += 8\n      state.v3 = adjustV(state.v3)\n      p += 8\n      state.v4 = adjustV(state.v4)\n      p += 8\n    } while (p <= limit)\n  }\n\n  if (p < input.length) {\n    state.u8a.set(input.subarray(p, input.length))\n    state.u8asize = input.length - p\n  }\n\n  return state\n}\n\nexport function xxhash64 (input: Uint8Array, initSeed: bigint | number): Uint8Array {\n  const { seed, u8a, u8asize, v1, v2, v3, v4 } = init(BigInt(initSeed), input)\n  let p = 0\n  let h64 = U64 & (BigInt(input.length) + (\n    input.length >= 32\n      ? (((((((((rotl(v1, _1n) + rotl(v2, _7n) + rotl(v3, _12n) + rotl(v4, _18n)) ^ (P64_1 * rotl(v1 * P64_2, _31n))) * P64_1 + P64_4) ^ (P64_1 * rotl(v2 * P64_2, _31n))) * P64_1 + P64_4) ^ (P64_1 * rotl(v3 * P64_2, _31n))) * P64_1 + P64_4) ^ (P64_1 * rotl(v4 * P64_2, _31n))) * P64_1 + P64_4)\n      : (seed + P64_5)\n  ))\n\n  while (p <= (u8asize - 8)) {\n    h64 = U64 & (P64_4 + P64_1 * rotl(h64 ^ (P64_1 * rotl(P64_2 * fromU8a(u8a, p, 4), _31n)), _27n))\n    p += 8\n  }\n\n  if ((p + 4) <= u8asize) {\n    h64 = U64 & (P64_3 + P64_2 * rotl(h64 ^ (P64_1 * fromU8a(u8a, p, 2)), _23n))\n    p += 4\n  }\n\n  while (p < u8asize) {\n    h64 = U64 & (P64_1 * rotl(h64 ^ (P64_5 * BigInt(u8a[p++])), _11n))\n  }\n\n  h64 = U64 & (P64_2 * (h64 ^ (h64 >> _33n)))\n  h64 = U64 & (P64_3 * (h64 ^ (h64 >> _29n)))\n  h64 = U64 & (h64 ^ (h64 >> _32n))\n\n  const result = new Uint8Array(8)\n\n  for (let i = 7; i >= 0; i--) {\n    result[i] = Number(h64 % _256n)\n\n    h64 = h64 / _256n\n  }\n\n  return result\n}\n\n\n/**\n * @name xxhashAsU8a\n * @summary Creates a xxhash64 u8a from the input.\n * @description\n * From either a `string`, `Uint8Array` or a `Buffer` input, create the xxhash64 and return the result as a `Uint8Array` with the specified `bitLength`.\n * @example\n * <BR>\n *\n * ```javascript\n * xxhashAsU8a('abc') // => 0x44bc2cf5ad770999\n * ```\n */\nexport function xxhashOfU8a (data: Uint8Array, bitLength: 64 | 128 | 192 | 256 | 320 | 384 | 448 | 512 = 64): Uint8Array {\n  // check that data is a Uint8Array\n  const rounds = Math.ceil(bitLength / 64)\n\n  const result = new Uint8Array(rounds * 8)\n\n  for (let seed = 0; seed < rounds; seed++) {\n    result.set(xxhash64(data, seed).reverse(), seed * 8)\n  }\n\n  return result\n}\n\n/**\n * @name xxhashAsHex\n * @description Creates a xxhash64 hex from the input.\n */\nexport const xxhashOfU8aAsHex = (data: Uint8Array, bitLength: 64 | 128 | 192 | 256 | 320 | 384 | 448 | 512 = 64): string =>\n  HexString.fromU8a(xxhashOfU8a(data, bitLength))\n\nexport const encodeSubstrateStorageKey = (entries: string[]): `0x${string}` => {\n  const hashes = entries.map((entry) => xxhashOfU8a(Utf8.stringToU8a(entry), 128))\n  return HexString.fromU8a(u8aConcat(hashes)) as `0x${string}`\n}\n"],"mappings":"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","names":["encodeSubstrateStorageKey","encodeSubstrateStorageKey"]}