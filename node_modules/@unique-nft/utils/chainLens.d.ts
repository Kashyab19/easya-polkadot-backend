import { c as EnhancedCrossAccountId } from './types-DG4aSWMh.js';

type MakeFieldsNullable<Ob> = {
    [K in keyof Ob]: Ob[K] | null;
};
declare enum UNIQUE_CHAINS {
    unique = "unique",
    quartz = "quartz",
    opal = "opal",
    sapphire = "sapphire",
    rc = "rc"
}
type RequestRPC = <T = any>(method: string, params: unknown[]) => Promise<T>;
type TokenPropertyPermissionValue = {
    mutable: boolean;
    collection_admin: boolean;
    token_owner: boolean;
};
type TokenPropertyPermission = {
    key: string;
    keyHex: string;
    permission: TokenPropertyPermissionValue;
};
interface DecodedProperty {
    key: string;
    value: string;
    keyHex: string;
    valueHex: string;
}
interface DecodedPropertyWithTokenPropertyPermission extends DecodedProperty {
    tokenPropertyPermission: TokenPropertyPermissionValue;
}
type DecodedPropertiesMap = Record<string, DecodedProperty>;
type DecodedPropertiesWithTokenPropertyPermissionsMap = Record<string, DecodedPropertyWithTokenPropertyPermission>;
interface CollectionEffectiveLimits {
    account_token_ownership_limit: number;
    owner_can_destroy: boolean;
    owner_can_transfer: boolean;
    sponsor_approve_timeout: number;
    sponsor_transfer_timeout: number;
    sponsored_data_rate_limit: 'SponsoringDisabled' | {
        Blocks: number;
    };
    sponsored_data_size: number;
    token_limit: number;
    transfers_enabled: boolean;
}
type CollectionLimits = MakeFieldsNullable<CollectionEffectiveLimits>;
type DecodedCollectionLimits = {
    [K in keyof CollectionEffectiveLimits]: {
        key: K;
        value: CollectionEffectiveLimits[K];
        isDefaultValue: boolean;
    };
};
interface CollectionPermissions {
    access: 'Normal' | 'AllowList';
    mint_mode: boolean;
    nesting: {
        token_owner: boolean;
        collection_admin: boolean;
        restricted: null | number[];
    };
}
type CollectionType = 'NFT' | 'RFT' | 'FT';
interface ICollection {
    collectionId: number;
    collectionAddress: string;
    owner: EnhancedCrossAccountId;
    adminList: EnhancedCrossAccountId[];
    mode: 'NFT' | 'ReFungible' | {
        Fungible: number;
    };
    name: string;
    description: string;
    tokenPrefix: string;
    sponsorship: 'Disabled' | {
        Confirmed: string;
    } | {
        Unconfirmed: string;
    };
    decodedSponsorship: {
        enabled: boolean;
        confirmed: boolean;
        sponsor: EnhancedCrossAccountId | null;
    };
    lastTokenId: number;
    limits: CollectionLimits;
    decodedLimits: DecodedCollectionLimits;
    permissions: CollectionPermissions;
    tokenPropertyPermissions: TokenPropertyPermission[];
    properties: DecodedProperty[];
    propertiesMap: DecodedPropertiesMap;
    readOnly: boolean;
    additionalInfo: {
        isNFT: boolean;
        isRFT: boolean;
        isFT: boolean;
        type: CollectionType;
    };
    flags?: {
        foreign: boolean;
        erc721metadata: boolean;
    };
}
interface INftToken {
    collectionId: number;
    tokenId: number;
    collectionAddress: string;
    tokenAddress: string;
    owner: EnhancedCrossAccountId;
    properties: DecodedPropertyWithTokenPropertyPermission[];
    propertiesMap: DecodedPropertiesWithTokenPropertyPermissionsMap;
}
interface IRftToken {
    collectionId: number;
    tokenId: number;
    collectionAddress: string;
    tokenAddress: string;
    pieces: number;
    owners: EnhancedCrossAccountId[];
    allOwnersAreKnown: boolean;
    isOnlyOneOwner: boolean;
    properties: DecodedPropertyWithTokenPropertyPermission[];
    propertiesMap: DecodedPropertiesWithTokenPropertyPermissionsMap;
}
interface ChainLensOptions {
    ss58Prefix: number;
}
declare const generateChainLens: (rpcBaseUrlOrRequestRPC: string | RequestRPC, options?: ChainLensOptions) => {
    readonly ss58Prefix: number;
    requestRPC: <T = any>(method: string, params: unknown[]) => Promise<T>;
    requestCollection: (collectionIdOrAddress: number | string) => Promise<ICollection | null>;
    requestNftToken: (collectionIdOrAddress: number | string, tokenId: number) => Promise<INftToken | null>;
    requestNftTokenByAddress: (tokenAddress: string) => Promise<INftToken | null>;
    requestRftToken: (collectionIdOrAddress: number | string, tokenId: number) => Promise<IRftToken | null>;
    requestRftTokenByAddress: (tokenAddress: string) => Promise<IRftToken | null>;
};
type IChainLens = ReturnType<typeof generateChainLens>;
declare const ChainLenses: {
    [K in UNIQUE_CHAINS]: IChainLens;
};

declare const constants: {
    maxRefungiblePieces: bigint;
    collectionCreationPrice: number;
};

export { ChainLenses, type CollectionEffectiveLimits, type CollectionLimits, type CollectionPermissions, type CollectionType, type DecodedCollectionLimits, type DecodedPropertiesMap, type DecodedProperty, type IChainLens, type ICollection, type INftToken, type IRftToken, type TokenPropertyPermission, type TokenPropertyPermissionValue, UNIQUE_CHAINS, constants, ChainLenses as default, generateChainLens };
