{"version":3,"sources":["../src/Royalties/index.ts","../src/Royalties/types.ts","../src/Royalties/utils.ts","../src/Address/index.ts","../src/Address/constants.ts","../src/Address/imports.ts","../src/Address/ethereum.ts","../src/Address/substrate.ts","../src/Address/crossAccountId.ts","../src/index.ts","../src/Utils/coin.ts","../src/Royalties/calculation.ts","../src/Royalties/decoding.ts","../src/Royalties/encoding.ts"],"sourcesContent":["import {UniqueRoyaltyPart, UniqueRoyaltyPartToEncode} from './types'\n\nexport * from './types'\n\nimport * as calculation from './calculation'\nimport * as decoding from './decoding'\nimport * as encoding from './encoding'\nimport * as utils from './utils'\nimport {parseRoyalties, parseRoyaltyPart} from './utils'\nimport {encodeRoyaltyFromV2} from './encoding'\n\nexport const Royalties = {\n  part: {\n    calculate: calculation.calculateRoyaltyPart,\n    decode: decoding.decodeRoyaltyPart,\n    encode: encoding.encodeRoyaltyPart,\n    validate: (part: UniqueRoyaltyPartToEncode): part is UniqueRoyaltyPart => {\n      parseRoyaltyPart(part)\n      return true\n    },\n  },\n  calculate: calculation.calculateRoyalties,\n  decode: decoding.decodeRoyalties,\n  encode: encoding.encodeRoyalties,\n  validate: (royalties: UniqueRoyaltyPartToEncode[]): royalties is UniqueRoyaltyPart[] => {\n    parseRoyalties(royalties)\n    return true\n  },\n  uniqueV2: {\n    decode: decoding.decodeRoyaltyToV2,\n    encode: encoding.encodeRoyaltyFromV2,\n  },\n  utils,\n}\n","export enum RoyaltyType {\n  DEFAULT = 'DEFAULT',\n  PRIMARY_ONLY = 'PRIMARY_ONLY',\n}\n\nexport interface UniqueRoyaltyPart {\n  version: number\n  royaltyType: RoyaltyType | `${RoyaltyType}`\n  decimals: number\n  value: bigint\n  address: string\n}\n\nexport type UniqueRoyaltyPartToEncode = {\n  version?: number\n  royaltyType?: RoyaltyType | `${RoyaltyType}`\n  decimals?: number\n  value: bigint\n  address: string\n}\n\nexport type RoyaltyAmount = {\n  address: string\n  amount: bigint\n}\n\nexport type LibPart = {\n  account: string\n  value: bigint\n}\n\nexport type IV2Royalty = {\n  address: string,\n  percent: number,\n  isPrimaryOnly?: boolean,\n}\n","import {LibPart, RoyaltyType, UniqueRoyaltyPart, UniqueRoyaltyPartToEncode} from './types'\nimport {Address} from '../index'\n\nexport const ROYALTIES_PROPERTY = 'royalties'\n\nexport const get42Zeros = () => ''.padStart(42, '0')\n\nexport const splitStringEvery = (str: string, every: number): string[] => {\n  const result = []\n\n  for (let i = 0; i < str.length; i += every) {\n    result.push(str.substring(i, i + every))\n  }\n\n  return result\n}\n\n\nexport const encodeAddress = (address: string): [boolean, string] => {\n  if (Address.is.ethereumAddress(address)) {\n    return [\n      true,\n      Address.normalize\n        .ethereumAddress(address)\n        .substring(2)\n        .padStart(64, '0')\n        .toLowerCase(),\n    ]\n  }\n\n  return [false, Address.substrate.decode(address).hex.substring(2)]\n}\n\nexport const toLibPart = (part: UniqueRoyaltyPart): LibPart => {\n  const account = Address.is.ethereumAddress(part.address)\n    ? part.address\n    : Address.mirror.substrateToEthereum(part.address)\n\n  // recalculating value to 4 decimals\n  const value = part.value * 10n ** BigInt(part.decimals - 4)\n\n  return {account, value}\n}\n\nexport const parseRoyaltyPart = (\n  part: UniqueRoyaltyPartToEncode,\n): UniqueRoyaltyPart => {\n  part.version = part.version ?? 1\n  if (1 > part.version || part.version > 127) {\n    throw new Error(`Version must be between 1 and 127, got ${part.version}`)\n  }\n\n  if (!Number.isInteger(part.version)) {\n    throw new Error(`Version must be an integer, got ${part.version}`)\n  }\n\n  part.decimals = part.decimals ?? 4\n  if (0 > part.decimals || part.decimals > 255) {\n    throw new Error(`Decimals must be between 0 and 255, got ${part.decimals}`)\n  }\n\n  if (!Number.isInteger(part.decimals)) {\n    throw new Error(`Decimals must be an integer, got ${part.decimals}`)\n  }\n\n  if (!Number.isInteger(part.value) && (typeof part.value !== 'bigint')) {\n    throw new Error(`Value must be an integer or bigint, got ${part.value} (${typeof part.value})`)\n  }\n\n  if (part.value < 1 || part.value > (2n ** 64n - 1n)) {\n    throw new Error(\n      `Value must be between 1 and 18446744073709551615 (uint64), got ${part.value}`,\n    )\n  }\n\n  part.royaltyType = part.royaltyType ?? RoyaltyType.DEFAULT\n\n  if (!RoyaltyType[part.royaltyType]) {\n    throw new Error(\n      `Royalty type must be one of ${Object.keys(RoyaltyType)}, got ${\n        part.royaltyType\n      }`,\n    )\n  }\n\n  part.address = Address.extract.address(part.address)\n\n  return part as UniqueRoyaltyPart\n}\n\nexport const parseRoyalties = (parts: UniqueRoyaltyPartToEncode[]): UniqueRoyaltyPart[] => {\n  if (!Array.isArray(parts)) {\n    throw new Error('Royalties must be an array')\n  }\n  return parts.map(parseRoyaltyPart)\n}\n","import {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from './constants'\n\nimport {\n  addressToEvm, compareSubstrateAddresses,\n  decodeSubstrateAddress, encodeSubstrateAddress,\n  evmToAddress,\n  normalizeSubstrateAddress\n} from './substrate'\n\nimport {\n  collectionIdAndTokenIdToNestingAddress,\n  collectionIdToEthAddress, compareEthereumAddresses, DWORDHexString,\n  ethAddressToCollectionId,\n  nestingAddressToCollectionIdAndTokenId,\n  normalizeEthereumAddress\n} from './ethereum'\nimport {\n  CrossAccountId, CrossAccountIdUncapitalized,\n  EthAddressObj, EthAddressObjUncapitalized,\n  SubAddressObj, SubAddressObjUncapitalized,\n  EnhancedCrossAccountId, EthCrossAccountId,\n} from '../types'\nimport {\n  addressInAnyFormToEnhancedCrossAccountId,\n  guessAddressAndExtractCrossAccountIdSafe,\n  guessAddressAndExtractCrossAccountIdUnsafe,\n  substrateOrMirrorIfEthereum\n} from './crossAccountId'\n\nimport * as algorithms from './imports'\nimport * as constants from './constants'\n\nexport {constants, algorithms}\n\nconst ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nconst SUB_PUBLIC_KEY_REGEX = /^0x[a-fA-F0-9]{64}$/\n\nexport type DecodeSubstrateAddressResult = {\n  u8a: Uint8Array\n  hex: string\n  bigint: bigint\n  ss58Prefix: number\n}\n\nexport const validate = {\n  substrateAddress: (address: string) => {\n    decodeSubstrateAddress(address)\n    return true\n  },\n  ethereumAddress: (address: string) => {\n    if (!is.ethereumAddress(address)) {\n      throw new Error(`address \"${address}\" is not valid ethereum address`)\n    }\n    return true\n  },\n  substratePublicKey: (address: string) => {\n    if (!is.substratePublicKey(address)) {\n      throw new Error(`address \"${address}\" is not valid substrate public key`)\n    }\n    return true\n  },\n  collectionAddress: (address: string) => {\n    if (!is.collectionAddress(address)) {\n      throw new Error(`address ${address} is not a collection address`)\n    }\n    return true\n  },\n  nestingAddress: (address: string) => {\n    if (!is.nestingAddress(address)) {\n      throw new Error(`address ${address} is not a nesting address`)\n    }\n    return true\n  },\n  collectionId: (collectionId: number) => {\n    if (!is.collectionId(collectionId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n  tokenId: (tokenId: number) => {\n    if (!is.tokenId(tokenId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n}\n\nexport const is = {\n  substrateAddress: (address: string): boolean => {\n    try {\n      decodeSubstrateAddress(address)\n      return !is.substratePublicKey(address)\n    } catch {\n      return false\n    }\n  },\n  ethereumAddress: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 42 && !!address.match(ETH_ADDRESS_REGEX)\n  },\n  substratePublicKey: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 66 && !!address.match(SUB_PUBLIC_KEY_REGEX)\n  },\n\n  collectionAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(COLLECTION_ADDRESS_PREFIX)\n  },\n  nestingAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(NESTING_PREFIX)\n  },\n\n  collectionId: (collectionId: number): boolean => {\n    return !(typeof collectionId !== 'number' || isNaN(collectionId) || collectionId < 0 || collectionId > 0xffffffff)\n  },\n  tokenId: (tokenId: number): boolean => {\n    return !(typeof tokenId !== 'number' || isNaN(tokenId) || tokenId < 0 || tokenId > 0xffffffff)\n  },\n\n  crossAccountId(obj: any): obj is CrossAccountId {\n    return is.substrateAddressObject(obj) || is.ethereumAddressObject(obj)\n  },\n  crossAccountIdUncapitalized(obj: any): obj is CrossAccountIdUncapitalized {\n    return is.substrateAddressObjectUncapitalized(obj) || is.ethereumAddressObjectUncapitalized(obj)\n  },\n  substrateAddressObject(obj: any): obj is SubAddressObj {\n    return typeof obj === 'object' && typeof obj?.Substrate === 'string' && is.substrateAddress(obj.Substrate)\n  },\n  ethereumAddressObject(obj: any): obj is EthAddressObj {\n    return typeof obj === 'object' && typeof obj?.Ethereum === 'string' && is.ethereumAddress(obj.Ethereum)\n  },\n  substrateAddressObjectUncapitalized(obj: any): obj is SubAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.substrate === 'string' && is.substrateAddress(obj.substrate)\n  },\n  ethereumAddressObjectUncapitalized(obj: any): obj is EthAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.ethereum === 'string' && is.ethereumAddress(obj.ethereum)\n  },\n  substrateAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.substrateAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.substrateAddressObject(address) || is.substrateAddressObjectUncapitalized(address))\n      )\n  },\n  ethereumAddressInAnyForm(address: any): address is string | EthAddressObj | EthAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.ethereumAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.ethereumAddressObject(address) || is.ethereumAddressObjectUncapitalized(address))\n      )\n  },\n  validAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized | EthAddressObj | EthAddressObjUncapitalized {\n    return is.ethereumAddressInAnyForm(address) || is.substrateAddressInAnyForm(address)\n  }\n}\n\nexport const collection = {\n  idToAddress: collectionIdToEthAddress,\n  addressToId: ethAddressToCollectionId,\n}\nexport const nesting = {\n  idsToAddress: collectionIdAndTokenIdToNestingAddress,\n  addressToIds: nestingAddressToCollectionIdAndTokenId,\n}\n\nexport const extract = {\n  address: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressForScanNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string\n  },\n  addressForScanNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string : null\n  },\n\n\n  crossAccountId: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n  },\n  crossAccountIdSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n  },\n\n  crossAccountIdNormalized: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n  },\n  crossAccountIdNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n  },\n\n  crossAccountIdUncapitalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n  crossAccountIdUncapitalizedNormalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalizedNormalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n\n  substrateOrMirrorIfEthereum: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n  },\n  substrateOrMirrorIfEthereumSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  substrateOrMirrorIfEthereumNormalized: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n  },\n  substrateOrMirrorIfEthereumNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n    } catch {\n      return null\n    }\n  },\n\n  substratePublicKey: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    if (!crossAccountId.Substrate) {\n      throw new Error('Address is not a substrate address')\n    }\n    return substrate.decode(crossAccountId.Substrate).hex\n  },\n  substratePublicKeySafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return extract.substratePublicKey(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  enhancedCrossAccountId: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n    return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n  },\n  enhancedCrossAccountIdSafe: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId | null => {\n    try {\n      return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n    } catch {\n      return null\n    }\n  },\n\n  ethCrossAccountId: (addressInAnyForm: string | object): EthCrossAccountId => {\n    const addressEnhanced = addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm)\n    if (addressEnhanced.Substrate) {\n      return {\n        eth: '0x0000000000000000000000000000000000000000',\n        sub: addressEnhanced.substratePublicKey,\n      }\n    } else {\n      return {\n        eth: addressEnhanced.address,\n        sub: '0x00',\n      }\n    }\n  },\n  ethCrossAccountIdSafe: (addressInAnyForm: string | object): EthCrossAccountId | null => {\n    try {\n      return extract.ethCrossAccountId(addressInAnyForm)\n    } catch {\n      return null\n    }\n  }\n}\n\nexport const mirror = {\n  substrateToEthereum: addressToEvm,\n  ethereumToSubstrate: evmToAddress,\n}\n\nexport const normalize = {\n  substrateAddress: normalizeSubstrateAddress,\n  ethereumAddress: normalizeEthereumAddress,\n}\n\nexport const compare = {\n  substrateAddresses: compareSubstrateAddresses,\n  ethereumAddresses: compareEthereumAddresses,\n}\n\nexport const substrate = {\n  encode: encodeSubstrateAddress,\n  decode: decodeSubstrateAddress,\n  compare: compareSubstrateAddresses,\n}\n\nexport const Address = {\n  constants,\n  algorithms,\n  is,\n  validate,\n  collection,\n  nesting,\n  extract,\n  mirror,\n  normalize,\n  compare,\n  substrate,\n  utils: {\n    DWORDHexString,\n  }\n}\n","export const STATIC_ADDRESSES = <const>{\r\n  contractHelpers: '0x842899ECF380553E8a4de75bF534cdf6fBF64049',\r\n  collectionHelpers: '0x6C4E9fE1AE37a41E93CEE429e8E1881aBdcbb54F',\r\n}\r\nexport const NESTING_PREFIX = <const>'0xf8238ccfff8ed887463fd5e0'\r\nexport const COLLECTION_ADDRESS_PREFIX = <const>'0x17c4e6453cc49aaaaeaca894e6d9683e'\r\n","import basex from 'base-x'\r\nimport {keccak_256} from '@noble/hashes/sha3'\r\nimport {blake2b} from '@noble/hashes/blake2b'\r\n\r\nconst BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\r\nconst BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\nconst base58 = basex(BASE58_ALPHABET)\r\nconst base64 = basex(BASE64_ALPHABET)\r\n\r\nexport {keccak_256, blake2b, base58, base64, basex}\r\n","import {HexString} from 'utf-helpers'\n\nimport {keccak_256} from \"./imports\"\nimport {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from \"./constants\"\nimport {is, validate} from \"./index\"\n\n\nexport const DWORDHexString = {\n  _checkU32: (num: number): number => {\n    if (typeof num !== 'number') throw new Error(`Passed number is not a number: ${typeof num}, ${num}`)\n    if (isNaN(num)) throw new Error(`Passed number is NaN: ${num}`)\n    if (num < 0) throw new Error(`Passed number is less than 0: ${num}`)\n    if (num > 0xFFFFFFFF) throw new Error(`Passed number is more than 2**32: ${num}`)\n    if (num !== Math.floor(num)) throw new Error(`Passed number is not an integer number: ${num}`)\n\n    return num\n  },\n  fromNumber: (n: number): string => {\n    return DWORDHexString._checkU32(n).toString(16).padStart(8, '0')\n  },\n  toNumber: (s: string): number => {\n    const num: number = parseInt(s, 16)\n\n    if (isNaN(num)) throw new Error(`Passed string is not hexadecimal: ${s}`)\n\n    return DWORDHexString._checkU32(num)\n  }\n}\n\n\nconst unsafeNormalizeEthereumAddress = (address: string) => {\n  const addr = address.toLowerCase().replace(/^0x/i, '')\n  const addressHash = HexString.fromU8a(keccak_256(addr)).replace(/^0x/i, '')\n\n  let checksumAddress = '0x'\n\n  for (let i = 0; i < addr.length; i++) {\n    checksumAddress += (parseInt(addressHash[i], 16) > 7)\n      ? addr[i].toUpperCase()\n      : addr[i]\n  }\n\n  return checksumAddress\n}\nexport const normalizeEthereumAddress = (address: string) => {\n  validate.ethereumAddress(address)\n  return unsafeNormalizeEthereumAddress(address)\n}\n\ntype EthAddressObj = { Ethereum: string }\nexport const compareEthereumAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as EthAddressObj).Ethereum || (address1 as any).ethereum) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as EthAddressObj).Ethereum || (address2 as any).ethereum) as string | undefined\n\n  if (!addr1 || !addr2 || !is.ethereumAddress(addr1) || !is.ethereumAddress(addr2)) {\n    return false\n  }\n  return addr1.toLowerCase() === addr2.toLowerCase()\n\n}\n\nexport const collectionIdToEthAddress = (collectionId: number): string => {\n  validate.collectionId(collectionId)\n  return unsafeNormalizeEthereumAddress(\n    COLLECTION_ADDRESS_PREFIX +\n    DWORDHexString.fromNumber(collectionId)\n  )\n}\nexport const ethAddressToCollectionId = (address: string): number => {\n  validate.collectionAddress(address)\n  return DWORDHexString.toNumber(address.slice(-8))\n}\n\nexport const collectionIdAndTokenIdToNestingAddress = (collectionId: number, tokenId: number): string => {\n  validate.collectionId(collectionId)\n  validate.tokenId(tokenId)\n\n  return unsafeNormalizeEthereumAddress(\n    NESTING_PREFIX +\n    DWORDHexString.fromNumber(collectionId) +\n    DWORDHexString.fromNumber(tokenId)\n  )\n}\n\nexport const nestingAddressToCollectionIdAndTokenId = (address: string): { collectionId: number, tokenId: number } => {\n  validate.nestingAddress(address)\n  return {\n    collectionId: DWORDHexString.toNumber(address.slice(-16, -8)),\n    tokenId: DWORDHexString.toNumber(address.slice(-8)),\n  }\n}\n","import {base58, blake2b} from './imports'\nimport {DecodeSubstrateAddressResult, validate, is} from './index'\nimport {normalizeEthereumAddress} from './ethereum'\nimport {HexString} from 'utf-helpers'\n\nconst blake2AsU8a = (u8a: Uint8Array, dkLen: 8 | 16 | 32 | 48 | 64 = 32): Uint8Array => {\n  return blake2b(u8a, {dkLen})\n}\n\nconst u8aConcat = (u8as: readonly Uint8Array[]): Uint8Array => {\n  let offset = 0\n\n  let length = 0\n\n  for (let i = 0; i < u8as.length; i++) {\n    length += u8as[i].length\n  }\n\n  const result = new Uint8Array(length)\n\n  for (let i = 0; i < u8as.length; i++) {\n    result.set(u8as[i], offset)\n    offset += u8as[i].length\n  }\n\n  return result\n}\n\n// strToU8a('SS58PRE')\nconst SS58_PREFIX = new Uint8Array([83, 83, 53, 56, 80, 82, 69])\n\nconst sshash = (data: Uint8Array): Uint8Array => {\n  return blake2AsU8a(u8aConcat([SS58_PREFIX, data]), 64);\n}\n\nconst checkAddressChecksum = (decoded: Uint8Array, ignoreChecksum: boolean = false): [boolean, number, number, number] => {\n  const ss58Length = (decoded[0] & 0b0100_0000) ? 2 : 1;\n  const ss58Decoded = ss58Length === 1\n    ? decoded[0]\n    : ((decoded[0] & 0x3f) << 2) | (decoded[1] >> 6) | ((decoded[1] & 0x3f) << 8);\n\n  // 32/33 bytes public + 2 bytes checksum + prefix\n  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);\n  const length = decoded.length - (isPublicKey ? 2 : 1);\n\n  let isValid = false\n\n  if (!ignoreChecksum) {\n    // calculate the hash and do the checksum byte checks\n    const hash = sshash(decoded.subarray(0, length));\n    isValid = (decoded[0] & 0x80) === 0 && ![46, 47].includes(decoded[0]) && (\n      isPublicKey\n        ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1]\n        : decoded[decoded.length - 1] === hash[0]\n    )\n  }\n\n  return [isValid, length, ss58Length, ss58Decoded];\n}\n\nexport const normalizeSubstrateAddress = (address: string, prefix: number = 42): string => {\n  return encodeSubstrateAddress(decodeSubstrateAddress(address).u8a, prefix)\n}\n\n\nexport function encodeSubstrateAddress(key: Uint8Array | string | bigint, ss58Format: number = 42): string {\n  const u8a: Uint8Array = typeof key === 'string'\n    ? HexString.toU8a(key)\n    : typeof key === 'bigint'\n      ? HexString.toU8a(key.toString(16))\n      : key\n\n  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {\n    throw new Error(`ss58Format is not valid, received ${typeof ss58Format} \"${ss58Format}\"`)\n  }\n\n  const allowedDecodedLengths = [1, 2, 4, 8, 32, 33]\n  if (!allowedDecodedLengths.includes(u8a.length)) {\n    throw new Error(`key length is not valid, received ${u8a.length}, valid values are ${allowedDecodedLengths.join(', ')}`)\n  }\n\n  const u8aPrefix = ss58Format < 64\n    ? new Uint8Array([ss58Format])\n    : new Uint8Array([\n      ((ss58Format & 0xfc) >> 2) | 0x40,\n      (ss58Format >> 8) | ((ss58Format & 0x03) << 6)\n    ])\n\n  const input = u8aConcat([u8aPrefix, u8a])\n\n  return base58.encode(\n    u8aConcat([\n      input,\n      sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)\n    ])\n  );\n}\n\nexport function decodeSubstrateAddress(address: string, ignoreChecksum?: boolean, ss58Format: number = -1): DecodeSubstrateAddressResult {\n  let realError: Error | null = null\n\n  try {\n    if (is.substratePublicKey(address)) {\n      return {\n        u8a: HexString.toU8a(address),\n        bigint: BigInt(address),\n        hex: address,\n        ss58Prefix: 42,\n      }\n    } else if (address.startsWith('0x')) {\n      throw new Error(`Invalid substrate address, received ${address}. Wrong or mangled public key?`)\n    }\n\n    const decoded = base58.decode(address);\n\n    const allowedEncodedLengths = [3, 4, 6, 10, 35, 36, 37, 38]\n\n    if (!allowedEncodedLengths.includes(decoded.length)) {\n      realError = new Error(`key length is not valid, decoded key length is ${decoded.length}, valid values are ${allowedEncodedLengths.join(', ')}`)\n      throw realError\n    }\n\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded, ignoreChecksum)\n\n    if (!ignoreChecksum && !isValid) {\n      realError = new Error(`Invalid decoded address checksum`)\n      throw realError\n    }\n    if (![-1, ss58Decoded].includes(ss58Format)) {\n      realError = new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`)\n      throw realError\n    }\n\n    const publicKey = decoded.slice(ss58Length, endPos)\n\n    const hex: string = HexString.fromU8a(publicKey)\n    return {\n      u8a: publicKey,\n      hex,\n      bigint: BigInt(hex),\n      ss58Prefix: ss58Decoded,\n    }\n  } catch (error) {\n    throw realError\n      ? realError\n      : new Error(`Decoding ${address}: ${(error as Error).message}`)\n  }\n}\n\ntype SubAddressObj = { Substrate: string }\nexport const compareSubstrateAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as SubAddressObj).Substrate || (address1 as any).substrate) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as SubAddressObj).Substrate || (address2 as any).substrate) as string | undefined\n\n  if (!addr1 || !addr2) {\n    return false\n  }\n\n  try {\n    const decoded1 = decodeSubstrateAddress(addr1)\n    const decoded2 = decodeSubstrateAddress(addr2)\n    return decoded1.bigint === decoded2.bigint\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addressToEvm = (address: string, ignoreChecksum?: boolean): string => {\n  const truncated = decodeSubstrateAddress(address, ignoreChecksum).u8a.subarray(0, 20)\n  return normalizeEthereumAddress(HexString.fromU8a(truncated))\n}\n\n// strToU8a('evm:')\nconst EVM_PREFIX_U8A = new Uint8Array([101, 118, 109, 58])\nexport const evmToAddress = (evmAddress: string, ss58Format: number = 42): string => {\n  validate.ethereumAddress(evmAddress)\n\n  const message = u8aConcat([EVM_PREFIX_U8A, HexString.toU8a(evmAddress)])\n\n  return encodeSubstrateAddress(blake2AsU8a(message), ss58Format)\n}\n","import {normalizeEthereumAddress} from './ethereum'\nimport {normalizeSubstrateAddress, decodeSubstrateAddress} from './substrate'\nimport {CrossAccountId, EnhancedCrossAccountId} from '../types'\nimport {is, mirror, validate} from './index'\n\nexport const guessAddressAndExtractCrossAccountIdUnsafe = (rawAddress: string | object, normalize: boolean = false): CrossAccountId => {\n  const address = rawAddress as any\n\n  if (typeof address === 'object') {\n    if (address.hasOwnProperty('eth') && address.hasOwnProperty('sub')) {\n      // bn.js value extraction for ethers.js\n      const subPublicKey = (address.sub.hasOwnProperty('_hex') && typeof address.sub._hex === 'string')\n        ? address.sub._hex\n        : address.sub\n      if (typeof subPublicKey !== 'string' || !subPublicKey.startsWith('0x')) {\n        throw new Error(`Substrate public key must be a hex string, got ${subPublicKey}`)\n      }\n\n      const subBigInt = BigInt(subPublicKey)\n      const ethBigInt = BigInt(address.eth)\n\n      if (!(Number(subBigInt === 0n) ^ Number(ethBigInt === 0n))) {\n        throw new Error(`One of the addresses must be 0, got eth ${address.eth} and substrate public key ${address.sub}.`)\n      }\n\n      // always normalize addresses from the EthCrossAccountId\n      if (subBigInt === 0n) {\n        return {Ethereum: normalizeEthereumAddress(address.eth)}\n      } else {\n        return {Substrate: normalizeSubstrateAddress(subPublicKey)}\n      }\n    } else if (address.hasOwnProperty('Substrate') || address.hasOwnProperty('substrate')) {\n      const substrateAddress = address.hasOwnProperty('Substrate') ? address.Substrate : address.substrate\n      if (is.substratePublicKey(substrateAddress)) {\n        return {Substrate: normalizeSubstrateAddress(substrateAddress)}\n      } else if (is.substrateAddress(substrateAddress)) {\n        return {Substrate: normalize ? normalizeSubstrateAddress(substrateAddress) : substrateAddress}\n      } else {\n        throw new Error(`Address ${substrateAddress} is not a valid Substrate address`)\n      }\n    } else if (address.hasOwnProperty('Ethereum') || address.hasOwnProperty('ethereum')) {\n      const ethereumAddress = address.hasOwnProperty('Ethereum') ? address.Ethereum : address.ethereum\n      validate.ethereumAddress(ethereumAddress)\n      return {Ethereum: normalize ? normalizeEthereumAddress(ethereumAddress) : ethereumAddress}\n    } else {\n      throw new Error(`Address ${address} is not a valid crossAccountId object (should contain \"Substrate\"/\"substrate\" or \"Ethereum\"/\"ethereum\" field) or EthCrossAccountId (should contain \"eth\" and \"sub\" fields)`)\n    }\n  }\n\n  if (typeof address === 'string') {\n    if (is.substrateAddress(address)) return {Substrate: normalize ? normalizeSubstrateAddress(address) : address}\n    else if (is.ethereumAddress(address)) return {Ethereum: normalize ? normalizeEthereumAddress(address) : address}\n    else if (is.substratePublicKey(address)) return {Substrate: normalizeSubstrateAddress(address)}\n    else {\n      throw new Error(`Address ${address} is not a valid Substrate or Ethereum address`)\n    }\n  }\n\n  throw new Error(`Address ${address} is not a string or object: ${typeof address}`)\n}\n\nexport const guessAddressAndExtractCrossAccountIdSafe = (address: string | object, normalize: boolean = false): CrossAccountId | null => {\n  try {\n    return guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  } catch {\n    return null\n  }\n}\n\nexport const substrateOrMirrorIfEthereum = (address: string | object, normalize: boolean = false): string => {\n  const addressObject = guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  return addressObject.Substrate\n    ? addressObject.Substrate\n    : mirror.ethereumToSubstrate(addressObject.Ethereum as string)\n}\n\nexport const addressInAnyFormToEnhancedCrossAccountId = (address: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n  const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(address)\n\n  if (crossAccountId.Ethereum) {\n    const normalized = normalizeEthereumAddress(crossAccountId.Ethereum)\n    return {\n      ...crossAccountId,\n      address: normalized,\n      addressSS58: normalized,\n      substratePublicKey: normalized,\n      isEthereum: true,\n      isSubstrate: false,\n      type: 'Ethereum',\n    }\n  } else {\n    return {\n      ...crossAccountId,\n      address: normalizeSubstrateAddress(crossAccountId.Substrate as string),\n      addressSS58: normalizeSubstrateAddress(crossAccountId.Substrate as string, ss58Prefix),\n      substratePublicKey: decodeSubstrateAddress(crossAccountId.Substrate as string).hex,\n      isEthereum: false,\n      isSubstrate: true,\n      type: 'Substrate',\n    }\n  }\n}\n","import * as Address from './Address'\nimport * as constants from './Address/constants'\nimport * as StringUtils from 'utf-helpers'\nimport * as CoinUtils from './Utils/coin'\n\nexport {\n  Address,\n  StringUtils,\n  constants,\n  CoinUtils,\n}\n\nexport const {\n  HexString,\n  Utf8,\n  Utf16,\n} = StringUtils\n\nexport const HexUtils = StringUtils.HexString\n\nexport {Coin} from './Utils/coin'\nexport type {ICoin, ICoinFormats} from './Utils/coin'\n\nexport * from './types'\n","export * from 'coin-format'\n","import {RoyaltyAmount, RoyaltyType, UniqueRoyaltyPartToEncode} from './types'\nimport {parseRoyaltyPart} from './utils'\n\nexport const calculateRoyaltyPart = (\n  part: UniqueRoyaltyPartToEncode,\n  sellPrice: bigint,\n): RoyaltyAmount => {\n  const royalty = parseRoyaltyPart(part)\n  return {\n    address: royalty.address,\n    amount: (sellPrice * royalty.value) / 10n ** BigInt(royalty.decimals),\n  }\n}\n\nexport const calculateRoyalties = (\n  royalties: UniqueRoyaltyPartToEncode[],\n  isPrimarySale: boolean,\n  sellPrice: bigint,\n): RoyaltyAmount[] => {\n  return royalties\n    .filter(\n      (r) => isPrimarySale === (r.royaltyType === RoyaltyType.PRIMARY_ONLY),\n    )\n    .map((r) => calculateRoyaltyPart(r, sellPrice))\n}\n","import {Address} from '../Address'\n\nimport {IV2Royalty, RoyaltyType, UniqueRoyaltyPart} from './types'\nimport {splitStringEvery} from './utils'\n\nexport const decodeRoyaltyPart = (encoded: string): UniqueRoyaltyPart => {\n  if (encoded.length !== 130) {\n    throw new Error('Invalid royalty part encoding - length is not 32 bytes (\"0x\" + 64 symbols)')\n  }\n  const encodedMeta = encoded.slice(2, 66)\n  const encodedAddress = encoded.slice(2 + 64)\n\n  const version = parseInt(encodedMeta.slice(0, 2), 16)\n  const decimals = parseInt(encodedMeta.slice(46, 46 + 2), 16)\n  const value = BigInt('0x' + encodedMeta.slice(48))\n  const royaltyType = encodedMeta[44] === '0'\n    ? RoyaltyType.DEFAULT\n    : RoyaltyType.PRIMARY_ONLY\n\n  const isEthereum = encodedMeta[45] === '0'\n  const address = isEthereum\n    ? Address.normalize.ethereumAddress('0x' + encodedAddress.slice(24))\n    : Address.substrate.encode(encodedAddress)\n\n  return {\n    version,\n    decimals,\n    value,\n    royaltyType,\n    address,\n  }\n}\n\nexport const decodeRoyalties = (encoded: string): UniqueRoyaltyPart[] => {\n  if (((encoded.length - 2) % 128) !== 0) {\n    throw new Error('Invalid royalties encoding - length is not multiple of 64 bytes (128 symbols)')\n  }\n\n  const parts = splitStringEvery(encoded.substring(2), 128).map(\n    (encoded) => '0x' + encoded,\n  )\n\n  return parts.map((part) => decodeRoyaltyPart(part))\n}\n\nexport const decodeRoyaltyToV2 = (encoded: string): IV2Royalty[] => {\n  const royaltyParts = encoded ? decodeRoyalties(encoded) : []\n\n  return royaltyParts.map((royaltyPart) => {\n    const royalty: IV2Royalty = {\n      address: royaltyPart.address,\n      // core idea: given value   2500 with decimals 4, we want to get 2.5\n      //                     or 650000 with decimals 6, we want to get 6.5\n      percent: Number(royaltyPart.value) / (Math.pow(10, royaltyPart.decimals - 2)),\n    }\n    if (royaltyPart.royaltyType === RoyaltyType.PRIMARY_ONLY) {\n      royalty.isPrimaryOnly = true\n    }\n    return royalty\n  })\n}\n","import {IV2Royalty, RoyaltyType, UniqueRoyaltyPart, UniqueRoyaltyPartToEncode} from './types'\nimport {encodeAddress, get42Zeros, parseRoyaltyPart} from './utils'\n\n/**\n * encodes a UniqueRoyaltyPart into a hex string\n * @param part UniqueRoyaltyPart\n * @returns hex string where first 64 characters are metadata in format:\n * VV000000000000000000000000000000000000000000RADDvvvvvvvvvvvvvvvv\n * where:\n * VV - version\n * 42 zeros\n * R - royalty type (0 - default, 1 - primary-only)\n * A - address type (0 - ethereum, 1 - substrate)\n * DD - decimals\n * vvvvvvvvvvvvvvvvvv - value (uint64)\n *\n * and the rest of the string is the address encoded as hex\n */\nexport const encodeRoyaltyPart = (\n  royaltyPart: UniqueRoyaltyPartToEncode,\n): string => {\n  const part = parseRoyaltyPart(royaltyPart)\n\n  const version = part.version.toString(16).padStart(2, '0')\n  const royaltyType = part.royaltyType === RoyaltyType.DEFAULT ? '0' : '1'\n  const decimals = part.decimals.toString(16).padStart(2, '0')\n\n  const value = part.value.toString(16).padStart(16, '0')\n\n  const [isEthereum, address] = encodeAddress(part.address)\n  const addressType = isEthereum ? '0' : '1'\n\n  return `0x${version}${get42Zeros()}${royaltyType}${addressType}${decimals}${value}${address}`\n}\n\nexport const encodeRoyalties = (\n  parts: UniqueRoyaltyPartToEncode[],\n): string =>\n  '0x' + parts.map((part) => encodeRoyaltyPart(part).substring(2)).join('')\n\n\nexport const encodeRoyaltyFromV2 = (royalties: IV2Royalty[]) => {\n  const royaltiesToEncode = royalties.map((royalty) => {\n    const {address, percent, isPrimaryOnly} = royalty;\n    const valueInPercent = percent * 100\n\n    // if valueInPercent is not integer\n    if (valueInPercent % 1 !== 0) throw new Error('Royalty percent value must has maximum 2 decimal places')\n\n    return {\n      address,\n      value: BigInt(percent * 100),\n      decimals: 4,\n      royaltyType: isPrimaryOnly ? RoyaltyType.PRIMARY_ONLY : RoyaltyType.DEFAULT,\n      version: 1,\n    } satisfies UniqueRoyaltyPart\n  })\n\n  return encodeRoyalties(royaltiesToEncode)\n}\n"],"mappings":"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","names":["RoyaltyType","basex","import_utf_helpers","normalize","HexString","encoded"]}