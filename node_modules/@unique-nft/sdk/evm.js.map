{"version":3,"sources":["../../../packages/sdk/src/common/base-client.ts","../../../packages/sdk/src/errors/api-error.ts","../../../packages/sdk/src/errors/max-status-requests-error.ts","../../../packages/sdk/src/errors/timeout-error.ts","../../../packages/sdk/src/types/enums.ts","../../../packages/common/types/subscriptions.ts","../../../packages/sdk/src/common/section.ts","../../../packages/sdk/src/common/utils.ts","../../../packages/sdk/src/sections/extrinsic.ts","../../../packages/sdk/package.json","../../../packages/sdk/src/common/mutation.ts","../../../packages/sdk/src/sections/evm/utils.ts","../../../packages/sdk/src/sections/evm/mutation/evm.ts","../../../packages/sdk/src/sections/evm/mutation/contract.ts","../../../packages/sdk/src/sections/evm/contract.ts","../../../packages/sdk/src/sections/evm/evm.ts","../../../packages/sdk/src/sections/evm/evm-client.ts","../../../packages/sdk/src/common/constants.ts","../../../packages/sdk/src/evm.ts"],"sourcesContent":["import Axios, { AxiosInstance } from 'axios';\n\nimport { IBaseClient, IExtrinsics, Options } from '../types';\nimport { ApiError } from '../errors';\n\nimport { Extrinsic } from '../sections/extrinsic';\n\nimport { version } from '../../package.json';\n\nexport class BaseClient implements IBaseClient {\n  public instance: AxiosInstance;\n\n  public readonly options: Options;\n\n  public readonly extrinsic: IExtrinsics;\n\n  constructor(options: Options) {\n    this.options = options;\n    this.checkOptions();\n\n    this.instance = Axios.create({\n      baseURL: `${this.options.baseUrl}`,\n      maxContentLength: Infinity,\n      maxBodyLength: Infinity,\n      ...options.axiosConfig,\n    });\n\n    this.instance.interceptors.response.use(\n      (response) => response,\n      (exception) => {\n        const err = exception.response?.data?.error;\n        throw err && typeof err === 'object' ? new ApiError(err) : exception;\n      },\n    );\n\n    if (version) {\n      this.instance.defaults.headers.common['X-SDK-Version'] = version;\n    }\n\n    this.extrinsic = new Extrinsic(this, 'extrinsic');\n  }\n\n  private checkOptions() {\n    const { baseUrl } = this.options;\n\n    if (!this.options.baseUrl) {\n      throw new Error(`'baseUrl' option is required`);\n    }\n\n    this.options.baseUrl = baseUrl.replace(/\\/$/, '');\n\n    if (!this.options.statusTotalTimeoutInMs) {\n      this.options.statusTotalTimeoutInMs = 3 * 60 * 1000;\n    }\n\n    if (!this.options.maximumNumberOfStatusRequests) {\n      this.options.maximumNumberOfStatusRequests = Number.MAX_SAFE_INTEGER;\n    }\n\n    if (!this.options.waitBetweenStatusRequestsInMs) {\n      this.options.waitBetweenStatusRequestsInMs = 5_000;\n    }\n  }\n}\n","interface RestError {\n  code: string;\n  name: string;\n  message: string;\n  details?: unknown;\n}\n\nexport class ApiError extends Error implements RestError {\n  public readonly code: string;\n\n  public readonly details: unknown;\n\n  constructor(responseError: RestError) {\n    super(responseError.message);\n    this.code = responseError.code;\n    this.name = responseError.name;\n    this.details = responseError.details;\n  }\n}\n","/**\n * Error thrown when the maximum number of status requests has been reached.\n */\nexport class MaxStatusRequestsError extends Error {\n  details: string;\n\n  txHash: string;\n\n  limit: number;\n\n  constructor(txHash: string, limit: number) {\n    const message = `Extrinsic status was not changed within the specified count of status requests (${limit}).`;\n\n    super(message);\n\n    this.details =\n      `${message} This does not mean that the Extrinsic has failed nor that it will be included in the future.` +\n      ' You can check the status of the Extrinsic by calling the getStatus() method.';\n\n    this.txHash = txHash;\n    this.limit = limit;\n  }\n}\n","export class TimeoutError extends Error {\n  details: string;\n\n  txHash: string;\n\n  timeoutMs: number;\n\n  constructor(txHash: string, timeoutMs: number) {\n    const message = `Extrinsic status was not changed within the specified time (${timeoutMs} ms).`;\n\n    super(message);\n    this.details =\n      `${message} This does not mean that the Extrinsic has failed nor that it will be included in the future.` +\n      ' You can check the status of the Extrinsic by calling the getStatus() method.';\n\n    this.txHash = txHash;\n    this.timeoutMs = timeoutMs;\n  }\n}\n","export enum Method {\n  GET = 'GET',\n  POST = 'POST',\n  DELETE = 'DELETE',\n  PATCH = 'PATCH',\n  PUT = 'PUT',\n}\n","export enum Rooms {\n  SYSTEM = 'system',\n  BLOCKS = 'blocks',\n  EXTRINSICS = 'extrinsics',\n  COLLECTION = 'collection',\n  CONTRACT = 'contract',\n  EVENTS = 'events',\n  BALANCE = 'balance',\n  ACCOUNT_CURRENT_BALANCE = 'account-current-balance',\n}\n\nexport enum SubscriptionEvents {\n  SYSTEM = 'system',\n  BLOCKS = 'blocks',\n  EXTRINSICS = 'extrinsics',\n  EVENTS = 'events',\n  CONTRACT_LOGS = 'contract-logs',\n  COLLECTIONS = 'collections',\n  HAS_NEXT = 'has-next',\n  BALANCES = 'balances',\n  ACCOUNT_CURRENT_BALANCE = 'account-current-balance',\n  SUBSCRIBE_STATE = 'subscribe-state',\n}\n\nexport interface Room {\n  name: Rooms;\n  data: {\n    [key: string]: string;\n  };\n}\n\nexport interface BlockFilter {\n  fromBlock?: number;\n}\n\nexport interface ExtrinsicFilter extends BlockFilter {\n  signer?: string | '*';\n}\n\nexport interface CollectionFilter extends ExtrinsicFilter {\n  collectionId?: number | '*';\n}\n\nexport interface BalancesFilter extends ExtrinsicFilter {\n  address?: string | '*';\n}\n\nexport interface AccountCurrentBalanceFilter {\n  address?: string | '*';\n}\n\nexport interface ContractFilter extends ExtrinsicFilter {\n  address?: string | '*';\n}\n\nexport interface EventsFilter extends ExtrinsicFilter {\n  section?: string | '*';\n  method?: string | '*';\n}\n\nexport interface ContractLog {\n  address: string;\n  topics: Array<any>;\n  data: string;\n}\n\nexport enum BalanceMethods {\n  WITHDRAW = 'Withdraw',\n  TRANSFER = 'Transfer',\n  DEPOSIT = 'Deposit',\n\n  DUST_LOST = 'DustLost',\n  ENDOWED = 'Endowed',\n  LOCKED = 'Locked',\n  UNLOCKED = 'Unlocked',\n  RESERVED = 'Reserved',\n}\n\nexport interface BalancesParsedData {\n  method: BalanceMethods;\n  from?: string;\n  to?: string;\n  amount: string;\n}\n","import { IBaseClient, ISection, Method } from '../types';\n\nexport abstract class Section implements ISection {\n  public readonly baseUrl: string;\n\n  constructor(\n    public readonly client: IBaseClient,\n    public readonly path: string,\n  ) {\n    this.baseUrl = `${this.client.options.baseUrl}/${path}`;\n  }\n\n  async query<P, R>(url: string, params?: P): Promise<R> {\n    const response = await this.client.instance({\n      method: Method.GET,\n      baseURL: this.baseUrl,\n      url,\n      params,\n    });\n    return response.data;\n  }\n\n  async postRequest<P, R, Q>(url: string, data?: P, params?: Q): Promise<R> {\n    const response = await this.client.instance({\n      method: Method.POST,\n      baseURL: this.baseUrl,\n      url,\n      data,\n      params,\n    });\n    return response.data;\n  }\n}\n","import {\n  SubmitTxBody,\n  UnsignedTxPayloadResponse,\n  Account,\n  Options,\n  Signer,\n  WithAddress,\n  WithOptionalAddress,\n} from '../types';\n\nexport const isUnsignedTxPayloadResponse = (\n  args: unknown,\n): args is UnsignedTxPayloadResponse =>\n  typeof args === 'object' && !!args && 'signerPayloadJSON' in args;\n\nexport const isSubmitTxBody = (args: unknown): args is SubmitTxBody =>\n  isUnsignedTxPayloadResponse(args) && !!args && 'signature' in args;\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nconst hasOwnProperty = (obj: unknown, prop: string): boolean =>\n  Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport const getSigner = (\n  options: Options,\n  accountOrSigner?: Account | Signer,\n): Signer | undefined => {\n  if (accountOrSigner) {\n    return hasOwnProperty(accountOrSigner, 'sign')\n      ? (accountOrSigner as Signer)\n      : (accountOrSigner as Account).signer;\n  }\n\n  if (options.signer) return options.signer;\n  if (options.account?.signer) return options.account.signer;\n\n  return undefined;\n};\n\nconst getAddress = (\n  options: Options,\n  args: { address?: string },\n): string | undefined => {\n  if (args.address) return args.address;\n  if (options.signer?.address) return options.signer.address;\n  if (options.account?.address) return options.account.address;\n  if (options.account?.signer?.address) return options.account.signer.address;\n\n  return undefined;\n};\n\nexport const addAddress = <A extends WithOptionalAddress>(\n  options: Options,\n  args: A,\n): A & WithAddress => {\n  const address = getAddress(options, args);\n  if (!address) throw new Error('No address provided');\n\n  return { ...args, address };\n};\n","/* eslint-disable no-await-in-loop */\n\nimport { Section } from '../common';\nimport {\n  SignTxResultResponse,\n  UnsignedTxPayloadBody,\n  SubmitTxBody,\n  SubmitResultResponse,\n  ExtrinsicResultResponse,\n  FeeResponse,\n  ExtrinsicResultRequest,\n  GetExtrinsicQuery,\n  GetExtrinsicResponse,\n  Method,\n  SdkTxBuildBody,\n  Account,\n  Signer,\n  IExtrinsics,\n  Options,\n} from '../types';\nimport { sleep } from '../common/utils';\nimport { TimeoutError, MaxStatusRequestsError } from '../errors';\n\nconst getSigner = (\n  options: Options,\n  accountOrSigner?: Account | Signer,\n): Signer | undefined => {\n  if (accountOrSigner) {\n    return 'sign' in accountOrSigner\n      ? (accountOrSigner as Signer)\n      : (accountOrSigner as Account).signer;\n  }\n\n  if (options.signer) return options.signer;\n  if (options.account?.signer) return options.account.signer;\n\n  return undefined;\n};\n\nconst getAddress = (\n  options: Options,\n  args: { address?: string },\n): string | undefined => {\n  if (args.address) return args.address;\n  if (options.signer?.address) return options.signer.address;\n  if (options.account?.address) return options.account.address;\n  if (options.account?.signer?.address) return options.account.signer.address;\n\n  return undefined;\n};\n\nexport class Extrinsic extends Section implements IExtrinsics {\n  async build(args: SdkTxBuildBody): Promise<UnsignedTxPayloadBody> {\n    const address = getAddress(this.client.options, args);\n\n    if (!address) throw new Error('Invalid address');\n\n    const response = await this.client.instance({\n      method: Method.POST,\n      baseURL: this.baseUrl,\n      url: 'build',\n      data: {\n        ...args,\n        address,\n      },\n    });\n\n    return response.data;\n  }\n\n  async getFee(\n    args: SdkTxBuildBody | UnsignedTxPayloadBody | SubmitTxBody,\n  ): Promise<FeeResponse> {\n    const response = await this.client.instance({\n      method: Method.POST,\n      baseURL: this.baseUrl,\n      url: 'calculate-fee',\n      data: args,\n    });\n    return response.data;\n  }\n\n  async sign(\n    args: UnsignedTxPayloadBody,\n    signer?: Account | Signer,\n  ): Promise<SignTxResultResponse> {\n    const signerToUse = getSigner(this.client.options, signer);\n\n    if (!signerToUse) throw new Error(`No signer provided`);\n\n    return signerToUse.sign(args);\n  }\n\n  async submit(args: SubmitTxBody): Promise<SubmitResultResponse> {\n    const response = await this.client.instance({\n      method: Method.POST,\n      baseURL: this.baseUrl,\n      url: 'submit',\n      data: args,\n    });\n    return response.data;\n  }\n\n  async submitWatch(\n    args: SdkTxBuildBody,\n    signer = this.client.options.signer,\n  ): Promise<SubmitResultResponse> {\n    const txBuild = await this.client.extrinsic.build(args);\n\n    const signedTxPayload = await this.client.extrinsic.sign(txBuild, signer);\n\n    const submitTxResult = await this.client.extrinsic.submit({\n      signerPayloadJSON: txBuild.signerPayloadJSON,\n      signature: signedTxPayload.signature,\n    });\n\n    return submitTxResult;\n  }\n\n  async submitWaitResult(\n    args: SdkTxBuildBody,\n    signer = this.client.options.signer,\n  ): Promise<ExtrinsicResultResponse<any>> {\n    const { hash } = await this.client.extrinsic.submitWatch(args, signer);\n\n    return this.client.extrinsic.waitResult({ hash });\n  }\n\n  async waitResult({\n    hash,\n  }: {\n    hash: string;\n  }): Promise<ExtrinsicResultResponse<any>> {\n    const timeout = this.client.options.statusTotalTimeoutInMs;\n    const maxRequests = this.client.options.maximumNumberOfStatusRequests;\n    const waitTime = this.client.options.waitBetweenStatusRequestsInMs;\n\n    let isTimeExceeded = false;\n    setTimeout(() => {\n      isTimeExceeded = true;\n    }, timeout);\n\n    let requestCount = 0;\n\n    do {\n      const checkStatusResult = await this.client.extrinsic.status({ hash });\n\n      if (checkStatusResult.isCompleted || checkStatusResult.error) {\n        return checkStatusResult;\n      }\n\n      await sleep(waitTime);\n      requestCount += 1;\n    } while (!isTimeExceeded && requestCount < maxRequests);\n\n    if (isTimeExceeded) throw new TimeoutError(hash, timeout);\n\n    throw new MaxStatusRequestsError(hash, maxRequests);\n  }\n\n  async status(\n    args: ExtrinsicResultRequest,\n  ): Promise<ExtrinsicResultResponse<any>> {\n    const response = await this.client.instance({\n      method: Method.GET,\n      baseURL: this.baseUrl,\n      url: 'status',\n      params: args,\n    });\n    return response.data;\n  }\n\n  async get(args: GetExtrinsicQuery): Promise<GetExtrinsicResponse> {\n    const response = await this.client.instance({\n      method: Method.GET,\n      baseURL: this.baseUrl,\n      url: '',\n      params: args,\n    });\n    return response.data;\n  }\n}\n","{\n  \"name\": \"@unique-nft/sdk\",\n  \"version\": \"0.7.7\",\n  \"type\": \"module\",\n  \"homepage\": \"https://unique.network/\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/UniqueNetwork/unique-sdk.git\"\n  },\n  \"dependencies\": {\n    \"abi-coder\": \"^4.1.1\",\n    \"axios\": \"^1.7.2\",\n    \"form-data\": \"^4.0.0\",\n    \"socket.io-client\": \"^4.5.4\",\n    \"@unique-nft/utils\": \"^0.3.19\",\n    \"@unique-nft/sr25519\": \"^0.0.2\"\n  },\n  \"description\": \"The @unique-nft/sdk package implements the SDK methods via the REST API. The package implements all the basic methods for working with the Unique Network SDK.\",\n  \"keywords\": [\n    \"blockchain\",\n    \"parachain\",\n    \"polkadot\",\n    \"unique network\",\n    \"nft\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/UniqueNetwork/unique-sdk/issues\"\n  },\n  \"license\": \"MIT\",\n  \"author\": {\n    \"name\": \"Unique Network SDK team\"\n  },\n  \"types\": \"index.d.ts\",\n  \"main\": \"index.js\",\n  \"module\": \"index.mjs\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"require\": \"./index.cjs\",\n      \"default\": \"./index.js\"\n    },\n    \"./evm\": {\n      \"types\": \"./evm.d.ts\",\n      \"require\": \"./evm.cjs\",\n      \"default\": \"./evm.js\"\n    },\n    \"./subscriptions\": {\n      \"types\": \"./subscriptions.d.ts\",\n      \"require\": \"./subscriptions.cjs\",\n      \"default\": \"./subscriptions.js\"\n    },\n    \"./full\": {\n      \"types\": \"./full.d.ts\",\n      \"require\": \"./full.cjs\",\n      \"default\": \"./full.js\"\n    },\n    \"./sr25519\": {\n      \"types\": \"./sr25519.d.ts\",\n      \"require\": \"./sr25519.cjs\",\n      \"default\": \"./sr25519.js\"\n    },\n    \"./extension\": {\n      \"types\": \"./extension.d.ts\",\n      \"require\": \"./extension.cjs\",\n      \"default\": \"./extension.js\"\n    },\n    \"./utils\": {\n      \"types\": \"./utils.d.ts\",\n      \"require\": \"./utils.cjs\",\n      \"default\": \"./utils.js\"\n    }\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport {\n  ExtrinsicResultResponse,\n  SubmitResultResponse,\n  SubmitTxBody,\n  UnsignedTxPayloadResponse,\n  BuildSequencePayloadsResponse,\n  IMutation,\n  Method,\n  FeeBodyResponse,\n  IBaseClient,\n  MutationOptions,\n  IMutationEx,\n  WithOptionalAddress,\n  BatchCallArgumentsBody,\n  MethodNameBody,\n} from '../types';\nimport {\n  isUnsignedTxPayloadResponse,\n  isSubmitTxBody,\n  addAddress,\n} from './utils';\n\nexport abstract class MutationAbstract<A extends WithOptionalAddress, R>\n  implements IMutation<A, R>\n{\n  public readonly url: string;\n\n  constructor(\n    private readonly client: IBaseClient,\n    private readonly method: Method,\n    private readonly path: string,\n    private readonly methodName: MethodNameBody,\n  ) {\n    this.url = `${this.client.options.baseUrl}/${this.path}`;\n  }\n\n  async buildBatch(\n    args: A[],\n    options?: MutationOptions,\n  ): Promise<BuildSequencePayloadsResponse> {\n    const data = args.map((a) => addAddress(this.client.options, a));\n\n    const response = await this.client.instance({\n      method: this.method,\n      url: this.url,\n      params: { ...options, use: 'BuildBatch' },\n      data,\n    });\n\n    return response.data;\n  }\n\n  async build(\n    args: A,\n    options?: MutationOptions,\n  ): Promise<UnsignedTxPayloadResponse> {\n    const data = addAddress(this.client.options, args);\n\n    const response = await this.client.instance({\n      method: this.method,\n      url: this.url,\n      params: { ...options, use: 'Build' },\n      data,\n    });\n\n    return response.data;\n  }\n\n  async getFee(\n    args:\n      | A\n      | UnsignedTxPayloadResponse\n      | SubmitTxBody\n      | Array<A | UnsignedTxPayloadResponse | SubmitTxBody>,\n  ): Promise<FeeBodyResponse> {\n    const response = await this.client.instance({\n      method: this.method,\n      url: this.url,\n      params: { use: 'GetFee' },\n      data: args,\n    });\n\n    return response?.data as FeeBodyResponse;\n  }\n\n  async sign(\n    args: A | UnsignedTxPayloadResponse,\n    options?: MutationOptions,\n  ): Promise<SubmitTxBody> {\n    const unsigned = isUnsignedTxPayloadResponse(args)\n      ? args\n      : await this.build(args, options);\n\n    const { signerPayloadJSON } = unsigned;\n    const { signature } = await this.client.extrinsic.sign(\n      unsigned,\n      options?.signer,\n    );\n    return { signature, signerPayloadJSON };\n  }\n\n  async submit(\n    args: A | UnsignedTxPayloadResponse | SubmitTxBody,\n    options?: MutationOptions,\n  ): Promise<SubmitResultResponse> {\n    const submitTxArguments = isSubmitTxBody(args)\n      ? args\n      : await this.sign(args, options);\n\n    const response = await this.client.instance({\n      method: this.method,\n      url: this.url,\n      params: { ...options, use: 'Submit' },\n      data: submitTxArguments,\n    });\n\n    return response.data;\n  }\n\n  async submitWatch(\n    args: A | UnsignedTxPayloadResponse | SubmitTxBody,\n    options?: MutationOptions,\n  ): Promise<SubmitResultResponse> {\n    const submitTxArguments = isSubmitTxBody(args)\n      ? args\n      : await this.sign(args, options);\n\n    const response = await this.client.instance({\n      method: this.method,\n      url: this.url,\n      params: { ...options, use: 'SubmitWatch' },\n      data: submitTxArguments,\n    });\n\n    return response.data;\n  }\n\n  async submitWaitResult(\n    args: A | UnsignedTxPayloadResponse | SubmitTxBody,\n    options?: MutationOptions,\n  ): Promise<ExtrinsicResultResponse<R>> {\n    const { hash } = await this.submitWatch(args, options);\n\n    return this.client.extrinsic.waitResult({ hash });\n  }\n\n  public batchCall(args: A): BatchCallArgumentsBody {\n    if (!this.methodName) {\n      throw new Error(`Batching not defined in method: ${this.path}`);\n    }\n\n    return {\n      method: this.methodName,\n      rawPayload: args,\n    };\n  }\n}\n\nclass Mutation<A, R> extends MutationAbstract<A, R> {}\n\nexport function createMutationByInstance<A, R>(\n  mutation: Mutation<A, R>,\n): IMutationEx<A, R> {\n  const submitWaitResult = (\n    args: A | UnsignedTxPayloadResponse | SubmitTxBody,\n    options?: MutationOptions,\n  ) => mutation.submitWaitResult(args, options);\n\n  submitWaitResult.build = mutation.build.bind(mutation);\n  submitWaitResult.buildBatch = mutation.buildBatch.bind(mutation);\n  submitWaitResult.getFee = mutation.getFee.bind(mutation);\n  submitWaitResult.sign = mutation.sign.bind(mutation);\n  submitWaitResult.submit = mutation.submit.bind(mutation);\n  submitWaitResult.submitWatch = mutation.submitWatch.bind(mutation);\n  submitWaitResult.submitWaitResult = mutation.submitWaitResult.bind(mutation);\n  submitWaitResult.batchCall = mutation.batchCall.bind(mutation);\n\n  return submitWaitResult as IMutationEx<A, R>;\n}\n\nexport const MethodNameNull = null;\n\nexport function createMutationEx<A, R>(\n  client: IBaseClient,\n  method: Method,\n  path: string,\n  methodName: MethodNameBody | null,\n): IMutationEx<A, R> {\n  const mutation = new Mutation<A, R>(client, method, path, methodName);\n\n  return createMutationByInstance(mutation);\n}\n","import { Coder, Event } from 'abi-coder';\n\nimport {\n  AbiItemDto,\n  EvmEvent,\n  EvmEvents,\n  EvmUnknownEvent,\n  ExtrinsicResultEvent,\n} from '../../types';\n\nexport const parseEvmEvents = (\n  events: ExtrinsicResultEvent[],\n  abi: AbiItemDto[],\n): EvmEvents => {\n  const erc20Coder = new Coder(abi);\n  const parsedEvents: EvmEvent[] = [];\n  const unknownEvents: EvmUnknownEvent[] = [];\n\n  events\n    .filter((event) => event.section === 'evm' && event.method === 'Log')\n    .forEach((event) => {\n      const logData = event.data[0];\n\n      const { topics, data } = logData;\n\n      try {\n        const decoded: Event = erc20Coder.decodeEvent(topics, data);\n\n        parsedEvents.push({\n          name: decoded.name,\n          values: decoded.values,\n        });\n      } catch (err) {\n        unknownEvents.push({\n          topics,\n          data,\n        });\n      }\n    });\n\n  return {\n    parsedEvents,\n    unknownEvents,\n  };\n};\n","import { EvmSendArguments } from '@unique-nft/common/types/evm';\nimport {\n  createMutationByInstance,\n  MutationAbstract,\n} from '../../../common/mutation';\nimport {\n  EvmSendResultParsed,\n  IEvm,\n  Method,\n  MutationOptions,\n} from '../../../types';\nimport { parseEvmEvents } from '../utils';\n\nclass EvmSendMutation extends MutationAbstract<\n  EvmSendArguments,\n  EvmSendResultParsed\n> {\n  constructor(private readonly evm: IEvm) {\n    super(evm.client, Method.POST, 'evm/send', {\n      section: 'evm',\n      method: 'call',\n    });\n  }\n\n  public override async submitWaitResult(args, options: MutationOptions) {\n    const result = await super.submitWaitResult(args, options);\n\n    if ('abi' in args) {\n      if (result.parsed.isExecutedFailed) {\n        await this.evm.call(args);\n      }\n\n      const { parsedEvents, unknownEvents } = parseEvmEvents(\n        result.events,\n        args.abi,\n      );\n\n      result.parsed.parsedEvents = parsedEvents;\n      result.parsed.unknownEvents = unknownEvents;\n    }\n\n    return result;\n  }\n}\nexport function createEvmSendMutation(evm: IEvm) {\n  const mutation = new EvmSendMutation(evm);\n  return createMutationByInstance(mutation);\n}\n","import {\n  createMutationByInstance,\n  MethodNameNull,\n  MutationAbstract,\n} from '../../../common/mutation';\nimport {\n  ContractSendArguments,\n  EvmSendArgumentsDto,\n  EvmSendResultParsed,\n  IContract,\n  Method,\n  MutationOptions,\n} from '../../../types';\nimport { parseEvmEvents } from '../utils';\n\nclass ContractSendMutation extends MutationAbstract<\n  EvmSendArgumentsDto,\n  EvmSendResultParsed\n> {\n  constructor(private readonly contract: IContract) {\n    super(contract.client, Method.POST, 'evm/send', MethodNameNull);\n  }\n\n  public override async build(args: ContractSendArguments) {\n    return super.build({\n      contractAddress: this.contract.contractAddress,\n      abi: this.contract.abi,\n      ...args,\n    });\n  }\n\n  public override async submitWaitResult(args, options: MutationOptions) {\n    const result = await super.submitWaitResult(args, options);\n\n    if (result.parsed.isExecutedFailed) {\n      await this.contract.call(args);\n    }\n\n    const { parsedEvents, unknownEvents } = parseEvmEvents(\n      result.events,\n      this.contract.abi,\n    );\n\n    result.parsed.parsedEvents = parsedEvents;\n    result.parsed.unknownEvents = unknownEvents;\n\n    return result;\n  }\n}\n\nexport function createContractSendMutation(contract: IContract) {\n  const mutation = new ContractSendMutation(contract);\n  return createMutationByInstance(mutation);\n}\n","import { Section } from '../../common';\nimport {\n  AbiItemDto,\n  ContractCallArguments,\n  ContractSendArguments,\n  EvmCallResponseDto,\n  EvmSendResultParsed,\n  IBaseClient,\n  IContract,\n  IMutationEx,\n  Method,\n} from '../../types';\nimport { createContractSendMutation } from './mutation';\n\nexport class Contract extends Section implements IContract {\n  readonly send: IMutationEx<ContractSendArguments, EvmSendResultParsed>;\n\n  constructor(\n    client: IBaseClient,\n    readonly contractAddress: string,\n    readonly abi: AbiItemDto[],\n  ) {\n    super(client, 'evm');\n\n    this.send = createContractSendMutation(this);\n  }\n\n  public async call(args: ContractCallArguments): Promise<EvmCallResponseDto> {\n    const response = await this.client.instance({\n      method: Method.POST,\n      baseURL: this.baseUrl,\n      url: 'call',\n      data: {\n        contractAddress: this.contractAddress,\n        abi: this.abi,\n        ...args,\n      },\n    });\n    return response.data;\n  }\n}\n","import {\n  EvmCallArguments,\n  EvmContractExistsArguments,\n  EvmContractExistsResponse,\n} from '@unique-nft/common/types/evm';\nimport { Section } from '../../common';\nimport { IEvm, AbiItemDto } from '../../types';\nimport { Contract } from './contract';\nimport { createEvmSendMutation } from './mutation';\n\nexport class Evm extends Section implements IEvm {\n  readonly send = createEvmSendMutation(this);\n\n  readonly contractExists = (\n    args: EvmContractExistsArguments,\n  ): Promise<EvmContractExistsResponse> => this.query('contract-exists', args);\n\n  call<R = any>(args: EvmCallArguments): Promise<R> {\n    return this.postRequest('call', args);\n  }\n\n  public async contractConnect(\n    contractAddress: string,\n    abi: AbiItemDto[],\n  ): Promise<Contract> {\n    const { exists } = await this.contractExists({ contractAddress });\n    if (!exists) {\n      throw new Error('Contract is not exists');\n    }\n    return new Contract(this.client, contractAddress, abi);\n  }\n}\n","import { IBaseClient, IEvm, Options } from '../../types';\nimport { BaseClient } from '../../common/base-client';\nimport { Evm } from './evm';\n\nexport class EvmClient extends BaseClient implements IEvm {\n  client: IBaseClient;\n\n  send: IEvm['send'];\n\n  contractExists: IEvm['contractExists'];\n\n  call: IEvm['call'];\n\n  contractConnect: IEvm['contractConnect'];\n\n  constructor(options: Options) {\n    super(options);\n\n    const evm = new Evm(this, 'evm');\n\n    this.send = evm.send;\n    this.contractExists = evm.contractExists;\n    this.call = evm.call;\n    this.contractConnect = evm.contractConnect;\n  }\n}\n","type ChainConfig = {\n  websocketUrl: string;\n  rpcUrl: string;\n  restUrl: string;\n  ss58Prefix: number;\n  currency: {\n    symbol: string;\n    decimals: number;\n  };\n  logo: {\n    color: `#${string}`;\n    ipfsCid: string;\n  };\n};\n\nexport enum Chains {\n  opal = 'opal',\n  sapphire = 'sapphire',\n  quartz = 'quartz',\n  unique = 'unique',\n}\n\nexport const CHAIN_CONFIG: Record<`${Chains}`, ChainConfig> = {\n  opal: {\n    websocketUrl: 'wss://ws-opal.unique.network',\n    rpcUrl: 'https://rpc-opal.unique.network',\n    restUrl: 'https://rest.unique.network/opal/v1',\n    ss58Prefix: 42,\n    currency: {\n      symbol: 'OPL',\n      decimals: 18,\n    },\n    logo: {\n      color: '#0CB6B8',\n      ipfsCid: 'QmYJDpmWyjDa3H6BxweFmQXk4fU8b1GU7M9EqYcaUNvXzc',\n    },\n  },\n  sapphire: {\n    websocketUrl: 'wss://ws-sapphire.unique.network',\n    ss58Prefix: 8883,\n    rpcUrl: 'https://rpc-sapphire.unique.network',\n    restUrl: 'https://rest.unique.network/sapphire/v1',\n    currency: {\n      symbol: 'QTZ',\n      decimals: 18,\n    },\n    logo: {\n      color: '#5D59FF',\n      ipfsCid: 'Qmd1PGt4cDRjFbh4ihP5QKEd4XQVwN1MkebYKdF56V74pf',\n    },\n  },\n  quartz: {\n    websocketUrl: 'wss://ws-quartz.unique.network',\n    ss58Prefix: 255,\n    rpcUrl: 'https://rpc-quartz.unique.network',\n    restUrl: 'https://rest.unique.network/quartz/v1',\n    currency: {\n      symbol: 'QTZ',\n      decimals: 18,\n    },\n    logo: {\n      color: '#FF4D6A',\n      ipfsCid: 'QmaGPdccULQEFcCGxzstnmE8THfac2kSiGwvWRAiaRq4dp',\n    },\n  },\n  unique: {\n    websocketUrl: 'wss://ws.unique.network',\n    ss58Prefix: 7391,\n    rpcUrl: 'https://rpc.unique.network',\n    restUrl: 'https://rest.unique.network/unique/v1',\n    currency: {\n      symbol: 'UNQ',\n      decimals: 18,\n    },\n    logo: {\n      color: '#00BFFF',\n      ipfsCid: 'QmbJ7CGZ2GxWMp7s6jy71UGzRsMe4w3KANKXDAExYWdaFR',\n    },\n  },\n};\n","import { EvmClient } from './sections/evm/evm-client';\n\nexport { EvmClient } from './sections/evm/evm-client';\n\nexport * from './types';\n\nexport default EvmClient;\n\nexport * from './common/constants';\n"],"mappings":"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","names":["Axios","ApiError","Error","constructor","responseError","message","code","details","name","MaxStatusRequestsError","Error","constructor","txHash","limit","message","details","TimeoutError","Error","constructor","txHash","timeoutMs","message","details","Method","Rooms","SubscriptionEvents","BalanceMethods","Section","constructor","client","path","baseUrl","options","query","url","params","response","instance","method","Method","GET","baseURL","data","postRequest","POST","isUnsignedTxPayloadResponse","args","isSubmitTxBody","sleep","ms","Promise","resolve","setTimeout","getAddress","options","args","address","signer","account","undefined","addAddress","Error","getSigner","options","accountOrSigner","signer","account","undefined","getAddress","args","address","Extrinsic","Section","build","client","Error","response","instance","method","Method","POST","baseURL","baseUrl","url","data","getFee","sign","signerToUse","submit","submitWatch","txBuild","extrinsic","signedTxPayload","submitTxResult","signerPayloadJSON","signature","submitWaitResult","hash","waitResult","timeout","statusTotalTimeoutInMs","maxRequests","maximumNumberOfStatusRequests","waitTime","waitBetweenStatusRequestsInMs","isTimeExceeded","setTimeout","requestCount","checkStatusResult","status","isCompleted","error","sleep","TimeoutError","MaxStatusRequestsError","GET","params","get","BaseClient","constructor","options","instance","extrinsic","checkOptions","Axios","create","baseURL","baseUrl","maxContentLength","Infinity","maxBodyLength","axiosConfig","interceptors","response","use","exception","err","data","error","ApiError","version","defaults","headers","common","Extrinsic","Error","replace","statusTotalTimeoutInMs","maximumNumberOfStatusRequests","Number","MAX_SAFE_INTEGER","waitBetweenStatusRequestsInMs","MutationAbstract","constructor","client","method","path","methodName","url","options","baseUrl","buildBatch","args","data","map","a","addAddress","response","instance","params","use","build","getFee","sign","unsigned","isUnsignedTxPayloadResponse","signerPayloadJSON","signature","extrinsic","signer","submit","submitTxArguments","isSubmitTxBody","submitWatch","submitWaitResult","hash","waitResult","batchCall","Error","rawPayload","createMutationByInstance","mutation","submitWaitResult","args","options","build","bind","buildBatch","getFee","sign","submit","submitWatch","batchCall","MethodNameNull","Coder","parseEvmEvents","events","abi","erc20Coder","Coder","parsedEvents","unknownEvents","filter","event","section","method","forEach","logData","data","topics","decoded","decodeEvent","push","name","values","err","EvmSendMutation","MutationAbstract","constructor","evm","client","Method","POST","section","method","submitWaitResult","args","options","result","parsed","isExecutedFailed","call","parsedEvents","unknownEvents","parseEvmEvents","events","abi","createEvmSendMutation","mutation","createMutationByInstance","ContractSendMutation","MutationAbstract","constructor","contract","client","Method","POST","MethodNameNull","build","args","contractAddress","abi","submitWaitResult","options","result","parsed","isExecutedFailed","call","parsedEvents","unknownEvents","parseEvmEvents","events","createContractSendMutation","mutation","createMutationByInstance","Contract","Section","constructor","client","contractAddress","abi","send","createContractSendMutation","call","args","response","instance","method","Method","POST","baseURL","baseUrl","url","data","Evm","Section","send","createEvmSendMutation","contractExists","args","query","call","postRequest","contractConnect","contractAddress","abi","exists","Error","Contract","client","EvmClient","BaseClient","constructor","options","client","send","contractExists","call","contractConnect","evm","Evm","Chains","CHAIN_CONFIG","opal","websocketUrl","rpcUrl","restUrl","ss58Prefix","currency","symbol","decimals","logo","color","ipfsCid","sapphire","quartz","unique","EvmClient"]}