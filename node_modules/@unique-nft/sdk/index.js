var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// packages/sdk/src/common/base-client.ts
import Axios from "axios";

// packages/sdk/src/errors/api-error.ts
var ApiError = class extends Error {
  constructor(responseError) {
    super(responseError.message);
    __publicField(this, "code");
    __publicField(this, "details");
    this.code = responseError.code;
    this.name = responseError.name;
    this.details = responseError.details;
  }
};
__name(ApiError, "ApiError");

// packages/sdk/src/errors/max-status-requests-error.ts
var MaxStatusRequestsError = class extends Error {
  constructor(txHash, limit) {
    const message = `Extrinsic status was not changed within the specified count of status requests (${limit}).`;
    super(message);
    __publicField(this, "details");
    __publicField(this, "txHash");
    __publicField(this, "limit");
    this.details = `${message} This does not mean that the Extrinsic has failed nor that it will be included in the future. You can check the status of the Extrinsic by calling the getStatus() method.`;
    this.txHash = txHash;
    this.limit = limit;
  }
};
__name(MaxStatusRequestsError, "MaxStatusRequestsError");

// packages/sdk/src/errors/timeout-error.ts
var TimeoutError = class extends Error {
  constructor(txHash, timeoutMs) {
    const message = `Extrinsic status was not changed within the specified time (${timeoutMs} ms).`;
    super(message);
    __publicField(this, "details");
    __publicField(this, "txHash");
    __publicField(this, "timeoutMs");
    this.details = `${message} This does not mean that the Extrinsic has failed nor that it will be included in the future. You can check the status of the Extrinsic by calling the getStatus() method.`;
    this.txHash = txHash;
    this.timeoutMs = timeoutMs;
  }
};
__name(TimeoutError, "TimeoutError");

// packages/sdk/src/types/enums.ts
var Method;
(function(Method2) {
  Method2["GET"] = "GET";
  Method2["POST"] = "POST";
  Method2["DELETE"] = "DELETE";
  Method2["PATCH"] = "PATCH";
  Method2["PUT"] = "PUT";
})(Method || (Method = {}));

// packages/common/types/subscriptions.ts
var Rooms;
(function(Rooms2) {
  Rooms2["SYSTEM"] = "system";
  Rooms2["BLOCKS"] = "blocks";
  Rooms2["EXTRINSICS"] = "extrinsics";
  Rooms2["COLLECTION"] = "collection";
  Rooms2["CONTRACT"] = "contract";
  Rooms2["EVENTS"] = "events";
  Rooms2["BALANCE"] = "balance";
  Rooms2["ACCOUNT_CURRENT_BALANCE"] = "account-current-balance";
})(Rooms || (Rooms = {}));
var SubscriptionEvents;
(function(SubscriptionEvents2) {
  SubscriptionEvents2["SYSTEM"] = "system";
  SubscriptionEvents2["BLOCKS"] = "blocks";
  SubscriptionEvents2["EXTRINSICS"] = "extrinsics";
  SubscriptionEvents2["EVENTS"] = "events";
  SubscriptionEvents2["CONTRACT_LOGS"] = "contract-logs";
  SubscriptionEvents2["COLLECTIONS"] = "collections";
  SubscriptionEvents2["HAS_NEXT"] = "has-next";
  SubscriptionEvents2["BALANCES"] = "balances";
  SubscriptionEvents2["ACCOUNT_CURRENT_BALANCE"] = "account-current-balance";
  SubscriptionEvents2["SUBSCRIBE_STATE"] = "subscribe-state";
})(SubscriptionEvents || (SubscriptionEvents = {}));
var BalanceMethods;
(function(BalanceMethods2) {
  BalanceMethods2["WITHDRAW"] = "Withdraw";
  BalanceMethods2["TRANSFER"] = "Transfer";
  BalanceMethods2["DEPOSIT"] = "Deposit";
  BalanceMethods2["DUST_LOST"] = "DustLost";
  BalanceMethods2["ENDOWED"] = "Endowed";
  BalanceMethods2["LOCKED"] = "Locked";
  BalanceMethods2["UNLOCKED"] = "Unlocked";
  BalanceMethods2["RESERVED"] = "Reserved";
})(BalanceMethods || (BalanceMethods = {}));

// packages/sdk/src/common/section.ts
var Section = class {
  constructor(client, path) {
    __publicField(this, "client");
    __publicField(this, "path");
    __publicField(this, "baseUrl");
    this.client = client;
    this.path = path;
    this.baseUrl = `${this.client.options.baseUrl}/${path}`;
  }
  async query(url, params) {
    const response = await this.client.instance({
      method: Method.GET,
      baseURL: this.baseUrl,
      url,
      params
    });
    return response.data;
  }
  async postRequest(url, data, params) {
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url,
      data,
      params
    });
    return response.data;
  }
};
__name(Section, "Section");

// packages/sdk/src/common/utils.ts
var isUnsignedTxPayloadResponse = /* @__PURE__ */ __name((args) => typeof args === "object" && !!args && "signerPayloadJSON" in args, "isUnsignedTxPayloadResponse");
var isSubmitTxBody = /* @__PURE__ */ __name((args) => isUnsignedTxPayloadResponse(args) && !!args && "signature" in args, "isSubmitTxBody");
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
__name(sleep, "sleep");
var getAddress = /* @__PURE__ */ __name((options, args) => {
  if (args.address)
    return args.address;
  if (options.signer?.address)
    return options.signer.address;
  if (options.account?.address)
    return options.account.address;
  if (options.account?.signer?.address)
    return options.account.signer.address;
  return void 0;
}, "getAddress");
var addAddress = /* @__PURE__ */ __name((options, args) => {
  const address = getAddress(options, args);
  if (!address)
    throw new Error("No address provided");
  return {
    ...args,
    address
  };
}, "addAddress");

// packages/sdk/src/sections/extrinsic.ts
var getSigner = /* @__PURE__ */ __name((options, accountOrSigner) => {
  if (accountOrSigner) {
    return "sign" in accountOrSigner ? accountOrSigner : accountOrSigner.signer;
  }
  if (options.signer)
    return options.signer;
  if (options.account?.signer)
    return options.account.signer;
  return void 0;
}, "getSigner");
var getAddress2 = /* @__PURE__ */ __name((options, args) => {
  if (args.address)
    return args.address;
  if (options.signer?.address)
    return options.signer.address;
  if (options.account?.address)
    return options.account.address;
  if (options.account?.signer?.address)
    return options.account.signer.address;
  return void 0;
}, "getAddress");
var Extrinsic = class extends Section {
  async build(args) {
    const address = getAddress2(this.client.options, args);
    if (!address)
      throw new Error("Invalid address");
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url: "build",
      data: {
        ...args,
        address
      }
    });
    return response.data;
  }
  async getFee(args) {
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url: "calculate-fee",
      data: args
    });
    return response.data;
  }
  async sign(args, signer) {
    const signerToUse = getSigner(this.client.options, signer);
    if (!signerToUse)
      throw new Error(`No signer provided`);
    return signerToUse.sign(args);
  }
  async submit(args) {
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url: "submit",
      data: args
    });
    return response.data;
  }
  async submitWatch(args, signer = this.client.options.signer) {
    const txBuild = await this.client.extrinsic.build(args);
    const signedTxPayload = await this.client.extrinsic.sign(txBuild, signer);
    const submitTxResult = await this.client.extrinsic.submit({
      signerPayloadJSON: txBuild.signerPayloadJSON,
      signature: signedTxPayload.signature
    });
    return submitTxResult;
  }
  async submitWaitResult(args, signer = this.client.options.signer) {
    const { hash } = await this.client.extrinsic.submitWatch(args, signer);
    return this.client.extrinsic.waitResult({
      hash
    });
  }
  async waitResult({ hash }) {
    const timeout = this.client.options.statusTotalTimeoutInMs;
    const maxRequests = this.client.options.maximumNumberOfStatusRequests;
    const waitTime = this.client.options.waitBetweenStatusRequestsInMs;
    let isTimeExceeded = false;
    setTimeout(() => {
      isTimeExceeded = true;
    }, timeout);
    let requestCount = 0;
    do {
      const checkStatusResult = await this.client.extrinsic.status({
        hash
      });
      if (checkStatusResult.isCompleted || checkStatusResult.error) {
        return checkStatusResult;
      }
      await sleep(waitTime);
      requestCount += 1;
    } while (!isTimeExceeded && requestCount < maxRequests);
    if (isTimeExceeded)
      throw new TimeoutError(hash, timeout);
    throw new MaxStatusRequestsError(hash, maxRequests);
  }
  async status(args) {
    const response = await this.client.instance({
      method: Method.GET,
      baseURL: this.baseUrl,
      url: "status",
      params: args
    });
    return response.data;
  }
  async get(args) {
    const response = await this.client.instance({
      method: Method.GET,
      baseURL: this.baseUrl,
      url: "",
      params: args
    });
    return response.data;
  }
};
__name(Extrinsic, "Extrinsic");

// packages/sdk/package.json
var version = "0.7.7";

// packages/sdk/src/common/base-client.ts
var BaseClient = class {
  constructor(options) {
    __publicField(this, "instance");
    __publicField(this, "options");
    __publicField(this, "extrinsic");
    this.options = options;
    this.checkOptions();
    this.instance = Axios.create({
      baseURL: `${this.options.baseUrl}`,
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      ...options.axiosConfig
    });
    this.instance.interceptors.response.use((response) => response, (exception) => {
      const err = exception.response?.data?.error;
      throw err && typeof err === "object" ? new ApiError(err) : exception;
    });
    if (version) {
      this.instance.defaults.headers.common["X-SDK-Version"] = version;
    }
    this.extrinsic = new Extrinsic(this, "extrinsic");
  }
  checkOptions() {
    const { baseUrl } = this.options;
    if (!this.options.baseUrl) {
      throw new Error(`'baseUrl' option is required`);
    }
    this.options.baseUrl = baseUrl.replace(/\/$/, "");
    if (!this.options.statusTotalTimeoutInMs) {
      this.options.statusTotalTimeoutInMs = 3 * 60 * 1e3;
    }
    if (!this.options.maximumNumberOfStatusRequests) {
      this.options.maximumNumberOfStatusRequests = Number.MAX_SAFE_INTEGER;
    }
    if (!this.options.waitBetweenStatusRequestsInMs) {
      this.options.waitBetweenStatusRequestsInMs = 5e3;
    }
  }
};
__name(BaseClient, "BaseClient");

// packages/sdk/src/common/mutation.ts
var MutationAbstract = class {
  constructor(client, method, path, methodName) {
    __publicField(this, "client");
    __publicField(this, "method");
    __publicField(this, "path");
    __publicField(this, "methodName");
    __publicField(this, "url");
    this.client = client;
    this.method = method;
    this.path = path;
    this.methodName = methodName;
    this.url = `${this.client.options.baseUrl}/${this.path}`;
  }
  async buildBatch(args, options) {
    const data = args.map((a) => addAddress(this.client.options, a));
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "BuildBatch"
      },
      data
    });
    return response.data;
  }
  async build(args, options) {
    const data = addAddress(this.client.options, args);
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "Build"
      },
      data
    });
    return response.data;
  }
  async getFee(args) {
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        use: "GetFee"
      },
      data: args
    });
    return response?.data;
  }
  async sign(args, options) {
    const unsigned = isUnsignedTxPayloadResponse(args) ? args : await this.build(args, options);
    const { signerPayloadJSON } = unsigned;
    const { signature } = await this.client.extrinsic.sign(unsigned, options?.signer);
    return {
      signature,
      signerPayloadJSON
    };
  }
  async submit(args, options) {
    const submitTxArguments = isSubmitTxBody(args) ? args : await this.sign(args, options);
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "Submit"
      },
      data: submitTxArguments
    });
    return response.data;
  }
  async submitWatch(args, options) {
    const submitTxArguments = isSubmitTxBody(args) ? args : await this.sign(args, options);
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "SubmitWatch"
      },
      data: submitTxArguments
    });
    return response.data;
  }
  async submitWaitResult(args, options) {
    const { hash } = await this.submitWatch(args, options);
    return this.client.extrinsic.waitResult({
      hash
    });
  }
  batchCall(args) {
    if (!this.methodName) {
      throw new Error(`Batching not defined in method: ${this.path}`);
    }
    return {
      method: this.methodName,
      rawPayload: args
    };
  }
};
__name(MutationAbstract, "MutationAbstract");
var Mutation = /* @__PURE__ */ __name(class Mutation2 extends MutationAbstract {
}, "Mutation");
function createMutationByInstance(mutation) {
  const submitWaitResult = /* @__PURE__ */ __name((args, options) => mutation.submitWaitResult(args, options), "submitWaitResult");
  submitWaitResult.build = mutation.build.bind(mutation);
  submitWaitResult.buildBatch = mutation.buildBatch.bind(mutation);
  submitWaitResult.getFee = mutation.getFee.bind(mutation);
  submitWaitResult.sign = mutation.sign.bind(mutation);
  submitWaitResult.submit = mutation.submit.bind(mutation);
  submitWaitResult.submitWatch = mutation.submitWatch.bind(mutation);
  submitWaitResult.submitWaitResult = mutation.submitWaitResult.bind(mutation);
  submitWaitResult.batchCall = mutation.batchCall.bind(mutation);
  return submitWaitResult;
}
__name(createMutationByInstance, "createMutationByInstance");
var MethodNameNull = null;
function createMutationEx(client, method, path, methodName) {
  const mutation = new Mutation(client, method, path, methodName);
  return createMutationByInstance(mutation);
}
__name(createMutationEx, "createMutationEx");

// packages/sdk/src/sections/balance.ts
var Balance = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "transfer", createMutationEx(this.client, Method.POST, `${this.path}/transfer`, {
      section: "balances",
      method: "transferKeepAlive"
    }));
    __publicField(this, "get", /* @__PURE__ */ __name((args) => this.query("", args), "get"));
  }
};
__name(Balance, "Balance");

// packages/sdk/src/sections/collection.ts
var Collection = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "setProperties", createMutationEx(this.client, Method.POST, `${this.path}/properties`, {
      section: "unique",
      method: "setCollectionProperties"
    }));
    __publicField(this, "deleteProperties", createMutationEx(this.client, Method.DELETE, `${this.path}/properties`, {
      section: "unique",
      method: "deleteCollectionProperties"
    }));
    __publicField(this, "setPropertyPermissions", createMutationEx(this.client, Method.POST, `${this.path}/property-permissions`, {
      section: "unique",
      method: "setTokenPropertyPermissions"
    }));
    __publicField(this, "properties", /* @__PURE__ */ __name((args) => this.query("properties", args), "properties"));
    __publicField(this, "tokens", /* @__PURE__ */ __name((args) => this.query("tokens", args), "tokens"));
    __publicField(this, "propertyPermissions", /* @__PURE__ */ __name((args) => this.query("property-permissions", args), "propertyPermissions"));
    /**
    * @deprecated Use create method
    */
    __publicField(this, "creation", createMutationEx(this.client, Method.POST, this.path, {
      section: "unique",
      method: "createCollectionEx"
    }));
    __publicField(this, "create", createMutationEx(this.client, Method.POST, this.path, {
      section: "unique",
      method: "createCollectionEx"
    }));
    __publicField(this, "createV2", createMutationEx(this.client, Method.POST, `${this.path}/v2`, {
      section: "unique",
      method: "createCollectionEx"
    }));
    __publicField(this, "getLimits", /* @__PURE__ */ __name((args) => this.query("limits", args), "getLimits"));
    __publicField(this, "setLimits", createMutationEx(this.client, Method.POST, `${this.path}/set-limits`, {
      section: "unique",
      method: "setCollectionLimits"
    }));
    __publicField(this, "get", /* @__PURE__ */ __name((args) => this.query("", args), "get"));
    __publicField(this, "getV2", /* @__PURE__ */ __name((args) => this.query("v2", args), "getV2"));
    __publicField(this, "transfer", createMutationEx(this.client, Method.PATCH, `${this.path}/transfer`, {
      section: "unique",
      method: "changeCollectionOwner"
    }));
    __publicField(this, "destroy", createMutationEx(this.client, Method.DELETE, this.path, {
      section: "unique",
      method: "destroyCollection"
    }));
    __publicField(this, "stats", /* @__PURE__ */ __name(() => this.query("stats"), "stats"));
    __publicField(this, "setTransfersEnabled", createMutationEx(this.client, Method.POST, `${this.path}/transfers-enabled`, {
      section: "unique",
      method: "setTransfersEnabledFlag"
    }));
    __publicField(this, "setPermissions", createMutationEx(this.client, Method.POST, `${this.path}/permissions`, {
      section: "unique",
      method: "setCollectionPermissions"
    }));
    __publicField(this, "nextSponsored", /* @__PURE__ */ __name((args) => this.query("next-sponsored", args), "nextSponsored"));
    __publicField(this, "lastTokenId", /* @__PURE__ */ __name((args) => this.query("last-token-id", args), "lastTokenId"));
    __publicField(this, "allowList", /* @__PURE__ */ __name((args) => this.query("allow-list", args), "allowList"));
    __publicField(this, "allowed", /* @__PURE__ */ __name((args) => this.query("allowed", args), "allowed"));
    __publicField(this, "addToAllowList", createMutationEx(this.client, Method.POST, `${this.path}/add-to-allow-list`, {
      section: "unique",
      method: "addToAllowList"
    }));
    __publicField(this, "removeFromAllowList", createMutationEx(this.client, Method.POST, `${this.path}/remove-from-allow-list`, {
      section: "unique",
      method: "removeFromAllowList"
    }));
    __publicField(this, "admins", /* @__PURE__ */ __name((args) => this.query("admins", args), "admins"));
    __publicField(this, "addAdmin", createMutationEx(this.client, Method.POST, `${this.path}/admins`, {
      section: "unique",
      method: "addCollectionAdmin"
    }));
    __publicField(this, "removeAdmin", createMutationEx(this.client, Method.DELETE, `${this.path}/admins`, {
      section: "unique",
      method: "removeCollectionAdmin"
    }));
    __publicField(this, "setSponsorship", createMutationEx(this.client, Method.POST, `${this.path}/sponsorship`, {
      section: "unique",
      method: "setCollectionSponsor"
    }));
    __publicField(this, "confirmSponsorship", createMutationEx(this.client, Method.POST, `${this.path}/sponsorship/confirm`, {
      section: "unique",
      method: "confirmSponsorship"
    }));
    __publicField(this, "removeSponsorship", createMutationEx(this.client, Method.DELETE, `${this.path}/sponsorship`, {
      section: "unique",
      method: "removeCollectionSponsor"
    }));
    __publicField(this, "totalSupply", /* @__PURE__ */ __name((args) => this.query("total-supply", args), "totalSupply"));
  }
};
__name(Collection, "Collection");

// packages/sdk/src/sections/erc721.ts
var ERC721 = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "createCollection", createMutationEx(this.client, Method.POST, `${this.path}/collection`, MethodNameNull));
    __publicField(this, "createToken", createMutationEx(this.client, Method.POST, `${this.path}/token`, MethodNameNull));
  }
};
__name(ERC721, "ERC721");

// packages/sdk/src/sections/fungible.ts
var Fungible = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "transfer", createMutationEx(this.client, Method.POST, `${this.path}/transfer`, MethodNameNull));
    __publicField(this, "getCollection", /* @__PURE__ */ __name((args) => this.query("collection", args), "getCollection"));
    __publicField(this, "burn", createMutationEx(this.client, Method.DELETE, this.path, MethodNameNull));
    __publicField(this, "createCollection", createMutationEx(this.client, Method.POST, `${this.path}/collection`, MethodNameNull));
    __publicField(this, "getBalance", /* @__PURE__ */ __name((args) => this.query("balance", args), "getBalance"));
    __publicField(this, "addTokens", createMutationEx(this.client, Method.POST, `${this.path}/tokens`, MethodNameNull));
    __publicField(this, "transferTokens", createMutationEx(this.client, Method.POST, `${this.path}/tokens/transfer`, MethodNameNull));
    __publicField(this, "approveTokens", createMutationEx(this.client, Method.POST, `${this.path}/tokens/approve`, MethodNameNull));
    __publicField(this, "allowanceTokens", /* @__PURE__ */ __name((args) => this.query("tokens/allowance", args), "allowanceTokens"));
    __publicField(this, "totalPieces", /* @__PURE__ */ __name((args) => this.query("total-pieces", args), "totalPieces"));
  }
};
__name(Fungible, "Fungible");

// packages/sdk/src/sections/refungible.ts
var Refungible = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "getCollection", /* @__PURE__ */ __name((args) => this.query("collection", args), "getCollection"));
    __publicField(this, "burn", createMutationEx(this.client, Method.DELETE, this.path, MethodNameNull));
    __publicField(this, "getBalance", /* @__PURE__ */ __name((args) => this.query("tokens/balance", args), "getBalance"));
    __publicField(this, "createCollection", createMutationEx(this.client, Method.POST, `${this.path}/collection`, MethodNameNull));
    __publicField(this, "createToken", createMutationEx(this.client, Method.POST, `${this.path}/tokens`, MethodNameNull));
    __publicField(this, "transferToken", createMutationEx(this.client, Method.POST, `${this.path}/tokens/transfer`, MethodNameNull));
    __publicField(this, "approveToken", createMutationEx(this.client, Method.POST, `${this.path}/tokens/approve`, MethodNameNull));
    __publicField(this, "allowanceToken", /* @__PURE__ */ __name((args) => this.query("tokens/allowance", args), "allowanceToken"));
    __publicField(this, "repartitionToken", createMutationEx(this.client, Method.POST, `${this.path}/tokens/repartition`, MethodNameNull));
    __publicField(this, "totalPieces", /* @__PURE__ */ __name((args) => this.query("tokens/total-pieces", args), "totalPieces"));
    __publicField(this, "accountTokens", /* @__PURE__ */ __name((args) => this.query("tokens/account-tokens", args), "accountTokens"));
  }
};
__name(Refungible, "Refungible");

// packages/sdk/src/sections/ipfs.ts
import FormData from "form-data";
var isFileLike = /* @__PURE__ */ __name((input) => Object.hasOwnProperty.call(input, "content"), "isFileLike");
var Ipfs = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "headers", {
      "Content-Type": `multipart/form-data`
    });
  }
  async uploadFile({ file }) {
    const data = new FormData();
    data.append("file", file, "file");
    const response = await this.client.instance({
      method: Method.POST,
      url: `${this.baseUrl}/upload-file`,
      data,
      headers: this.headers
    });
    return response.data;
  }
  async uploadFiles({ files }) {
    const data = Ipfs.filesToFormData(files);
    const response = await this.client.instance({
      method: Method.POST,
      url: `${this.baseUrl}/upload-files`,
      data,
      headers: this.headers
    });
    return response.data;
  }
  async addFiles({ cid, files }) {
    const data = Ipfs.filesToFormData(files);
    data.append("cid", cid);
    const response = await this.client.instance({
      method: Method.PATCH,
      url: `${this.baseUrl}/add-files`,
      data,
      headers: this.headers
    });
    return response.data;
  }
  async uploadZip({ file }) {
    const form = new FormData();
    form.append("file", file, "file");
    const response = await this.client.instance({
      method: Method.POST,
      url: `${this.baseUrl}/upload-zip`,
      data: form,
      headers: {
        "Content-Type": `multipart/form-data`
      }
    });
    return response.data;
  }
  static filesToFormData(files) {
    const formData = new FormData();
    files.forEach((file) => {
      formData.append("files", isFileLike(file) ? file.content : file, file.name);
    });
    return formData;
  }
};
__name(Ipfs, "Ipfs");

// packages/sdk/src/sections/token.ts
var Token = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "setProperties", createMutationEx(this.client, Method.POST, `${this.path}/properties`, {
      section: "unique",
      method: "setTokenProperties"
    }));
    __publicField(this, "deleteProperties", createMutationEx(this.client, Method.DELETE, `${this.path}/properties`, {
      section: "unique",
      method: "deleteTokenProperties"
    }));
    __publicField(this, "properties", /* @__PURE__ */ __name((args) => this.query("properties", args), "properties"));
    __publicField(this, "create", createMutationEx(this.client, Method.POST, this.path, {
      section: "unique",
      method: "createItem"
    }));
    __publicField(this, "createV2", createMutationEx(this.client, Method.POST, `${this.path}/v2`, {
      section: "unique",
      method: "createItem"
    }));
    __publicField(this, "createMultiple", createMutationEx(this.client, Method.POST, `${this.path}/create-multiple`, {
      section: "unique",
      method: "createMultipleItemsEx"
    }));
    __publicField(this, "createMultipleV2", createMutationEx(this.client, Method.POST, `${this.path}/create-multiple-v2`, {
      section: "unique",
      method: "createMultipleItemsEx"
    }));
    __publicField(this, "accountTokens", /* @__PURE__ */ __name((args) => this.query("account-tokens", args), "accountTokens"));
    __publicField(this, "get", /* @__PURE__ */ __name((args) => this.query("", args), "get"));
    __publicField(this, "getV2", /* @__PURE__ */ __name((args) => this.query("v2", args), "getV2"));
    __publicField(this, "exists", /* @__PURE__ */ __name((args) => this.query("exists", args), "exists"));
    __publicField(this, "children", /* @__PURE__ */ __name((args) => this.query("children", args), "children"));
    __publicField(this, "parent", /* @__PURE__ */ __name((args) => this.query("parent", args), "parent"));
    __publicField(this, "owner", /* @__PURE__ */ __name((args) => this.query("owner", args), "owner"));
    __publicField(this, "topmostOwner", /* @__PURE__ */ __name((args) => this.query("topmost-owner", args), "topmostOwner"));
    __publicField(this, "nest", createMutationEx(this.client, Method.POST, `${this.path}/nest`, MethodNameNull));
    __publicField(this, "unnest", createMutationEx(this.client, Method.POST, `${this.path}/unnest`, MethodNameNull));
    __publicField(this, "burn", createMutationEx(this.client, Method.DELETE, this.path, {
      section: "unique",
      method: "burnFrom"
    }));
    __publicField(this, "transfer", createMutationEx(this.client, Method.PATCH, `${this.path}/transfer`, {
      section: "unique",
      method: "transferFrom"
    }));
    __publicField(this, "approve", createMutationEx(this.client, Method.POST, `${this.path}/approve`, {
      section: "unique",
      method: "approve"
    }));
    __publicField(this, "allowance", /* @__PURE__ */ __name((args) => this.query("allowance", args), "allowance"));
    __publicField(this, "isBundle", /* @__PURE__ */ __name((args) => this.query("is-bundle", args), "isBundle"));
    __publicField(this, "getBundle", /* @__PURE__ */ __name((args) => this.query("get-bundle", args), "getBundle"));
    __publicField(this, "balance", /* @__PURE__ */ __name((args) => this.query("balance", args), "balance"));
  }
};
__name(Token, "Token");

// packages/sdk/src/sections/common.ts
var Common = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "chainProperties", /* @__PURE__ */ __name(() => this.query("chain-properties"), "chainProperties"));
    __publicField(this, "getNonce", /* @__PURE__ */ __name((args) => this.query("nonce", args), "getNonce"));
    __publicField(this, "batch", createMutationEx(this.client, Method.POST, `${this.path}/batching`, MethodNameNull));
  }
};
__name(Common, "Common");

// packages/sdk/src/sections/state-queries.ts
var StateQueries = class extends Section {
  async get(args) {
    const { endpoint, module, method } = args;
    const url = `${endpoint}/${module}/${method}`;
    const response = await this.client.instance({
      method: Method.GET,
      baseURL: this.baseUrl,
      url
    });
    return response.data;
  }
  async execute(params, body) {
    const { endpoint, module, method } = params;
    const url = `${endpoint}/${module}/${method}`;
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url,
      data: body || {}
    });
    return response.data;
  }
};
__name(StateQueries, "StateQueries");

// packages/sdk/src/common/constants.ts
var Chains;
(function(Chains2) {
  Chains2["opal"] = "opal";
  Chains2["sapphire"] = "sapphire";
  Chains2["quartz"] = "quartz";
  Chains2["unique"] = "unique";
})(Chains || (Chains = {}));
var CHAIN_CONFIG = {
  opal: {
    websocketUrl: "wss://ws-opal.unique.network",
    rpcUrl: "https://rpc-opal.unique.network",
    restUrl: "https://rest.unique.network/opal/v1",
    ss58Prefix: 42,
    currency: {
      symbol: "OPL",
      decimals: 18
    },
    logo: {
      color: "#0CB6B8",
      ipfsCid: "QmYJDpmWyjDa3H6BxweFmQXk4fU8b1GU7M9EqYcaUNvXzc"
    }
  },
  sapphire: {
    websocketUrl: "wss://ws-sapphire.unique.network",
    ss58Prefix: 8883,
    rpcUrl: "https://rpc-sapphire.unique.network",
    restUrl: "https://rest.unique.network/sapphire/v1",
    currency: {
      symbol: "QTZ",
      decimals: 18
    },
    logo: {
      color: "#5D59FF",
      ipfsCid: "Qmd1PGt4cDRjFbh4ihP5QKEd4XQVwN1MkebYKdF56V74pf"
    }
  },
  quartz: {
    websocketUrl: "wss://ws-quartz.unique.network",
    ss58Prefix: 255,
    rpcUrl: "https://rpc-quartz.unique.network",
    restUrl: "https://rest.unique.network/quartz/v1",
    currency: {
      symbol: "QTZ",
      decimals: 18
    },
    logo: {
      color: "#FF4D6A",
      ipfsCid: "QmaGPdccULQEFcCGxzstnmE8THfac2kSiGwvWRAiaRq4dp"
    }
  },
  unique: {
    websocketUrl: "wss://ws.unique.network",
    ss58Prefix: 7391,
    rpcUrl: "https://rpc.unique.network",
    restUrl: "https://rest.unique.network/unique/v1",
    currency: {
      symbol: "UNQ",
      decimals: 18
    },
    logo: {
      color: "#00BFFF",
      ipfsCid: "QmbJ7CGZ2GxWMp7s6jy71UGzRsMe4w3KANKXDAExYWdaFR"
    }
  }
};

// packages/sdk/src/thin-client.ts
var ThinClient = class extends BaseClient {
  constructor(options) {
    super(options);
    __publicField(this, "options");
    __publicField(this, "common");
    __publicField(this, "balance");
    __publicField(this, "fungible");
    __publicField(this, "refungible");
    __publicField(this, "collection");
    __publicField(this, "token");
    __publicField(this, "erc721");
    __publicField(this, "ipfs");
    __publicField(this, "stateQuery");
    __publicField(this, "defaults");
    this.options = options;
    this.defaults = {
      baseUrl: ""
    };
    this.common = new Common(this, "common");
    this.balance = new Balance(this, "balance");
    this.fungible = new Fungible(this, "fungible");
    this.refungible = new Refungible(this, "refungible");
    this.collection = new Collection(this, "collections");
    this.token = new Token(this, "tokens");
    this.erc721 = new ERC721(this, "erc721");
    this.ipfs = new Ipfs(this, "ipfs");
    this.stateQuery = new StateQueries(this, "query");
  }
};
__name(ThinClient, "ThinClient");

// packages/sdk/src/index.ts
var src_default = ThinClient;
export {
  BalanceMethods,
  CHAIN_CONFIG,
  Chains,
  Method,
  Rooms,
  SubscriptionEvents,
  ThinClient,
  src_default as default
};
//# sourceMappingURL=index.js.map