var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// packages/sdk/src/evm.ts
var evm_exports = {};
__export(evm_exports, {
  BalanceMethods: () => BalanceMethods,
  CHAIN_CONFIG: () => CHAIN_CONFIG,
  Chains: () => Chains,
  EvmClient: () => EvmClient,
  Method: () => Method,
  Rooms: () => Rooms,
  SubscriptionEvents: () => SubscriptionEvents,
  default: () => evm_default
});
module.exports = __toCommonJS(evm_exports);

// packages/sdk/src/common/base-client.ts
var import_axios = __toESM(require("axios"), 1);

// packages/sdk/src/errors/api-error.ts
var ApiError = class extends Error {
  constructor(responseError) {
    super(responseError.message);
    __publicField(this, "code");
    __publicField(this, "details");
    this.code = responseError.code;
    this.name = responseError.name;
    this.details = responseError.details;
  }
};
__name(ApiError, "ApiError");

// packages/sdk/src/errors/max-status-requests-error.ts
var MaxStatusRequestsError = class extends Error {
  constructor(txHash, limit) {
    const message = `Extrinsic status was not changed within the specified count of status requests (${limit}).`;
    super(message);
    __publicField(this, "details");
    __publicField(this, "txHash");
    __publicField(this, "limit");
    this.details = `${message} This does not mean that the Extrinsic has failed nor that it will be included in the future. You can check the status of the Extrinsic by calling the getStatus() method.`;
    this.txHash = txHash;
    this.limit = limit;
  }
};
__name(MaxStatusRequestsError, "MaxStatusRequestsError");

// packages/sdk/src/errors/timeout-error.ts
var TimeoutError = class extends Error {
  constructor(txHash, timeoutMs) {
    const message = `Extrinsic status was not changed within the specified time (${timeoutMs} ms).`;
    super(message);
    __publicField(this, "details");
    __publicField(this, "txHash");
    __publicField(this, "timeoutMs");
    this.details = `${message} This does not mean that the Extrinsic has failed nor that it will be included in the future. You can check the status of the Extrinsic by calling the getStatus() method.`;
    this.txHash = txHash;
    this.timeoutMs = timeoutMs;
  }
};
__name(TimeoutError, "TimeoutError");

// packages/sdk/src/types/enums.ts
var Method;
(function(Method2) {
  Method2["GET"] = "GET";
  Method2["POST"] = "POST";
  Method2["DELETE"] = "DELETE";
  Method2["PATCH"] = "PATCH";
  Method2["PUT"] = "PUT";
})(Method || (Method = {}));

// packages/common/types/subscriptions.ts
var Rooms;
(function(Rooms2) {
  Rooms2["SYSTEM"] = "system";
  Rooms2["BLOCKS"] = "blocks";
  Rooms2["EXTRINSICS"] = "extrinsics";
  Rooms2["COLLECTION"] = "collection";
  Rooms2["CONTRACT"] = "contract";
  Rooms2["EVENTS"] = "events";
  Rooms2["BALANCE"] = "balance";
  Rooms2["ACCOUNT_CURRENT_BALANCE"] = "account-current-balance";
})(Rooms || (Rooms = {}));
var SubscriptionEvents;
(function(SubscriptionEvents2) {
  SubscriptionEvents2["SYSTEM"] = "system";
  SubscriptionEvents2["BLOCKS"] = "blocks";
  SubscriptionEvents2["EXTRINSICS"] = "extrinsics";
  SubscriptionEvents2["EVENTS"] = "events";
  SubscriptionEvents2["CONTRACT_LOGS"] = "contract-logs";
  SubscriptionEvents2["COLLECTIONS"] = "collections";
  SubscriptionEvents2["HAS_NEXT"] = "has-next";
  SubscriptionEvents2["BALANCES"] = "balances";
  SubscriptionEvents2["ACCOUNT_CURRENT_BALANCE"] = "account-current-balance";
  SubscriptionEvents2["SUBSCRIBE_STATE"] = "subscribe-state";
})(SubscriptionEvents || (SubscriptionEvents = {}));
var BalanceMethods;
(function(BalanceMethods2) {
  BalanceMethods2["WITHDRAW"] = "Withdraw";
  BalanceMethods2["TRANSFER"] = "Transfer";
  BalanceMethods2["DEPOSIT"] = "Deposit";
  BalanceMethods2["DUST_LOST"] = "DustLost";
  BalanceMethods2["ENDOWED"] = "Endowed";
  BalanceMethods2["LOCKED"] = "Locked";
  BalanceMethods2["UNLOCKED"] = "Unlocked";
  BalanceMethods2["RESERVED"] = "Reserved";
})(BalanceMethods || (BalanceMethods = {}));

// packages/sdk/src/common/section.ts
var Section = class {
  constructor(client, path) {
    __publicField(this, "client");
    __publicField(this, "path");
    __publicField(this, "baseUrl");
    this.client = client;
    this.path = path;
    this.baseUrl = `${this.client.options.baseUrl}/${path}`;
  }
  async query(url, params) {
    const response = await this.client.instance({
      method: Method.GET,
      baseURL: this.baseUrl,
      url,
      params
    });
    return response.data;
  }
  async postRequest(url, data, params) {
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url,
      data,
      params
    });
    return response.data;
  }
};
__name(Section, "Section");

// packages/sdk/src/common/utils.ts
var isUnsignedTxPayloadResponse = /* @__PURE__ */ __name((args) => typeof args === "object" && !!args && "signerPayloadJSON" in args, "isUnsignedTxPayloadResponse");
var isSubmitTxBody = /* @__PURE__ */ __name((args) => isUnsignedTxPayloadResponse(args) && !!args && "signature" in args, "isSubmitTxBody");
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
__name(sleep, "sleep");
var getAddress = /* @__PURE__ */ __name((options, args) => {
  if (args.address)
    return args.address;
  if (options.signer?.address)
    return options.signer.address;
  if (options.account?.address)
    return options.account.address;
  if (options.account?.signer?.address)
    return options.account.signer.address;
  return void 0;
}, "getAddress");
var addAddress = /* @__PURE__ */ __name((options, args) => {
  const address = getAddress(options, args);
  if (!address)
    throw new Error("No address provided");
  return {
    ...args,
    address
  };
}, "addAddress");

// packages/sdk/src/sections/extrinsic.ts
var getSigner = /* @__PURE__ */ __name((options, accountOrSigner) => {
  if (accountOrSigner) {
    return "sign" in accountOrSigner ? accountOrSigner : accountOrSigner.signer;
  }
  if (options.signer)
    return options.signer;
  if (options.account?.signer)
    return options.account.signer;
  return void 0;
}, "getSigner");
var getAddress2 = /* @__PURE__ */ __name((options, args) => {
  if (args.address)
    return args.address;
  if (options.signer?.address)
    return options.signer.address;
  if (options.account?.address)
    return options.account.address;
  if (options.account?.signer?.address)
    return options.account.signer.address;
  return void 0;
}, "getAddress");
var Extrinsic = class extends Section {
  async build(args) {
    const address = getAddress2(this.client.options, args);
    if (!address)
      throw new Error("Invalid address");
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url: "build",
      data: {
        ...args,
        address
      }
    });
    return response.data;
  }
  async getFee(args) {
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url: "calculate-fee",
      data: args
    });
    return response.data;
  }
  async sign(args, signer) {
    const signerToUse = getSigner(this.client.options, signer);
    if (!signerToUse)
      throw new Error(`No signer provided`);
    return signerToUse.sign(args);
  }
  async submit(args) {
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url: "submit",
      data: args
    });
    return response.data;
  }
  async submitWatch(args, signer = this.client.options.signer) {
    const txBuild = await this.client.extrinsic.build(args);
    const signedTxPayload = await this.client.extrinsic.sign(txBuild, signer);
    const submitTxResult = await this.client.extrinsic.submit({
      signerPayloadJSON: txBuild.signerPayloadJSON,
      signature: signedTxPayload.signature
    });
    return submitTxResult;
  }
  async submitWaitResult(args, signer = this.client.options.signer) {
    const { hash } = await this.client.extrinsic.submitWatch(args, signer);
    return this.client.extrinsic.waitResult({
      hash
    });
  }
  async waitResult({ hash }) {
    const timeout = this.client.options.statusTotalTimeoutInMs;
    const maxRequests = this.client.options.maximumNumberOfStatusRequests;
    const waitTime = this.client.options.waitBetweenStatusRequestsInMs;
    let isTimeExceeded = false;
    setTimeout(() => {
      isTimeExceeded = true;
    }, timeout);
    let requestCount = 0;
    do {
      const checkStatusResult = await this.client.extrinsic.status({
        hash
      });
      if (checkStatusResult.isCompleted || checkStatusResult.error) {
        return checkStatusResult;
      }
      await sleep(waitTime);
      requestCount += 1;
    } while (!isTimeExceeded && requestCount < maxRequests);
    if (isTimeExceeded)
      throw new TimeoutError(hash, timeout);
    throw new MaxStatusRequestsError(hash, maxRequests);
  }
  async status(args) {
    const response = await this.client.instance({
      method: Method.GET,
      baseURL: this.baseUrl,
      url: "status",
      params: args
    });
    return response.data;
  }
  async get(args) {
    const response = await this.client.instance({
      method: Method.GET,
      baseURL: this.baseUrl,
      url: "",
      params: args
    });
    return response.data;
  }
};
__name(Extrinsic, "Extrinsic");

// packages/sdk/package.json
var version = "0.7.7";

// packages/sdk/src/common/base-client.ts
var BaseClient = class {
  constructor(options) {
    __publicField(this, "instance");
    __publicField(this, "options");
    __publicField(this, "extrinsic");
    this.options = options;
    this.checkOptions();
    this.instance = import_axios.default.create({
      baseURL: `${this.options.baseUrl}`,
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      ...options.axiosConfig
    });
    this.instance.interceptors.response.use((response) => response, (exception) => {
      const err = exception.response?.data?.error;
      throw err && typeof err === "object" ? new ApiError(err) : exception;
    });
    if (version) {
      this.instance.defaults.headers.common["X-SDK-Version"] = version;
    }
    this.extrinsic = new Extrinsic(this, "extrinsic");
  }
  checkOptions() {
    const { baseUrl } = this.options;
    if (!this.options.baseUrl) {
      throw new Error(`'baseUrl' option is required`);
    }
    this.options.baseUrl = baseUrl.replace(/\/$/, "");
    if (!this.options.statusTotalTimeoutInMs) {
      this.options.statusTotalTimeoutInMs = 3 * 60 * 1e3;
    }
    if (!this.options.maximumNumberOfStatusRequests) {
      this.options.maximumNumberOfStatusRequests = Number.MAX_SAFE_INTEGER;
    }
    if (!this.options.waitBetweenStatusRequestsInMs) {
      this.options.waitBetweenStatusRequestsInMs = 5e3;
    }
  }
};
__name(BaseClient, "BaseClient");

// packages/sdk/src/common/mutation.ts
var MutationAbstract = class {
  constructor(client, method, path, methodName) {
    __publicField(this, "client");
    __publicField(this, "method");
    __publicField(this, "path");
    __publicField(this, "methodName");
    __publicField(this, "url");
    this.client = client;
    this.method = method;
    this.path = path;
    this.methodName = methodName;
    this.url = `${this.client.options.baseUrl}/${this.path}`;
  }
  async buildBatch(args, options) {
    const data = args.map((a) => addAddress(this.client.options, a));
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "BuildBatch"
      },
      data
    });
    return response.data;
  }
  async build(args, options) {
    const data = addAddress(this.client.options, args);
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "Build"
      },
      data
    });
    return response.data;
  }
  async getFee(args) {
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        use: "GetFee"
      },
      data: args
    });
    return response?.data;
  }
  async sign(args, options) {
    const unsigned = isUnsignedTxPayloadResponse(args) ? args : await this.build(args, options);
    const { signerPayloadJSON } = unsigned;
    const { signature } = await this.client.extrinsic.sign(unsigned, options?.signer);
    return {
      signature,
      signerPayloadJSON
    };
  }
  async submit(args, options) {
    const submitTxArguments = isSubmitTxBody(args) ? args : await this.sign(args, options);
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "Submit"
      },
      data: submitTxArguments
    });
    return response.data;
  }
  async submitWatch(args, options) {
    const submitTxArguments = isSubmitTxBody(args) ? args : await this.sign(args, options);
    const response = await this.client.instance({
      method: this.method,
      url: this.url,
      params: {
        ...options,
        use: "SubmitWatch"
      },
      data: submitTxArguments
    });
    return response.data;
  }
  async submitWaitResult(args, options) {
    const { hash } = await this.submitWatch(args, options);
    return this.client.extrinsic.waitResult({
      hash
    });
  }
  batchCall(args) {
    if (!this.methodName) {
      throw new Error(`Batching not defined in method: ${this.path}`);
    }
    return {
      method: this.methodName,
      rawPayload: args
    };
  }
};
__name(MutationAbstract, "MutationAbstract");
function createMutationByInstance(mutation) {
  const submitWaitResult = /* @__PURE__ */ __name((args, options) => mutation.submitWaitResult(args, options), "submitWaitResult");
  submitWaitResult.build = mutation.build.bind(mutation);
  submitWaitResult.buildBatch = mutation.buildBatch.bind(mutation);
  submitWaitResult.getFee = mutation.getFee.bind(mutation);
  submitWaitResult.sign = mutation.sign.bind(mutation);
  submitWaitResult.submit = mutation.submit.bind(mutation);
  submitWaitResult.submitWatch = mutation.submitWatch.bind(mutation);
  submitWaitResult.submitWaitResult = mutation.submitWaitResult.bind(mutation);
  submitWaitResult.batchCall = mutation.batchCall.bind(mutation);
  return submitWaitResult;
}
__name(createMutationByInstance, "createMutationByInstance");
var MethodNameNull = null;

// packages/sdk/src/sections/evm/utils.ts
var import_abi_coder = require("abi-coder");
var parseEvmEvents = /* @__PURE__ */ __name((events, abi) => {
  const erc20Coder = new import_abi_coder.Coder(abi);
  const parsedEvents = [];
  const unknownEvents = [];
  events.filter((event) => event.section === "evm" && event.method === "Log").forEach((event) => {
    const logData = event.data[0];
    const { topics, data } = logData;
    try {
      const decoded = erc20Coder.decodeEvent(topics, data);
      parsedEvents.push({
        name: decoded.name,
        values: decoded.values
      });
    } catch (err) {
      unknownEvents.push({
        topics,
        data
      });
    }
  });
  return {
    parsedEvents,
    unknownEvents
  };
}, "parseEvmEvents");

// packages/sdk/src/sections/evm/mutation/evm.ts
var EvmSendMutation = /* @__PURE__ */ __name(class EvmSendMutation2 extends MutationAbstract {
  constructor(evm) {
    super(evm.client, Method.POST, "evm/send", {
      section: "evm",
      method: "call"
    });
    __publicField(this, "evm");
    this.evm = evm;
  }
  async submitWaitResult(args, options) {
    const result = await super.submitWaitResult(args, options);
    if ("abi" in args) {
      if (result.parsed.isExecutedFailed) {
        await this.evm.call(args);
      }
      const { parsedEvents, unknownEvents } = parseEvmEvents(result.events, args.abi);
      result.parsed.parsedEvents = parsedEvents;
      result.parsed.unknownEvents = unknownEvents;
    }
    return result;
  }
}, "EvmSendMutation");
function createEvmSendMutation(evm) {
  const mutation = new EvmSendMutation(evm);
  return createMutationByInstance(mutation);
}
__name(createEvmSendMutation, "createEvmSendMutation");

// packages/sdk/src/sections/evm/mutation/contract.ts
var ContractSendMutation = /* @__PURE__ */ __name(class ContractSendMutation2 extends MutationAbstract {
  constructor(contract) {
    super(contract.client, Method.POST, "evm/send", MethodNameNull);
    __publicField(this, "contract");
    this.contract = contract;
  }
  async build(args) {
    return super.build({
      contractAddress: this.contract.contractAddress,
      abi: this.contract.abi,
      ...args
    });
  }
  async submitWaitResult(args, options) {
    const result = await super.submitWaitResult(args, options);
    if (result.parsed.isExecutedFailed) {
      await this.contract.call(args);
    }
    const { parsedEvents, unknownEvents } = parseEvmEvents(result.events, this.contract.abi);
    result.parsed.parsedEvents = parsedEvents;
    result.parsed.unknownEvents = unknownEvents;
    return result;
  }
}, "ContractSendMutation");
function createContractSendMutation(contract) {
  const mutation = new ContractSendMutation(contract);
  return createMutationByInstance(mutation);
}
__name(createContractSendMutation, "createContractSendMutation");

// packages/sdk/src/sections/evm/contract.ts
var Contract = class extends Section {
  constructor(client, contractAddress, abi) {
    super(client, "evm");
    __publicField(this, "contractAddress");
    __publicField(this, "abi");
    __publicField(this, "send");
    this.contractAddress = contractAddress;
    this.abi = abi;
    this.send = createContractSendMutation(this);
  }
  async call(args) {
    const response = await this.client.instance({
      method: Method.POST,
      baseURL: this.baseUrl,
      url: "call",
      data: {
        contractAddress: this.contractAddress,
        abi: this.abi,
        ...args
      }
    });
    return response.data;
  }
};
__name(Contract, "Contract");

// packages/sdk/src/sections/evm/evm.ts
var Evm = class extends Section {
  constructor() {
    super(...arguments);
    __publicField(this, "send", createEvmSendMutation(this));
    __publicField(this, "contractExists", /* @__PURE__ */ __name((args) => this.query("contract-exists", args), "contractExists"));
  }
  call(args) {
    return this.postRequest("call", args);
  }
  async contractConnect(contractAddress, abi) {
    const { exists } = await this.contractExists({
      contractAddress
    });
    if (!exists) {
      throw new Error("Contract is not exists");
    }
    return new Contract(this.client, contractAddress, abi);
  }
};
__name(Evm, "Evm");

// packages/sdk/src/sections/evm/evm-client.ts
var EvmClient = class extends BaseClient {
  constructor(options) {
    super(options);
    __publicField(this, "client");
    __publicField(this, "send");
    __publicField(this, "contractExists");
    __publicField(this, "call");
    __publicField(this, "contractConnect");
    const evm = new Evm(this, "evm");
    this.send = evm.send;
    this.contractExists = evm.contractExists;
    this.call = evm.call;
    this.contractConnect = evm.contractConnect;
  }
};
__name(EvmClient, "EvmClient");

// packages/sdk/src/common/constants.ts
var Chains;
(function(Chains2) {
  Chains2["opal"] = "opal";
  Chains2["sapphire"] = "sapphire";
  Chains2["quartz"] = "quartz";
  Chains2["unique"] = "unique";
})(Chains || (Chains = {}));
var CHAIN_CONFIG = {
  opal: {
    websocketUrl: "wss://ws-opal.unique.network",
    rpcUrl: "https://rpc-opal.unique.network",
    restUrl: "https://rest.unique.network/opal/v1",
    ss58Prefix: 42,
    currency: {
      symbol: "OPL",
      decimals: 18
    },
    logo: {
      color: "#0CB6B8",
      ipfsCid: "QmYJDpmWyjDa3H6BxweFmQXk4fU8b1GU7M9EqYcaUNvXzc"
    }
  },
  sapphire: {
    websocketUrl: "wss://ws-sapphire.unique.network",
    ss58Prefix: 8883,
    rpcUrl: "https://rpc-sapphire.unique.network",
    restUrl: "https://rest.unique.network/sapphire/v1",
    currency: {
      symbol: "QTZ",
      decimals: 18
    },
    logo: {
      color: "#5D59FF",
      ipfsCid: "Qmd1PGt4cDRjFbh4ihP5QKEd4XQVwN1MkebYKdF56V74pf"
    }
  },
  quartz: {
    websocketUrl: "wss://ws-quartz.unique.network",
    ss58Prefix: 255,
    rpcUrl: "https://rpc-quartz.unique.network",
    restUrl: "https://rest.unique.network/quartz/v1",
    currency: {
      symbol: "QTZ",
      decimals: 18
    },
    logo: {
      color: "#FF4D6A",
      ipfsCid: "QmaGPdccULQEFcCGxzstnmE8THfac2kSiGwvWRAiaRq4dp"
    }
  },
  unique: {
    websocketUrl: "wss://ws.unique.network",
    ss58Prefix: 7391,
    rpcUrl: "https://rpc.unique.network",
    restUrl: "https://rest.unique.network/unique/v1",
    currency: {
      symbol: "UNQ",
      decimals: 18
    },
    logo: {
      color: "#00BFFF",
      ipfsCid: "QmbJ7CGZ2GxWMp7s6jy71UGzRsMe4w3KANKXDAExYWdaFR"
    }
  }
};

// packages/sdk/src/evm.ts
var evm_default = EvmClient;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BalanceMethods,
  CHAIN_CONFIG,
  Chains,
  EvmClient,
  Method,
  Rooms,
  SubscriptionEvents
});
//# sourceMappingURL=evm.cjs.map