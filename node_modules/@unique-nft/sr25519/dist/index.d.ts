declare class Scalar {
    bytes: Uint8Array;
    static FromBytes(data: Uint8Array): Scalar;
    static FromBits(bytes: Uint8Array): Scalar;
    ToBytes(): Uint8Array;
    static FromBytesModOrderWide(data: Uint8Array): Uint8Array;
    static ToRadix16(bytes: Uint8Array): number[];
    static DivideScalarBytesByCofactor(bytes: Uint8Array): Uint8Array;
    static MultiplyScalarBytesByCofactor(bytes: Uint8Array): Uint8Array;
    NonAdjacentForm(size: number): number[];
}

declare class WrappedRes {
    i0: boolean;
    i1: FieldElement;
}
declare class FieldElement {
    data: bigint[];
    constructor(data: bigint[]);
    static FromBytes(bytes: Uint8Array): FieldElement;
    Clone(): FieldElement;
    CtEq(a: FieldElement): boolean;
    Negate(): FieldElement;
    static SqrtRatioI(u: FieldElement, v: FieldElement): WrappedRes;
    ConditionalNegate(choice: boolean): void;
    IsNegative(): boolean;
    ConditionalAssign(other: FieldElement, choice: boolean): void;
    Pow2k(k: number): FieldElement;
    static One(): FieldElement;
    static Zero(): FieldElement;
    Mul(second: FieldElement): FieldElement;
    Reduce(limbs: bigint[]): FieldElement;
    Add(element: FieldElement): FieldElement;
    Sub(x: FieldElement): FieldElement;
    Square(): FieldElement;
    Square2(): FieldElement;
    BitXor(a: FieldElement): FieldElement;
    BitAnd(a: bigint): FieldElement;
    ToBytes(): Uint8Array;
    Invert(): FieldElement;
}

declare class ProjectivePoint {
    X: FieldElement;
    Y: FieldElement;
    Z: FieldElement;
    Double(): CompletedPoint;
    static Identity(): ProjectivePoint;
    ToExtended(): EdwardsPoint;
}

declare class CompletedPoint {
    X: FieldElement;
    Y: FieldElement;
    Z: FieldElement;
    T: FieldElement;
    ToProjective(): ProjectivePoint;
    ToExtended(): EdwardsPoint;
}

declare class AffineNielsPoint {
    Y_plus_X: FieldElement;
    Y_minus_X: FieldElement;
    XY2d: FieldElement;
    constructor();
    static FromElements(Y_plus_X: FieldElement, Y_minus_X: FieldElement, XY2d: FieldElement): AffineNielsPoint;
    static FromArray(array: bigint[]): AffineNielsPoint;
    static FromStringInRadix36Form(param: string): AffineNielsPoint;
    ConditionalAssign(a: AffineNielsPoint, choice: boolean): void;
    BitXor(a: AffineNielsPoint): AffineNielsPoint;
    ConditionalNegate(choice: boolean): void;
    Negate(): AffineNielsPoint;
}

declare class ProjectiveNielsPoint {
    Y_plus_X: FieldElement;
    Y_minus_X: FieldElement;
    Z: FieldElement;
    T2d: FieldElement;
    constructor();
    BitXor(a: ProjectiveNielsPoint): ProjectiveNielsPoint;
    BitAnd(a: number): ProjectiveNielsPoint;
    Negate(): ProjectiveNielsPoint;
    Copy(): ProjectiveNielsPoint;
    GetPoint(): ProjectiveNielsPoint;
    FromPoint(a: ProjectiveNielsPoint): void;
    ConditionalAssign(a: ProjectiveNielsPoint, choice: boolean): void;
    ConditionalNegate(choice: boolean): void;
}

declare class EdwardsPoint {
    X: FieldElement;
    Y: FieldElement;
    Z: FieldElement;
    T: FieldElement;
    FromElems(x: FieldElement, y: FieldElement, z: FieldElement, t: FieldElement): void;
    static EdwardsPointFromElems(x: FieldElement, y: FieldElement, z: FieldElement, t: FieldElement): EdwardsPoint;
    Equals(a: EdwardsPoint): boolean;
    Copy(): EdwardsPoint;
    static FromCompressedPoint(bytes: Uint8Array): EdwardsPoint;
    static Double(point: EdwardsPoint): EdwardsPoint;
    MulByPow2(k: number): EdwardsPoint;
    static Identity(): EdwardsPoint;
    Negate(): EdwardsPoint;
    ToExtended(): EdwardsPoint;
    AddPnp(other: ProjectiveNielsPoint): CompletedPoint;
    AddAnp(other: AffineNielsPoint): CompletedPoint;
    AddEp(other: EdwardsPoint): EdwardsPoint;
    SubAnp(other: AffineNielsPoint): CompletedPoint;
    SubPnp(other: ProjectiveNielsPoint): CompletedPoint;
    ToProjectiveNiels(): ProjectiveNielsPoint;
    ToProjective(): ProjectivePoint;
    ToAffineNiels(): AffineNielsPoint;
}

declare class CompressedRistretto {
    bytes: Uint8Array;
    static FromBytes(data: Uint8Array): CompressedRistretto;
    ToBytes(): Uint8Array;
}
declare class RistrettoPoint {
    Ep: EdwardsPoint;
    constructor(ep: EdwardsPoint);
    static FromCompressedPoint(compressed: CompressedRistretto): RistrettoPoint;
    static FromCompressedPointBytes(bytes: Uint8Array): RistrettoPoint;
    Negate(): RistrettoPoint;
    static vartimeDoubleScalarMulBasepoint(a: Scalar, A: EdwardsPoint, b: Scalar): EdwardsPoint;
    Compress(): CompressedRistretto;
}

declare class SecretKey {
    nonce: Uint8Array;
    key: Scalar;
    static FromBytes(bytes: Uint8Array): SecretKey;
    static FromScalarAndNonce(scalar: Scalar, nonce: Uint8Array): SecretKey;
    static FromMiniSecret(miniSecret: Uint8Array): SecretKey;
    ToBytes(): Uint8Array;
    ToPublicKey(): PublicKey;
    sign(message: Uint8Array, publicKey: PublicKey, rng?: RandomGenerator): Signature;
}
declare class PublicKey {
    key: Uint8Array;
    static FromBytes(bytes: Uint8Array): PublicKey;
    ToBytes(): Uint8Array;
    ToRistrettoPoint(): RistrettoPoint;
    verify(message: Uint8Array, signatureBytes: Uint8Array): boolean;
}
declare class RandomGenerator {
    GetRandomArrayU8_32(): Uint8Array;
    GetHardcoded(): Uint8Array;
}
declare class Signature {
    R: CompressedRistretto;
    S: Scalar;
    static FromBytes(bytes: Uint8Array): Signature;
    static FromCompressedRistrettoAndScalar(R: CompressedRistretto, S: Scalar): Signature;
    ToBytes(): Uint8Array;
}

declare class Keypair {
    publicKey: PublicKey;
    secretKey: SecretKey;
    constructor(publicKey: PublicKey, secretKey: SecretKey);
    static FromBytes(bytes: Uint8Array): Keypair;
    static FromSecretKeyBytes(secretKeyBytes: Uint8Array): Keypair;
    static FromUri(uri: string): Keypair;
    static FromUriAsync(uri: string): Promise<Keypair>;
    static FromMiniSecret(miniSecret: Uint8Array): Keypair;
    ToBytes(): Uint8Array;
}

declare function decodeSubstrateAddress(address: string, ignoreChecksum?: boolean, ss58Format?: number): Uint8Array;

type KeypairType = 'ed25519' | 'sr25519' | 'ecdsa' | 'ethereum';
interface UNIQUE_SDK_UnsignedTxPayloadBody {
    signerPayloadJSON?: any;
    signerPayloadRaw?: any;
    signerPayloadHex: string;
}
interface UNIQUE_SDK_SignTxResultResponse {
    signature: string;
    signatureType: KeypairType;
}
interface IUniqueSdkSigner {
    sign: (unsignedTxPayload: UNIQUE_SDK_UnsignedTxPayloadBody) => Promise<UNIQUE_SDK_SignTxResultResponse>;
}

/**
 * private method, don't export
 * @param keypair
 */
declare const getAccountFromKeypair: (keypair: Keypair) => {
    readonly publicKey: Uint8Array;
    address: string;
    prefixedAddress(prefix?: number): string;
    /**
     * @name sign
     * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
     * @returns [Uint8Array] - signature
     */
    sign(message: Uint8Array | string): Uint8Array;
    /**
     * @name verify
     * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
     * @param signature [Uint8Array]
     * @returns [boolean] - true if the signature is valid, false otherwise
     */
    verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
    /**
     * @name signer
     * @description signer for @unique-nft/sdk
     */
    signer: {
        sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
    };
};
declare const verifySignature: (message: Uint8Array | string, signature: Uint8Array | string, signerAddressOrPublicKey: Uint8Array | string) => boolean;
declare const dangerouslyParseUriAndGetFullKeypair: (uri: string) => Keypair;
declare const Sr25519Account: {
    fromUri: (uri: string) => {
        readonly publicKey: Uint8Array;
        address: string;
        prefixedAddress(prefix?: number): string;
        /**
         * @name sign
         * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
         * @returns [Uint8Array] - signature
         */
        sign(message: Uint8Array | string): Uint8Array;
        /**
         * @name verify
         * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
         * @param signature [Uint8Array]
         * @returns [boolean] - true if the signature is valid, false otherwise
         */
        verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
        /**
         * @name signer
         * @description signer for @unique-nft/sdk
         */
        signer: {
            sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
        };
    };
    verifySignature: (message: Uint8Array | string, signature: Uint8Array | string, signerAddressOrPublicKey: Uint8Array | string) => boolean;
    other: {
        fromMiniSecret: (miniSecret: Uint8Array | string) => {
            readonly publicKey: Uint8Array;
            address: string;
            prefixedAddress(prefix?: number): string;
            /**
             * @name sign
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @returns [Uint8Array] - signature
             */
            sign(message: Uint8Array | string): Uint8Array;
            /**
             * @name verify
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @param signature [Uint8Array]
             * @returns [boolean] - true if the signature is valid, false otherwise
             */
            verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
            /**
             * @name signer
             * @description signer for @unique-nft/sdk
             */
            signer: {
                sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
            };
        };
        fromSecretKeyBytes: (secretKeyBytes: Uint8Array | string) => {
            readonly publicKey: Uint8Array;
            address: string;
            prefixedAddress(prefix?: number): string;
            /**
             * @name sign
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @returns [Uint8Array] - signature
             */
            sign(message: Uint8Array | string): Uint8Array;
            /**
             * @name verify
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @param signature [Uint8Array]
             * @returns [boolean] - true if the signature is valid, false otherwise
             */
            verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
            /**
             * @name signer
             * @description signer for @unique-nft/sdk
             */
            signer: {
                sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
            };
        };
        fromKeypair: (keypair: Keypair) => {
            readonly publicKey: Uint8Array;
            address: string;
            prefixedAddress(prefix?: number): string;
            /**
             * @name sign
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @returns [Uint8Array] - signature
             */
            sign(message: Uint8Array | string): Uint8Array;
            /**
             * @name verify
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @param signature [Uint8Array]
             * @returns [boolean] - true if the signature is valid, false otherwise
             */
            verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
            /**
             * @name signer
             * @description signer for @unique-nft/sdk
             */
            signer: {
                sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
            };
        };
        mnemonicToMiniSecret: (mnemonic: string, password?: string) => Uint8Array;
        dangerouslyParseUriAndGetFullKeypair: (uri: string) => Keypair;
    };
    utils: {
        encodeSubstrateAddress: (key: Uint8Array, ss58Format?: number) => string;
        decodeSubstrateAddress: typeof decodeSubstrateAddress;
    };
    generateMnemonic: (strengthInBits?: number) => string;
};
/** @deprecated use Sr25519Account instead */
declare const Account: {
    fromUri: (uri: string) => {
        readonly publicKey: Uint8Array;
        address: string;
        prefixedAddress(prefix?: number): string;
        /**
         * @name sign
         * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
         * @returns [Uint8Array] - signature
         */
        sign(message: Uint8Array | string): Uint8Array;
        /**
         * @name verify
         * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
         * @param signature [Uint8Array]
         * @returns [boolean] - true if the signature is valid, false otherwise
         */
        verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
        /**
         * @name signer
         * @description signer for @unique-nft/sdk
         */
        signer: {
            sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
        };
    };
    verifySignature: (message: Uint8Array | string, signature: Uint8Array | string, signerAddressOrPublicKey: Uint8Array | string) => boolean;
    other: {
        fromMiniSecret: (miniSecret: Uint8Array | string) => {
            readonly publicKey: Uint8Array;
            address: string;
            prefixedAddress(prefix?: number): string;
            /**
             * @name sign
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @returns [Uint8Array] - signature
             */
            sign(message: Uint8Array | string): Uint8Array;
            /**
             * @name verify
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @param signature [Uint8Array]
             * @returns [boolean] - true if the signature is valid, false otherwise
             */
            verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
            /**
             * @name signer
             * @description signer for @unique-nft/sdk
             */
            signer: {
                sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
            };
        };
        fromSecretKeyBytes: (secretKeyBytes: Uint8Array | string) => {
            readonly publicKey: Uint8Array;
            address: string;
            prefixedAddress(prefix?: number): string;
            /**
             * @name sign
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @returns [Uint8Array] - signature
             */
            sign(message: Uint8Array | string): Uint8Array;
            /**
             * @name verify
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @param signature [Uint8Array]
             * @returns [boolean] - true if the signature is valid, false otherwise
             */
            verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
            /**
             * @name signer
             * @description signer for @unique-nft/sdk
             */
            signer: {
                sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
            };
        };
        fromKeypair: (keypair: Keypair) => {
            readonly publicKey: Uint8Array;
            address: string;
            prefixedAddress(prefix?: number): string;
            /**
             * @name sign
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @returns [Uint8Array] - signature
             */
            sign(message: Uint8Array | string): Uint8Array;
            /**
             * @name verify
             * @param message [Uint8Array | string]; Hex string or UTF-8 string will be automatically converted to a byte array
             * @param signature [Uint8Array]
             * @returns [boolean] - true if the signature is valid, false otherwise
             */
            verify(message: Uint8Array | string, signature: Uint8Array | string): boolean;
            /**
             * @name signer
             * @description signer for @unique-nft/sdk
             */
            signer: {
                sign(payload: UNIQUE_SDK_UnsignedTxPayloadBody): Promise<UNIQUE_SDK_SignTxResultResponse>;
            };
        };
        mnemonicToMiniSecret: (mnemonic: string, password?: string) => Uint8Array;
        dangerouslyParseUriAndGetFullKeypair: (uri: string) => Keypair;
    };
    utils: {
        encodeSubstrateAddress: (key: Uint8Array, ss58Format?: number) => string;
        decodeSubstrateAddress: typeof decodeSubstrateAddress;
    };
    generateMnemonic: (strengthInBits?: number) => string;
};

type ISr25519Account = ReturnType<typeof getAccountFromKeypair>;

export { Account, type ISr25519Account, type IUniqueSdkSigner, Sr25519Account, dangerouslyParseUriAndGetFullKeypair, Sr25519Account as default, verifySignature };
