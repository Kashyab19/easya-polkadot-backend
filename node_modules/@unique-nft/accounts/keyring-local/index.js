import { KeyringAccountBase, Provider } from '@unique-nft/accounts/types';
import { cryptoIsReady, cryptoWaitReady } from '@polkadot/util-crypto';
import keyring from '@polkadot/ui-keyring';
import { accounts } from '@polkadot/ui-keyring/observable/accounts';

class KeyringLocalAccount extends KeyringAccountBase {
  constructor(keyringPair, passwordCallback) {
    super(keyringPair);
    this.passwordCallback = passwordCallback;
  }
  async sign(unsignedTxPayload) {
    if (this.keyringPair.isLocked && this.passwordCallback) {
      const password = await this.passwordCallback(this.keyringPair);
      this.keyringPair.unlock(password);
    }
    return super.sign(unsignedTxPayload);
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const _KeyringLocalProvider = class _KeyringLocalProvider extends Provider {
  constructor(options = {}) {
    super();
    this.options = options;
  }
  static initialize(options) {
    if (_KeyringLocalProvider.initializer) {
      const { initializedOptions } = _KeyringLocalProvider;
      if (initializedOptions.type !== options.type) {
        throw new Error(
          "Cannot initialize a local provider more than once with different types"
        );
      }
      return _KeyringLocalProvider.initializer;
    }
    _KeyringLocalProvider.initializedOptions = options;
    _KeyringLocalProvider.initializer = (cryptoIsReady() ? cryptoWaitReady() : Promise.resolve()).then(
      () => keyring.loadAll({
        ss58Format: options.ss58Format,
        genesisHash: options.genesisHash,
        type: options.type
      })
    );
    return _KeyringLocalProvider.initializer;
  }
  async init() {
    await _KeyringLocalProvider.initialize(this.options);
    accounts.subject.subscribe((observedAccounts) => {
      const accounts = Object.values(observedAccounts).map(
        (account) => this.buildAccount(account.json.address)
      );
      this.emit("accountsChanged", accounts);
    });
  }
  // eslint-disable-next-line class-methods-use-this
  addUri(suri, password, meta, type) {
    const { pair } = keyring.addUri(suri, password, meta, type);
    return new KeyringLocalAccount(pair, this.options.passwordCallback);
  }
  buildAccount(address) {
    const pair = keyring.getPair(address);
    return new KeyringLocalAccount(pair, this.options.passwordCallback);
  }
  async getAccounts() {
    return keyring.getAccounts().map((account) => this.buildAccount(account.address));
  }
  // eslint-disable-next-line class-methods-use-this
  forgetAccount(account) {
    if (typeof account === "string") {
      keyring.forgetAccount(account);
    } else {
      keyring.forgetAccount(account.address);
    }
  }
  addPair(pair, password) {
    const { pair: pairResult } = keyring.addPair(pair, password);
    return new KeyringLocalAccount(pairResult, this.options.passwordCallback);
  }
  getPair(address) {
    return this.buildAccount(address);
  }
  createFromUri(suri, meta, type) {
    const pair = keyring.createFromUri(suri, meta, type);
    return new KeyringLocalAccount(pair, this.options.passwordCallback);
  }
  addExternal(address, meta) {
    const { pair } = keyring.addExternal(address, meta);
    return new KeyringLocalAccount(pair, this.options.passwordCallback);
  }
  createFromJson(json, meta) {
    const pair = keyring.createFromJson(json, meta);
    return new KeyringLocalAccount(pair, this.options.passwordCallback);
  }
};
__publicField(_KeyringLocalProvider, "initializedOptions");
__publicField(_KeyringLocalProvider, "initializer");
let KeyringLocalProvider = _KeyringLocalProvider;

export { KeyringLocalAccount, KeyringLocalProvider };
