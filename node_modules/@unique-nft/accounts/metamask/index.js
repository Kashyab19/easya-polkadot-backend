import { ethers } from 'ethers';
import { Address } from '@unique-nft/utils';
import { Account, SignatureType, Provider } from '@unique-nft/accounts/types';

const win = window;

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MetamaskAccount extends Account {
  constructor(address) {
    super(address, address);
    __publicField(this, "signer");
    const provider = new ethers.providers.Web3Provider(win.ethereum);
    this.signer = provider.getSigner(address);
  }
  formatAddress(prefix) {
    if (prefix === "ethereum") {
      return Address.normalize.ethereumAddress(this.address);
    }
    if (typeof prefix === "number") {
      return Address.mirror.ethereumToSubstrate(this.address, prefix);
    }
    return this.address;
  }
  async sign(unsignedTxPayload) {
    const signature = await this.signer.signMessage(
      unsignedTxPayload.signerPayloadHex
    );
    return {
      signature,
      signatureType: SignatureType.Sr25519
    };
  }
}

const checkMetamaskAvailable = () => win && win.ethereum;
class MetamaskProvider extends Provider {
  async init() {
    if (!checkMetamaskAvailable())
      return Promise.resolve();
    win.ethereum.on("accountsChanged", (addresses) => {
      const accounts = addresses.map((address) => new MetamaskAccount(address));
      this.emit("accountsChanged", accounts);
    });
    return Promise.resolve();
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccounts() {
    if (!checkMetamaskAvailable())
      return [];
    const addresses = await win.ethereum.request({
      method: "eth_requestAccounts"
    }).catch(() => []);
    return addresses.map((address) => new MetamaskAccount(address));
  }
  // eslint-disable-next-line class-methods-use-this
  forgetAccount(account) {
    throw new Error("Can't forget an account from metamask provider");
  }
}

export { MetamaskAccount, MetamaskProvider };
