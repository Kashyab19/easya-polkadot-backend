import { KeyringPair$Meta, KeyringPair$Json, KeyringPair } from '@polkadot/keyring/types';
import { HexString } from '@polkadot/util/types';
import { SignerPayloadJSON, SignerPayloadRaw } from '@polkadot/types/types';
import { EventEmitter } from 'events';

interface UnsignedTxPayload {
    signerPayloadJSON: SignerPayloadJSON;
    signerPayloadRaw: SignerPayloadRaw;
    signerPayloadHex: HexString;
}
interface SdkSigner {
    sign(unsignedTxPayload: UnsignedTxPayload): Promise<SignResult>;
    get address(): string;
}
declare enum SignatureType {
    Sr25519 = "sr25519",
    Ed25519 = "ed25519",
    Ecdsa = "ecdsa",
    Ethereum = "ethereum"
}
interface SignResult {
    signatureType: SignatureType;
    signature: HexString;
}
interface GenerateAccountDataArguments {
    pairType?: SignatureType;
    meta?: KeyringPair$Meta;
}
interface GetAccountDataArguments extends GenerateAccountDataArguments {
    mnemonic: string;
}
interface AccountData {
    mnemonic: string;
    seed: HexString;
    publicKey: HexString;
    keyfile: KeyringPair$Json;
}
declare const getAddressFromSubstrate: (address: string, prefix?: number | "ethereum" | undefined) => string;
declare abstract class Account<T = unknown> implements SdkSigner {
    private legacyInstance;
    readonly address: string;
    protected constructor(legacyInstance: T, address: string);
    /**
     * @deprecated use KeyringAccount.keyringPair or MetamaskAccount.address or PolkadotAccount.injectedAccount
     */
    get instance(): T;
    abstract sign(unsignedTxPayload: UnsignedTxPayload): Promise<SignResult>;
    /**
     * @deprecated use .address or .formatAddress
     */
    getAddress(prefix?: number | 'ethereum'): string;
    abstract formatAddress(prefix: number | 'ethereum'): string;
}
declare class KeyringAccountBase extends Account<KeyringPair> {
    readonly keyringPair: KeyringPair;
    constructor(keyringPair: KeyringPair);
    formatAddress(prefix?: number | 'ethereum'): string;
    sign(unsignedTxPayload: UnsignedTxPayload): Promise<SignResult>;
}
declare interface Provider<A = unknown> {
    on(event: 'accountsChanged', listener: (accounts: Account<A>[]) => void): this;
    emit(event: 'accountsChanged', accounts: Account<A>[]): boolean;
}
declare abstract class Provider<A = unknown> extends EventEmitter {
    abstract init(): Promise<void>;
    abstract getAccounts(): Promise<Account<A>[]>;
    abstract forgetAccount(account: Account<A> | string): void;
    first(): Promise<Account | undefined>;
}
declare type ProviderClass<T extends Provider> = {
    new (o?: any): T;
};

export { Account, AccountData, GenerateAccountDataArguments, GetAccountDataArguments, KeyringAccountBase, Provider, ProviderClass, SdkSigner, SignResult, SignatureType, UnsignedTxPayload, getAddressFromSubstrate };
