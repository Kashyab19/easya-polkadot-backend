import 'reflect-metadata';
import { u8aToHex } from '@polkadot/util';
import { Address } from '@unique-nft/utils';
import { EventEmitter } from 'events';

var SignatureType = /* @__PURE__ */ ((SignatureType2) => {
  SignatureType2["Sr25519"] = "sr25519";
  SignatureType2["Ed25519"] = "ed25519";
  SignatureType2["Ecdsa"] = "ecdsa";
  SignatureType2["Ethereum"] = "ethereum";
  return SignatureType2;
})(SignatureType || {});
const getAddressFromSubstrate = function(address, prefix) {
  if (prefix === "ethereum") {
    return Address.mirror.substrateToEthereum(address);
  }
  if (typeof prefix === "number") {
    return Address.normalize.substrateAddress(address, prefix);
  }
  return address;
};
class Account {
  constructor(legacyInstance, address) {
    this.legacyInstance = legacyInstance;
    this.address = address;
  }
  /**
   * @deprecated use KeyringAccount.keyringPair or MetamaskAccount.address or PolkadotAccount.injectedAccount
   */
  get instance() {
    return this.legacyInstance;
  }
  /**
   * @deprecated use .address or .formatAddress
   */
  getAddress(prefix) {
    return prefix ? this.formatAddress(prefix) : this.address;
  }
}
class KeyringAccountBase extends Account {
  constructor(keyringPair) {
    super(keyringPair, keyringPair.address);
    this.keyringPair = keyringPair;
  }
  formatAddress(prefix) {
    return getAddressFromSubstrate(this.keyringPair.address, prefix);
  }
  async sign(unsignedTxPayload) {
    const signature = await this.keyringPair.sign(
      unsignedTxPayload.signerPayloadHex,
      {
        withType: true
      }
    );
    return {
      signature: u8aToHex(signature),
      signatureType: this.keyringPair.type
    };
  }
}
class Provider extends EventEmitter {
  async first() {
    const accounts = await this.getAccounts();
    return accounts.length ? accounts[0] : void 0;
  }
}

export { Account, KeyringAccountBase, Provider, SignatureType, getAddressFromSubstrate };
