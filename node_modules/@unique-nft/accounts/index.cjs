'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var keyring = require('@polkadot/keyring');
var utilCrypto = require('@polkadot/util-crypto');
var util = require('@polkadot/util');
require('reflect-metadata');
var utils = require('@unique-nft/utils');
var events = require('events');

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
async function getAccountFromMnemonic(args) {
  const { mnemonic, pairType, meta } = args;
  const seed = utilCrypto.mnemonicToMiniSecret(mnemonic);
  const { publicKey } = utilCrypto.ed25519PairFromSeed(seed);
  const account = new keyring.Keyring({ type: pairType }).addFromSeed(
    seed,
    __spreadValues({}, meta),
    pairType
  );
  const keyfile = account.toJson();
  return {
    mnemonic,
    seed: util.u8aToHex(seed),
    publicKey: util.u8aToHex(publicKey),
    keyfile
  };
}
async function generateAccount(args) {
  const mnemonic = utilCrypto.mnemonicGenerate();
  return getAccountFromMnemonic(__spreadProps(__spreadValues({}, args), {
    mnemonic
  }));
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Accounts {
  constructor() {
    __publicField(this, "providers", /* @__PURE__ */ new Map());
  }
  async addProvider(ProviderClassLink, options) {
    const provider = new ProviderClassLink(options);
    await provider.init();
    this.providers.set(ProviderClassLink, provider);
    return provider;
  }
  getProvider(ProviderClassLink) {
    return this.providers.get(ProviderClassLink);
  }
  async getAccounts() {
    const accounts = [];
    const providers = this.providers.values();
    for (const provider of providers) {
      accounts.push(provider.getAccounts());
    }
    const result = await Promise.all(accounts);
    return Promise.resolve(result.flat(1));
  }
  async first() {
    const accounts = await this.getAccounts();
    return accounts.find((a) => !!a);
  }
}

var SignatureType = /* @__PURE__ */ ((SignatureType2) => {
  SignatureType2["Sr25519"] = "sr25519";
  SignatureType2["Ed25519"] = "ed25519";
  SignatureType2["Ecdsa"] = "ecdsa";
  SignatureType2["Ethereum"] = "ethereum";
  return SignatureType2;
})(SignatureType || {});
const getAddressFromSubstrate = function(address, prefix) {
  if (prefix === "ethereum") {
    return utils.Address.mirror.substrateToEthereum(address);
  }
  if (typeof prefix === "number") {
    return utils.Address.normalize.substrateAddress(address, prefix);
  }
  return address;
};
class Account {
  constructor(legacyInstance, address) {
    this.legacyInstance = legacyInstance;
    this.address = address;
  }
  /**
   * @deprecated use KeyringAccount.keyringPair or MetamaskAccount.address or PolkadotAccount.injectedAccount
   */
  get instance() {
    return this.legacyInstance;
  }
  /**
   * @deprecated use .address or .formatAddress
   */
  getAddress(prefix) {
    return prefix ? this.formatAddress(prefix) : this.address;
  }
}
class KeyringAccountBase extends Account {
  constructor(keyringPair) {
    super(keyringPair, keyringPair.address);
    this.keyringPair = keyringPair;
  }
  formatAddress(prefix) {
    return getAddressFromSubstrate(this.keyringPair.address, prefix);
  }
  async sign(unsignedTxPayload) {
    const signature = await this.keyringPair.sign(
      unsignedTxPayload.signerPayloadHex,
      {
        withType: true
      }
    );
    return {
      signature: util.u8aToHex(signature),
      signatureType: this.keyringPair.type
    };
  }
}
class Provider extends events.EventEmitter {
  async first() {
    const accounts = await this.getAccounts();
    return accounts.length ? accounts[0] : void 0;
  }
}

exports.Account = Account;
exports.Accounts = Accounts;
exports.KeyringAccountBase = KeyringAccountBase;
exports.Provider = Provider;
exports.SignatureType = SignatureType;
exports.generateAccount = generateAccount;
exports.getAccountFromMnemonic = getAccountFromMnemonic;
exports.getAddressFromSubstrate = getAddressFromSubstrate;
