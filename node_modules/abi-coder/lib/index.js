"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Coder = void 0;
var abi_1 = require("@ethersproject/abi");
var keccak256_1 = require("@ethersproject/keccak256");
var strings_1 = require("@ethersproject/strings");
var Coder = /** @class */ (function () {
    function Coder(abi) {
        Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abi = abi;
    }
    Object.defineProperty(Coder.prototype, "getFunctionSelector", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            var func = this.getFunctionByName(name);
            var jsonInputs = func === null || func === void 0 ? void 0 : func.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var signature = Coder.getSignature(name, inputs);
            var hash = sha3(signature);
            return hash.substring(0, 10);
        }
    });
    Object.defineProperty(Coder.prototype, "getEventTopic", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            var event = this.getEventByName(name);
            var jsonInputs = event === null || event === void 0 ? void 0 : event.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var signature = Coder.getSignature(name, inputs);
            return sha3(signature);
        }
    });
    Object.defineProperty(Coder.prototype, "decodeConstructor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (data) {
            var constructor = this.getConstructor();
            var jsonInputs = constructor === null || constructor === void 0 ? void 0 : constructor.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var result = abi_1.defaultAbiCoder.decode(inputs, data);
            var values = toValueMap(result, inputs);
            return {
                inputs: inputs,
                values: values,
            };
        }
    });
    Object.defineProperty(Coder.prototype, "decodeEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (topics, data) {
            var event = this.getEventByTopic(topics[0]);
            var dataTopics = topics.slice(1);
            var jsonInputs = event === null || event === void 0 ? void 0 : event.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            // Decode topics
            var topicInputs = inputs.filter(function (input) { return input.indexed; });
            var topicResult = topicInputs.map(function (input, index) {
                var topic = dataTopics[index];
                var params = abi_1.defaultAbiCoder.decode([input], topic);
                var param = params[0];
                return param;
            });
            // Decode data
            var dataInputs = inputs.filter(function (input) { return !input.indexed; });
            var dataResult = abi_1.defaultAbiCoder.decode(dataInputs, data);
            // Concat
            if (!event.name) {
                throw Error;
            }
            var topicIndex = 0;
            var dataIndex = 0;
            var result = [];
            for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                var input = inputs_1[_i];
                if (input.indexed) {
                    result.push(topicResult[topicIndex]);
                    topicIndex++;
                }
                else {
                    result.push(dataResult[dataIndex]);
                    dataIndex++;
                }
            }
            var values = toValueMap(result, inputs);
            return {
                name: event.name,
                inputs: inputs,
                values: values,
            };
        }
    });
    Object.defineProperty(Coder.prototype, "decodeFunction", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (data) {
            var selector = data.substring(0, 10);
            var func = this.getFunctionBySelector(selector);
            // Decode calldata using function inputs
            var jsonInputs = func === null || func === void 0 ? void 0 : func.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var calldata = "0x".concat(data.substring(10));
            var result = abi_1.defaultAbiCoder.decode(inputs, calldata);
            var values = toValueMap(result, inputs);
            if (!func.name) {
                throw Error;
            }
            return {
                name: func.name,
                inputs: inputs,
                values: values,
            };
        }
    });
    Object.defineProperty(Coder.prototype, "decodeFunctionOutput", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, data) {
            var func = this.getFunctionByName(name);
            var jsonOutputs = func === null || func === void 0 ? void 0 : func.outputs;
            if (!jsonOutputs) {
                throw Error;
            }
            var outputs = jsonOutputs.map(function (output) { return abi_1.ParamType.fromObject(output); });
            var result = abi_1.defaultAbiCoder.decode(outputs, data);
            var values = toValueMap(result, outputs);
            return {
                name: name,
                outputs: outputs,
                values: values,
            };
        }
    });
    Object.defineProperty(Coder.prototype, "encodeConstructor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (valueMap) {
            var constructor = this.getConstructor();
            var jsonInputs = constructor === null || constructor === void 0 ? void 0 : constructor.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var values = toValues(valueMap, inputs);
            return abi_1.defaultAbiCoder.encode(inputs, values);
        }
    });
    Object.defineProperty(Coder.prototype, "encodeEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, values) {
            var event = this.getEventByName(name);
            var jsonInputs = event === null || event === void 0 ? void 0 : event.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var eventSignature = Coder.getSignature(name, inputs);
            var eventTopic = sha3(eventSignature);
            // Group params by type
            var topicResult = [];
            var dataResult = [];
            for (var i = 0; i < inputs.length; i++) {
                var input = inputs[i];
                var value = values[input.name];
                if (input.indexed) {
                    topicResult.push(value);
                }
                else {
                    dataResult.push(value);
                }
            }
            // Encode topic params
            var topicInputs = inputs.filter(function (input) { return input.indexed; });
            var dataTopics = topicInputs.map(function (input, index) {
                return abi_1.defaultAbiCoder.encode([input], [topicResult[index]]);
            });
            var topics = __spreadArray([eventTopic], dataTopics, true);
            // Encode data params
            var dataInputs = inputs.filter(function (input) { return !input.indexed; });
            var data = abi_1.defaultAbiCoder.encode(dataInputs, dataResult);
            return {
                topics: topics,
                data: data,
            };
        }
    });
    Object.defineProperty(Coder.prototype, "encodeFunction", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, valueMap) {
            var func = this.getFunctionByName(name);
            var jsonInputs = func === null || func === void 0 ? void 0 : func.inputs;
            if (!jsonInputs) {
                throw Error;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var signature = Coder.getSignature(name, inputs);
            var selector = sha3(signature).substring(2, 10);
            var values = toValues(valueMap, inputs);
            var argumentString = abi_1.defaultAbiCoder.encode(inputs, values);
            var argumentData = argumentString.substring(2);
            var inputData = "0x".concat(selector).concat(argumentData);
            return inputData;
        }
    });
    Object.defineProperty(Coder.prototype, "encodeFunctionOutput", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, valueMap) {
            var func = this.getFunctionByName(name);
            var jsonOutputs = func.outputs;
            if (!jsonOutputs) {
                throw Error;
            }
            var outputs = jsonOutputs.map(function (output) { return abi_1.ParamType.fromObject(output); });
            var values = toValues(valueMap, outputs);
            return abi_1.defaultAbiCoder.encode(outputs, values);
        }
    });
    Object.defineProperty(Coder.prototype, "getConstructor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var constructor = this.abi.find(function (item) { return item.type === 'constructor'; });
            if (!constructor) {
                throw Error;
            }
            return constructor;
        }
    });
    Object.defineProperty(Coder.prototype, "getFunctionByName", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            var func = this.abi.find(function (item) { return item.type === 'function' && item.name === name; });
            if (!func) {
                throw Error;
            }
            return func;
        }
    });
    Object.defineProperty(Coder.prototype, "getFunctionBySelector", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (selector) {
            var functions = this.abi.filter(function (item) { return item.type === 'function' || item.type === 'error'; });
            var func = functions.find(function (func) {
                var name = func.name;
                var jsonInputs = func.inputs;
                if (!name || !jsonInputs) {
                    return false;
                }
                var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
                var signature = Coder.getSignature(name, inputs);
                var hash = sha3(signature);
                var funcSelector = hash.substring(0, 10);
                return funcSelector === selector;
            });
            if (!func) {
                throw Error;
            }
            return func;
        }
    });
    Object.defineProperty(Coder.prototype, "getEventByName", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            var event = this.abi.find(function (item) { return item.type === 'event' && item.name === name; });
            if (!event) {
                throw Error;
            }
            return event;
        }
    });
    Object.defineProperty(Coder.prototype, "getEventByTopic", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (topic) {
            var events = this.abi.filter(function (item) { return item.type === 'event'; });
            var event = events.find(function (event) {
                var name = event.name;
                var jsonInputs = event.inputs;
                if (!name || !jsonInputs) {
                    return false;
                }
                var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
                var signature = Coder.getSignature(name, inputs);
                var eventTopic = sha3(signature);
                return eventTopic === topic;
            });
            if (!event) {
                throw Error;
            }
            return event;
        }
    });
    Object.defineProperty(Coder, "getSignature", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, inputs) {
            var types = [];
            for (var _i = 0, inputs_2 = inputs; _i < inputs_2.length; _i++) {
                var input = inputs_2[_i];
                if (input.type.startsWith('tuple')) {
                    var tupleString = Coder.getSignature('', input.components);
                    var arrayArityString = input.type.substring('tuple'.length);
                    var type = "".concat(tupleString).concat(arrayArityString);
                    types.push(type);
                }
                else {
                    types.push(input.type);
                }
            }
            var typeString = types.join(',');
            var functionSignature = "".concat(name, "(").concat(typeString, ")");
            return functionSignature;
        }
    });
    return Coder;
}());
exports.Coder = Coder;
function sha3(input) {
    return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(input));
}
function toValueMap(values, inputs) {
    return Object.fromEntries(values.map(function (value, index) {
        var input = inputs[index];
        return [input.name, value];
    }));
}
function toValues(valueMap, inputs) {
    return inputs.map(function (input) {
        return valueMap[input.name];
    });
}
//# sourceMappingURL=index.js.map