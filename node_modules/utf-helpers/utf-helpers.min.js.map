{"version":3,"sources":["../index.ts"],"sourcesContent":["export const HexString = {\n  fromArray: (bytes: number[] | Uint8Array) => {\n    if (!(bytes instanceof Uint8Array) && !Array.isArray(bytes)) {\n      throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes}, ${bytes}`)\n    }\n    const arr = bytes instanceof Uint8Array ? Array.from(bytes) : bytes\n    return '0x' + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n  },\n  fromU8a: (bytes: number[] | Uint8Array) => HexString.fromArray(bytes),\n  toArray(hexString: string): number[] {\n    if (typeof hexString !== 'string') {\n      throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`)\n    }\n\n    const str: string = hexString.startsWith('0x') ? hexString.slice(2) : hexString\n    const pairs: RegExpMatchArray = str.match(/.{1,2}/g) || []\n    return pairs.map((byte) => parseInt(byte, 16))\n  },\n  toU8a: (hexString: string): Uint8Array => Uint8Array.from(HexString.toArray(hexString)),\n}\n\n\nexport const Utf8 = {\n  stringToU8a(str: string): Uint8Array {\n    const u8a = new Uint8Array(Utf8.lengthInBytes(str))\n\n    let offset = 0\n    const start = offset\n    let c1: number = 0 // character 1\n    let c2: number = 0 // character 2\n\n    let i = 0\n\n    while (i < str.length) {\n      c1 = str.charCodeAt(i)\n      if (c1 < 128) {\n        u8a[offset++] = c1\n      } else if (c1 < 2048) {\n        u8a[offset++] = c1 >> 6 | 192\n        u8a[offset++] = c1 & 63 | 128\n      } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = str.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n        c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n        ++i\n        u8a[offset++] = c1 >> 18 | 240\n        u8a[offset++] = c1 >> 12 & 63 | 128\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      } else {\n        u8a[offset++] = c1 >> 12 | 224\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      }\n\n      i += 1\n    }\n    const diff = offset - start\n\n    return u8a\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf8.stringToU8a(str))\n  },\n  u8aToString(u8a: Uint8Array): string {\n    let start = 0\n    let end = u8a.length\n\n    if (end - start < 1) {\n      return \"\"\n    }\n\n    let str = \"\"\n\n    let i = start\n\n    while (i < end) {\n      const t = u8a[i++]\n      if (t <= 0x7F) {\n        str += String.fromCharCode(t);\n      } else if (t >= 0xC0 && t < 0xE0) {\n        str += String.fromCharCode((t & 0x1F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xE0 && t < 0xF0) {\n        str += String.fromCharCode((t & 0xF) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xF0) {\n        const t2 = ((t & 7) << 18 | (u8a[i++] & 0x3F) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F) - 0x10000\n        str += String.fromCharCode(0xD800 + (t2 >> 10))\n        str += String.fromCharCode(0xDC00 + (t2 & 0x3FF))\n      }\n    }\n\n    return str\n  },\n  numberArrayToString(arr: number[] | Uint8Array): string {\n    return Utf8.u8aToString(Uint8Array.from(arr))\n  },\n  stringToHexString(str: string): string {\n    return HexString.fromU8a(Utf8.stringToU8a(str))\n  },\n  hexStringToString(hexString: string): string {\n    return Utf8.u8aToString(HexString.toU8a(hexString))\n  },\n  lengthInBytes(str: string): number {\n    let len = 0\n    let c = 0\n\n    let i = 0\n\n    while (i < str.length) {\n      c = str.charCodeAt(i) as number\n      if (c < 128) {\n        len += 1\n      } else if (c < 2048) {\n        len += 2\n      } else if ((c & 0xFC00) === 0xD800 && ((str.charCodeAt(i + 1) as number) & 0xFC00) === 0xDC00) {\n        ++i\n        len += 4\n      } else {\n        len += 3\n      }\n\n      i += 1\n    }\n    return len\n  },\n}\n\n\nexport const Utf16 = {\n  stringToU16a(str: string): Uint16Array {\n    const u16arr = new Uint16Array(Utf16.lengthInBytes(str))\n\n    let i = 0\n\n    while (i < str.length) {\n      let cp = str.codePointAt(i) as number\n\n      if (cp <= 0xFFFF) {\n        u16arr[i++] = cp\n      } else {\n        cp -= 0x10000\n        u16arr[i++] = (cp >> 10) + 0xD800\n        u16arr[i++] = (cp % 0x400) + 0xDC00\n      }\n    }\n    return u16arr\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf16.stringToU16a(str))\n  },\n  numberArrayToString(arr: number[] | Uint16Array) {\n    let i = 0\n    const len = arr.length\n    let s = ''\n\n    while (i < len - 1) {\n      const c1 = arr[i]\n      const c2 = arr[i + 1]\n\n      if (c1 >= 0xD800 && c1 <= 0xDFFF) {\n        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {\n          s += String.fromCodePoint((c1 - 0xD800) * 0x400 + c2 - 0xDC00 + 0x10000)\n          i += 2\n        } else {\n          throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`)\n        }\n      } else {\n        s += String.fromCodePoint(c1)\n        i += 1\n      }\n    }\n\n    if (i < len) {\n      s += String.fromCodePoint(arr[len - 1])\n    }\n\n    return s\n  },\n  u16aToString(arr: number[] | Uint16Array): string {\n    return Utf16.numberArrayToString(arr)\n  },\n  lengthInBytes(str: string): number {\n    let i = 0\n\n    while (i < str.length) {\n      i += (str.codePointAt(i) as number <= 0xFFFF) ? 1 : 2\n    }\n\n    return i\n  },\n}\n\nexport const UtfHelpers = {\n  HexString,\n  Utf8,\n  Utf16,\n}\n"],"mappings":"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","names":["utf_helpers_exports","__export","HexString","Utf16","Utf8","UtfHelpers","bytes","arr","str","byte","hexString","u8a","offset","start","c1","c2","i","diff","end","t","t2","len","c","u16arr","cp","s"]}