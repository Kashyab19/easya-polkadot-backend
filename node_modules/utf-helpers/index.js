"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var utf_helpers_exports = {};
__export(utf_helpers_exports, {
  HexString: () => HexString,
  Utf16: () => Utf16,
  Utf8: () => Utf8,
  UtfHelpers: () => UtfHelpers
});
module.exports = __toCommonJS(utf_helpers_exports);
var HexString = {
  fromArray: (bytes) => {
    if (!(bytes instanceof Uint8Array) && !Array.isArray(bytes)) {
      throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes}, ${bytes}`);
    }
    const arr = bytes instanceof Uint8Array ? Array.from(bytes) : bytes;
    return "0x" + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  },
  fromU8a: (bytes) => HexString.fromArray(bytes),
  toArray(hexString) {
    if (typeof hexString !== "string") {
      throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`);
    }
    const str = hexString.startsWith("0x") ? hexString.slice(2) : hexString;
    const pairs = str.match(/.{1,2}/g) || [];
    return pairs.map((byte) => parseInt(byte, 16));
  },
  toU8a: (hexString) => Uint8Array.from(HexString.toArray(hexString))
};
var Utf8 = {
  stringToU8a(str) {
    const u8a = new Uint8Array(Utf8.lengthInBytes(str));
    let offset = 0;
    const start = offset;
    let c1 = 0;
    let c2 = 0;
    let i = 0;
    while (i < str.length) {
      c1 = str.charCodeAt(i);
      if (c1 < 128) {
        u8a[offset++] = c1;
      } else if (c1 < 2048) {
        u8a[offset++] = c1 >> 6 | 192;
        u8a[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = str.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        u8a[offset++] = c1 >> 18 | 240;
        u8a[offset++] = c1 >> 12 & 63 | 128;
        u8a[offset++] = c1 >> 6 & 63 | 128;
        u8a[offset++] = c1 & 63 | 128;
      } else {
        u8a[offset++] = c1 >> 12 | 224;
        u8a[offset++] = c1 >> 6 & 63 | 128;
        u8a[offset++] = c1 & 63 | 128;
      }
      i += 1;
    }
    const diff = offset - start;
    return u8a;
  },
  stringToNumberArray(str) {
    return Array.from(Utf8.stringToU8a(str));
  },
  u8aToString(u8a) {
    let start = 0;
    let end = u8a.length;
    if (end - start < 1) {
      return "";
    }
    let str = "";
    let i = start;
    while (i < end) {
      const t = u8a[i++];
      if (t <= 127) {
        str += String.fromCharCode(t);
      } else if (t >= 192 && t < 224) {
        str += String.fromCharCode((t & 31) << 6 | u8a[i++] & 63);
      } else if (t >= 224 && t < 240) {
        str += String.fromCharCode((t & 15) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63);
      } else if (t >= 240) {
        const t2 = ((t & 7) << 18 | (u8a[i++] & 63) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63) - 65536;
        str += String.fromCharCode(55296 + (t2 >> 10));
        str += String.fromCharCode(56320 + (t2 & 1023));
      }
    }
    return str;
  },
  numberArrayToString(arr) {
    return Utf8.u8aToString(Uint8Array.from(arr));
  },
  stringToHexString(str) {
    return HexString.fromU8a(Utf8.stringToU8a(str));
  },
  hexStringToString(hexString) {
    return Utf8.u8aToString(HexString.toU8a(hexString));
  },
  lengthInBytes(str) {
    let len = 0;
    let c = 0;
    let i = 0;
    while (i < str.length) {
      c = str.charCodeAt(i);
      if (c < 128) {
        len += 1;
      } else if (c < 2048) {
        len += 2;
      } else if ((c & 64512) === 55296 && (str.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else {
        len += 3;
      }
      i += 1;
    }
    return len;
  }
};
var Utf16 = {
  stringToU16a(str) {
    const u16arr = new Uint16Array(Utf16.lengthInBytes(str));
    let i = 0;
    while (i < str.length) {
      let cp = str.codePointAt(i);
      if (cp <= 65535) {
        u16arr[i++] = cp;
      } else {
        cp -= 65536;
        u16arr[i++] = (cp >> 10) + 55296;
        u16arr[i++] = cp % 1024 + 56320;
      }
    }
    return u16arr;
  },
  stringToNumberArray(str) {
    return Array.from(Utf16.stringToU16a(str));
  },
  numberArrayToString(arr) {
    let i = 0;
    const len = arr.length;
    let s = "";
    while (i < len - 1) {
      const c1 = arr[i];
      const c2 = arr[i + 1];
      if (c1 >= 55296 && c1 <= 57343) {
        if (c2 >= 56320 && c2 <= 57343) {
          s += String.fromCodePoint((c1 - 55296) * 1024 + c2 - 56320 + 65536);
          i += 2;
        } else {
          throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`);
        }
      } else {
        s += String.fromCodePoint(c1);
        i += 1;
      }
    }
    if (i < len) {
      s += String.fromCodePoint(arr[len - 1]);
    }
    return s;
  },
  u16aToString(arr) {
    return Utf16.numberArrayToString(arr);
  },
  lengthInBytes(str) {
    let i = 0;
    while (i < str.length) {
      i += str.codePointAt(i) <= 65535 ? 1 : 2;
    }
    return i;
  }
};
var UtfHelpers = {
  HexString,
  Utf8,
  Utf16
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HexString,
  Utf16,
  Utf8,
  UtfHelpers
});
//# sourceMappingURL=index.js.map