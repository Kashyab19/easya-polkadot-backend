{"version":3,"sources":["../index.ts"],"sourcesContent":["export const HexString = {\n  fromArray: (bytes: number[] | Uint8Array) => {\n    if (!(bytes instanceof Uint8Array) && !Array.isArray(bytes)) {\n      throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes}, ${bytes}`)\n    }\n    const arr = bytes instanceof Uint8Array ? Array.from(bytes) : bytes\n    return '0x' + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n  },\n  fromU8a: (bytes: number[] | Uint8Array) => HexString.fromArray(bytes),\n  toArray(hexString: string): number[] {\n    if (typeof hexString !== 'string') {\n      throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`)\n    }\n\n    const str: string = hexString.startsWith('0x') ? hexString.slice(2) : hexString\n    const pairs: RegExpMatchArray = str.match(/.{1,2}/g) || []\n    return pairs.map((byte) => parseInt(byte, 16))\n  },\n  toU8a: (hexString: string): Uint8Array => Uint8Array.from(HexString.toArray(hexString)),\n}\n\n\nexport const Utf8 = {\n  stringToU8a(str: string): Uint8Array {\n    const u8a = new Uint8Array(Utf8.lengthInBytes(str))\n\n    let offset = 0\n    const start = offset\n    let c1: number = 0 // character 1\n    let c2: number = 0 // character 2\n\n    let i = 0\n\n    while (i < str.length) {\n      c1 = str.charCodeAt(i)\n      if (c1 < 128) {\n        u8a[offset++] = c1\n      } else if (c1 < 2048) {\n        u8a[offset++] = c1 >> 6 | 192\n        u8a[offset++] = c1 & 63 | 128\n      } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = str.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n        c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n        ++i\n        u8a[offset++] = c1 >> 18 | 240\n        u8a[offset++] = c1 >> 12 & 63 | 128\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      } else {\n        u8a[offset++] = c1 >> 12 | 224\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      }\n\n      i += 1\n    }\n    const diff = offset - start\n\n    return u8a\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf8.stringToU8a(str))\n  },\n  u8aToString(u8a: Uint8Array): string {\n    let start = 0\n    let end = u8a.length\n\n    if (end - start < 1) {\n      return \"\"\n    }\n\n    let str = \"\"\n\n    let i = start\n\n    while (i < end) {\n      const t = u8a[i++]\n      if (t <= 0x7F) {\n        str += String.fromCharCode(t);\n      } else if (t >= 0xC0 && t < 0xE0) {\n        str += String.fromCharCode((t & 0x1F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xE0 && t < 0xF0) {\n        str += String.fromCharCode((t & 0xF) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xF0) {\n        const t2 = ((t & 7) << 18 | (u8a[i++] & 0x3F) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F) - 0x10000\n        str += String.fromCharCode(0xD800 + (t2 >> 10))\n        str += String.fromCharCode(0xDC00 + (t2 & 0x3FF))\n      }\n    }\n\n    return str\n  },\n  numberArrayToString(arr: number[] | Uint8Array): string {\n    return Utf8.u8aToString(Uint8Array.from(arr))\n  },\n  stringToHexString(str: string): string {\n    return HexString.fromU8a(Utf8.stringToU8a(str))\n  },\n  hexStringToString(hexString: string): string {\n    return Utf8.u8aToString(HexString.toU8a(hexString))\n  },\n  lengthInBytes(str: string): number {\n    let len = 0\n    let c = 0\n\n    let i = 0\n\n    while (i < str.length) {\n      c = str.charCodeAt(i) as number\n      if (c < 128) {\n        len += 1\n      } else if (c < 2048) {\n        len += 2\n      } else if ((c & 0xFC00) === 0xD800 && ((str.charCodeAt(i + 1) as number) & 0xFC00) === 0xDC00) {\n        ++i\n        len += 4\n      } else {\n        len += 3\n      }\n\n      i += 1\n    }\n    return len\n  },\n}\n\n\nexport const Utf16 = {\n  stringToU16a(str: string): Uint16Array {\n    const u16arr = new Uint16Array(Utf16.lengthInBytes(str))\n\n    let i = 0\n\n    while (i < str.length) {\n      let cp = str.codePointAt(i) as number\n\n      if (cp <= 0xFFFF) {\n        u16arr[i++] = cp\n      } else {\n        cp -= 0x10000\n        u16arr[i++] = (cp >> 10) + 0xD800\n        u16arr[i++] = (cp % 0x400) + 0xDC00\n      }\n    }\n    return u16arr\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf16.stringToU16a(str))\n  },\n  numberArrayToString(arr: number[] | Uint16Array) {\n    let i = 0\n    const len = arr.length\n    let s = ''\n\n    while (i < len - 1) {\n      const c1 = arr[i]\n      const c2 = arr[i + 1]\n\n      if (c1 >= 0xD800 && c1 <= 0xDFFF) {\n        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {\n          s += String.fromCodePoint((c1 - 0xD800) * 0x400 + c2 - 0xDC00 + 0x10000)\n          i += 2\n        } else {\n          throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`)\n        }\n      } else {\n        s += String.fromCodePoint(c1)\n        i += 1\n      }\n    }\n\n    if (i < len) {\n      s += String.fromCodePoint(arr[len - 1])\n    }\n\n    return s\n  },\n  u16aToString(arr: number[] | Uint16Array): string {\n    return Utf16.numberArrayToString(arr)\n  },\n  lengthInBytes(str: string): number {\n    let i = 0\n\n    while (i < str.length) {\n      i += (str.codePointAt(i) as number <= 0xFFFF) ? 1 : 2\n    }\n\n    return i\n  },\n}\n\nexport const UtfHelpers = {\n  HexString,\n  Utf8,\n  Utf16,\n}\n"],"mappings":"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","names":[]}