{"version":3,"sources":["../../src/coin.ts"],"sourcesContent":["export const DEFAULT_DECIMALS = 18\n\nconst validateDecimals = (decimals: any): decimals is number => {\n  if (typeof decimals !== 'number') throw new Error('Invalid decimals, must be a number')\n  if (decimals < 1 || decimals > 18) throw new Error('Invalid decimals, must be between 0 and 18')\n  return true\n}\n\nexport const coinToWeiInBigInt = (value: string | number, decimals: number = DEFAULT_DECIMALS): bigint => {\n  value = value.toString()\n\n  //test that value is string of positive number\n  if (!/^\\d+(\\.\\d+)?$/.test(value)) {\n    throw new Error('Invalid value')\n  }\n  validateDecimals(decimals)\n\n  // Define the multiplier as a BigInt\n  const multiplier = 10n ** BigInt(decimals)\n\n  // Convert the integer part and fractional part separately\n  let [integerPart, fractionalPart = ''] = value.split('.')\n\n  // Ensure the fractional part is not longer than decimals digits\n  fractionalPart = fractionalPart.padEnd(decimals, '0').slice(0, decimals)\n\n  // Combine the integer and fractional parts\n  const weiValue = BigInt(integerPart) * multiplier + BigInt(fractionalPart)\n\n  return weiValue\n}\n\nexport const coinToWei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return coinToWeiInBigInt(value, decimals).toString()\n}\n\nexport const weiToCoin = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  validateDecimals(decimals)\n\n  const weiBigInt = BigInt(weiValue)\n  const divisor = 10n ** BigInt(decimals)\n\n  // Divide the Wei amount by the divisor to get the Ether amount\n  const ethAmountBigInt = weiBigInt / divisor\n  const remainder = weiBigInt % divisor\n\n  // Determine how many digits to keep based on the Ether amount\n  // let digits = 0\n  // const ethAmount = Number(ethAmountBigInt) + (remainder > 0 ? Number(remainder) / 10 ** decimals : 0)\n  // if (ethAmount < 0.1) digits = 6\n  // else if (ethAmount < 1) digits = 4\n  // else if (ethAmount < 10) digits = 3\n  // else if (ethAmount < 100) digits = 2\n  // else if (ethAmount < 100000) digits = 1\n  // For amounts >= 100000, digits remain 0 for integer values\n\n  // Format the fractional part based on the determined digits\n  const remainderStr = remainder.toString()\n    .padStart(decimals, '0')\n  // .substring(0, digits)\n\n  // Remove trailing zeros from the remainder\n  const formattedRemainder = remainderStr.replace(/0+$/, '')\n\n  // Combine the integer part and the fractional part\n  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? '.' + formattedRemainder : ''}`\n\n  return formattedEthAmount\n}\n\nexport const dangerouslyWeiToCoinInFloat = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): number =>\n  parseFloat(weiToCoin(weiValue, decimals))\n\nexport const formatNice = (value: string | number, formattingThreshold: number = 100_000): string => {\n  const numStr = typeof value === 'string' ? value : value.toString()\n  const roughNum = parseFloat(numStr)\n  if (isNaN(roughNum)) throw new Error(`Coin.format: Invalid number: ${numStr}`)\n\n  if (formattingThreshold === -1) {\n    return numStr\n  }\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  const integerNum = parseInt(integerPart)\n\n  if (integerNum < formattingThreshold) {\n    if (!fractionalPart) return numStr\n\n    const roughRemainder = parseFloat(`0.${fractionalPart}`)\n    let digits = 0\n    if (roughRemainder < 0.1) digits = 6\n    else if (integerNum < 1) digits = 4\n    else if (integerNum < 10) digits = 3\n    else if (integerNum < 10000) digits = 2\n    else if (integerNum < 100000) digits = 1\n    // For amounts >= 100000, digits remain 0 for integer values\n\n    let fractionalPadded = fractionalPart\n      .substring(0, digits)\n    if (fractionalPadded.length < 2 && digits >= 2) fractionalPadded = fractionalPadded.padEnd(2, '0')\n\n    // if fractional part contains only zeroes, remove it\n    if (fractionalPadded.replace(/0/g, '') === '') return integerPart\n    if (!fractionalPadded) return integerPart\n    return `${integerPart}.${fractionalPadded}`\n  }\n\n  const suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"]\n  const i = integerNum === 0\n    ? 0\n    // 6.907... is Math.log(1000), 4 is max index of suffixes\n    : Math.min(Math.floor(Math.log(integerNum) / 6.907755278982137), 4)\n\n  const [integerPartOfNice, fractionalPartOfNice = ''] = (integerNum / Math.pow(1000, i)).toString().split('.')\n  const formatted = integerPartOfNice +\n    (fractionalPartOfNice.length > 0 ? '.' + fractionalPartOfNice.slice(0, 3) : '')\n\n  return `${formatted}${suffixes[i]}`\n}\n\nexport const formatFixed = (value: string | number, precision: number = 3): string => {\n  const numStr = value.toString()\n  if (precision === -1) return numStr\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  if (!fractionalPart) return numStr\n\n  return `${integerPart}.${fractionalPart.substring(0, precision).padEnd(precision, '0')}`\n}\n\nexport const weiFormatNice = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, formattingThreshold = 100_000): string => {\n  return formatNice(weiToCoin(weiValue, decimals), formattingThreshold)\n}\n\nexport const weiFormatFixed = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, precision: number = 3): string => {\n  return formatFixed(weiToCoin(weiValue, decimals), precision)\n}\n\nexport const weiToGwei = (gwei: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const weiBigInt = BigInt(gwei)\n  if (weiBigInt < 0n) throw new Error('Invalid gwei value')\n  const divisor = 10n ** (BigInt(decimals) / 2n)\n  const [integerPart, fractionalPart = ''] = [\n    (weiBigInt / divisor).toString(),\n    (weiBigInt % divisor).toString().padStart(decimals / 2, '0').replace(/0+$/, '')\n  ]\n  if (!fractionalPart) return integerPart\n  return `${integerPart}.${fractionalPart}`\n}\n\nexport const gweiToWei = (gwei: string | number | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const multiplier = 10n ** (BigInt(decimals) / 2n)\n\n  const [integerPart, fractionalPart = ''] = gwei.toString().split('.')\n  if (BigInt(integerPart) < 0n) throw new Error('Invalid gwei value - must be positive')\n  const gweiIntegerPartInWei = BigInt(integerPart) * multiplier\n  if (!fractionalPart) return gweiIntegerPartInWei.toString()\n\n  const fractionalPartStr = fractionalPart.padEnd(decimals / 2, '0').slice(0, decimals / 2)\n\n  const weiValue = gweiIntegerPartInWei + BigInt(fractionalPartStr)\n  return weiValue.toString()\n}\n\nexport const coinToGwei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToGwei(coinToWei(value, decimals), decimals)\n}\n\nexport const gweiToCoin = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToCoin(gweiToWei(value, decimals), decimals)\n}\n\nexport const cleanUpCoinsValue = (value: string | number): string => {\n  return value.toString().trim().replace(/\\.?0+$/, '')\n}\n\nexport const Coin = (\n  currency: string,\n  decimals: number = DEFAULT_DECIMALS,\n  precision: number = 3,\n  formattingThreshold: number = 100_000\n) => {\n  if (typeof currency as any !== 'string') throw new Error('Invalid currency, must be a string')\n  validateDecimals(decimals)\n  const paddedCurrency = currency.trim() === '' ? '' : ` ${currency.trim()}`\n\n  return {\n    coinToWeiInBigInt: (value: string): bigint => coinToWeiInBigInt(value, decimals),\n    coinToWei: (value: string): string => coinToWei(value, decimals),\n    weiToCoin: (value: string | bigint): string => weiToCoin(value, decimals),\n\n    dangerouslyWeiToCoinInFloat: (value: string | bigint): number => dangerouslyWeiToCoinInFloat(value, decimals),\n\n    formatNice: (value: string): string => formatNice(value, formattingThreshold) + paddedCurrency,\n    formatMetric: (value: string): string => formatNice(value, formattingThreshold),\n    formatFixed: (value: string | number, _precision = precision): string => formatFixed(value, _precision) + paddedCurrency,\n    formatFixedClean: (value: string | number, _precision = precision): string => formatFixed(value, _precision),\n    weiFormatNice: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold) + paddedCurrency,\n    weiFormatMetric: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold),\n    weiFormatFixed: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision) + paddedCurrency,\n    weiFormatFixedClean: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision),\n\n    gwei: {\n      gweiToWei: (value: string | number | bigint): string => gweiToWei(value, decimals),\n      weiToGwei: (value: string | bigint): string => weiToGwei(value, decimals),\n      gweiToCoin: (value: string | number): string => gweiToCoin(value, decimals),\n      coinToGwei: (value: string | number): string => coinToGwei(value, decimals),\n    },\n\n    inAllFormats: (value: string | number, _precision = precision): ICoinFormats => {\n      const wei = coinToWei(value, decimals)\n      const coins = cleanUpCoinsValue(value)\n      const metric = formatNice(value, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: formatFixed(value, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei,\n      }\n    },\n\n    weiInAllFormats: (wei: string | bigint, _precision = precision): ICoinFormats => {\n      const coins = weiToCoin(wei, decimals)\n      const metric = weiFormatNice(wei, decimals, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: weiFormatFixed(wei, decimals, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei: wei.toString(),\n      }\n    }\n  }\n}\n\nexport type ICoinFormats = {\n  value: string\n  metric: string\n  nice: string\n  fixed: string\n  exact: string\n  currency: string\n  wei: string\n}\n\nexport type ICoin = ReturnType<typeof Coin>\n"],"mappings":"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","names":["coin_exports","__export","Coin","DEFAULT_DECIMALS","cleanUpCoinsValue","coinToGwei","coinToWei","coinToWeiInBigInt","dangerouslyWeiToCoinInFloat","formatFixed","formatNice","gweiToCoin","gweiToWei","weiFormatFixed","weiFormatNice","weiToCoin","weiToGwei","validateDecimals","decimals","value","multiplier","integerPart","fractionalPart","weiValue","weiBigInt","divisor","ethAmountBigInt","formattedRemainder","formattingThreshold","numStr","roughNum","integerNum","roughRemainder","digits","fractionalPadded","suffixes","i","integerPartOfNice","fractionalPartOfNice","precision","gwei","gweiIntegerPartInWei","fractionalPartStr","currency","paddedCurrency","_precision","wei","coins","metric"]}