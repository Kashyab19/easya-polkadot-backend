{"version":3,"sources":["../src/coin.ts"],"sourcesContent":["export const DEFAULT_DECIMALS = 18\n\nconst validateDecimals = (decimals: any): decimals is number => {\n  if (typeof decimals !== 'number') throw new Error('Invalid decimals, must be a number')\n  if (decimals < 1 || decimals > 18) throw new Error('Invalid decimals, must be between 0 and 18')\n  return true\n}\n\nexport const coinToWeiInBigInt = (value: string | number, decimals: number = DEFAULT_DECIMALS): bigint => {\n  value = value.toString()\n\n  //test that value is string of positive number\n  if (!/^\\d+(\\.\\d+)?$/.test(value)) {\n    throw new Error('Invalid value')\n  }\n  validateDecimals(decimals)\n\n  // Define the multiplier as a BigInt\n  const multiplier = 10n ** BigInt(decimals)\n\n  // Convert the integer part and fractional part separately\n  let [integerPart, fractionalPart = ''] = value.split('.')\n\n  // Ensure the fractional part is not longer than decimals digits\n  fractionalPart = fractionalPart.padEnd(decimals, '0').slice(0, decimals)\n\n  // Combine the integer and fractional parts\n  const weiValue = BigInt(integerPart) * multiplier + BigInt(fractionalPart)\n\n  return weiValue\n}\n\nexport const coinToWei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return coinToWeiInBigInt(value, decimals).toString()\n}\n\nexport const weiToCoin = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  validateDecimals(decimals)\n\n  const weiBigInt = BigInt(weiValue)\n  const divisor = 10n ** BigInt(decimals)\n\n  // Divide the Wei amount by the divisor to get the Ether amount\n  const ethAmountBigInt = weiBigInt / divisor\n  const remainder = weiBigInt % divisor\n\n  // Determine how many digits to keep based on the Ether amount\n  // let digits = 0\n  // const ethAmount = Number(ethAmountBigInt) + (remainder > 0 ? Number(remainder) / 10 ** decimals : 0)\n  // if (ethAmount < 0.1) digits = 6\n  // else if (ethAmount < 1) digits = 4\n  // else if (ethAmount < 10) digits = 3\n  // else if (ethAmount < 100) digits = 2\n  // else if (ethAmount < 100000) digits = 1\n  // For amounts >= 100000, digits remain 0 for integer values\n\n  // Format the fractional part based on the determined digits\n  const remainderStr = remainder.toString()\n    .padStart(decimals, '0')\n  // .substring(0, digits)\n\n  // Remove trailing zeros from the remainder\n  const formattedRemainder = remainderStr.replace(/0+$/, '')\n\n  // Combine the integer part and the fractional part\n  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? '.' + formattedRemainder : ''}`\n\n  return formattedEthAmount\n}\n\nexport const dangerouslyWeiToCoinInFloat = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): number =>\n  parseFloat(weiToCoin(weiValue, decimals))\n\nexport const formatNice = (value: string | number, formattingThreshold: number = 100_000): string => {\n  const numStr = typeof value === 'string' ? value : value.toString()\n  const roughNum = parseFloat(numStr)\n  if (isNaN(roughNum)) throw new Error(`Coin.format: Invalid number: ${numStr}`)\n\n  if (formattingThreshold === -1) {\n    return numStr\n  }\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  const integerNum = parseInt(integerPart)\n\n  if (integerNum < formattingThreshold) {\n    if (!fractionalPart) return numStr\n\n    const roughRemainder = parseFloat(`0.${fractionalPart}`)\n    let digits = 0\n    if (roughRemainder < 0.1) digits = 6\n    else if (integerNum < 1) digits = 4\n    else if (integerNum < 10) digits = 3\n    else if (integerNum < 10000) digits = 2\n    else if (integerNum < 100000) digits = 1\n    // For amounts >= 100000, digits remain 0 for integer values\n\n    let fractionalPadded = fractionalPart\n      .substring(0, digits)\n    if (fractionalPadded.length < 2 && digits >= 2) fractionalPadded = fractionalPadded.padEnd(2, '0')\n\n    // if fractional part contains only zeroes, remove it\n    if (fractionalPadded.replace(/0/g, '') === '') return integerPart\n    if (!fractionalPadded) return integerPart\n    return `${integerPart}.${fractionalPadded}`\n  }\n\n  const suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"]\n  const i = integerNum === 0\n    ? 0\n    // 6.907... is Math.log(1000), 4 is max index of suffixes\n    : Math.min(Math.floor(Math.log(integerNum) / 6.907755278982137), 4)\n\n  const [integerPartOfNice, fractionalPartOfNice = ''] = (integerNum / Math.pow(1000, i)).toString().split('.')\n  const formatted = integerPartOfNice +\n    (fractionalPartOfNice.length > 0 ? '.' + fractionalPartOfNice.slice(0, 3) : '')\n\n  return `${formatted}${suffixes[i]}`\n}\n\nexport const formatFixed = (value: string | number, precision: number = 3): string => {\n  const numStr = value.toString()\n  if (precision === -1) return numStr\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  if (!fractionalPart) return numStr\n\n  return `${integerPart}.${fractionalPart.substring(0, precision).padEnd(precision, '0')}`\n}\n\nexport const weiFormatNice = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, formattingThreshold = 100_000): string => {\n  return formatNice(weiToCoin(weiValue, decimals), formattingThreshold)\n}\n\nexport const weiFormatFixed = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, precision: number = 3): string => {\n  return formatFixed(weiToCoin(weiValue, decimals), precision)\n}\n\nexport const weiToGwei = (gwei: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const weiBigInt = BigInt(gwei)\n  if (weiBigInt < 0n) throw new Error('Invalid gwei value')\n  const divisor = 10n ** (BigInt(decimals) / 2n)\n  const [integerPart, fractionalPart = ''] = [\n    (weiBigInt / divisor).toString(),\n    (weiBigInt % divisor).toString().padStart(decimals / 2, '0').replace(/0+$/, '')\n  ]\n  if (!fractionalPart) return integerPart\n  return `${integerPart}.${fractionalPart}`\n}\n\nexport const gweiToWei = (gwei: string | number | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const multiplier = 10n ** (BigInt(decimals) / 2n)\n\n  const [integerPart, fractionalPart = ''] = gwei.toString().split('.')\n  if (BigInt(integerPart) < 0n) throw new Error('Invalid gwei value - must be positive')\n  const gweiIntegerPartInWei = BigInt(integerPart) * multiplier\n  if (!fractionalPart) return gweiIntegerPartInWei.toString()\n\n  const fractionalPartStr = fractionalPart.padEnd(decimals / 2, '0').slice(0, decimals / 2)\n\n  const weiValue = gweiIntegerPartInWei + BigInt(fractionalPartStr)\n  return weiValue.toString()\n}\n\nexport const coinToGwei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToGwei(coinToWei(value, decimals), decimals)\n}\n\nexport const gweiToCoin = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToCoin(gweiToWei(value, decimals), decimals)\n}\n\nexport const cleanUpCoinsValue = (value: string | number): string => {\n  return value.toString().trim().replace(/\\.?0+$/, '')\n}\n\nexport const Coin = (\n  currency: string,\n  decimals: number = DEFAULT_DECIMALS,\n  precision: number = 3,\n  formattingThreshold: number = 100_000\n) => {\n  if (typeof currency as any !== 'string') throw new Error('Invalid currency, must be a string')\n  validateDecimals(decimals)\n  const paddedCurrency = currency.trim() === '' ? '' : ` ${currency.trim()}`\n\n  return {\n    coinToWeiInBigInt: (value: string): bigint => coinToWeiInBigInt(value, decimals),\n    coinToWei: (value: string): string => coinToWei(value, decimals),\n    weiToCoin: (value: string | bigint): string => weiToCoin(value, decimals),\n\n    dangerouslyWeiToCoinInFloat: (value: string | bigint): number => dangerouslyWeiToCoinInFloat(value, decimals),\n\n    formatNice: (value: string): string => formatNice(value, formattingThreshold) + paddedCurrency,\n    formatMetric: (value: string): string => formatNice(value, formattingThreshold),\n    formatFixed: (value: string | number, _precision = precision): string => formatFixed(value, _precision) + paddedCurrency,\n    formatFixedClean: (value: string | number, _precision = precision): string => formatFixed(value, _precision),\n    weiFormatNice: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold) + paddedCurrency,\n    weiFormatMetric: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold),\n    weiFormatFixed: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision) + paddedCurrency,\n    weiFormatFixedClean: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision),\n\n    gwei: {\n      gweiToWei: (value: string | number | bigint): string => gweiToWei(value, decimals),\n      weiToGwei: (value: string | bigint): string => weiToGwei(value, decimals),\n      gweiToCoin: (value: string | number): string => gweiToCoin(value, decimals),\n      coinToGwei: (value: string | number): string => coinToGwei(value, decimals),\n    },\n\n    inAllFormats: (value: string | number, _precision = precision): ICoinFormats => {\n      const wei = coinToWei(value, decimals)\n      const coins = cleanUpCoinsValue(value)\n      const metric = formatNice(value, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: formatFixed(value, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei,\n      }\n    },\n\n    weiInAllFormats: (wei: string | bigint, _precision = precision): ICoinFormats => {\n      const coins = weiToCoin(wei, decimals)\n      const metric = weiFormatNice(wei, decimals, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: weiFormatFixed(wei, decimals, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei: wei.toString(),\n      }\n    }\n  }\n}\n\nexport type ICoinFormats = {\n  value: string\n  metric: string\n  nice: string\n  fixed: string\n  exact: string\n  currency: string\n  wei: string\n}\n\nexport type ICoin = ReturnType<typeof Coin>\n"],"mappings":"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","names":[]}