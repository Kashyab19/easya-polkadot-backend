"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/coin.ts
var coin_exports = {};
__export(coin_exports, {
  Coin: () => Coin,
  DEFAULT_DECIMALS: () => DEFAULT_DECIMALS,
  cleanUpCoinsValue: () => cleanUpCoinsValue,
  coinToGwei: () => coinToGwei,
  coinToWei: () => coinToWei,
  coinToWeiInBigInt: () => coinToWeiInBigInt,
  dangerouslyWeiToCoinInFloat: () => dangerouslyWeiToCoinInFloat,
  formatFixed: () => formatFixed,
  formatNice: () => formatNice,
  gweiToCoin: () => gweiToCoin,
  gweiToWei: () => gweiToWei,
  weiFormatFixed: () => weiFormatFixed,
  weiFormatNice: () => weiFormatNice,
  weiToCoin: () => weiToCoin,
  weiToGwei: () => weiToGwei
});
module.exports = __toCommonJS(coin_exports);
var DEFAULT_DECIMALS = 18;
var validateDecimals = (decimals) => {
  if (typeof decimals !== "number")
    throw new Error("Invalid decimals, must be a number");
  if (decimals < 1 || decimals > 18)
    throw new Error("Invalid decimals, must be between 0 and 18");
  return true;
};
var coinToWeiInBigInt = (value, decimals = DEFAULT_DECIMALS) => {
  value = value.toString();
  if (!/^\d+(\.\d+)?$/.test(value)) {
    throw new Error("Invalid value");
  }
  validateDecimals(decimals);
  const multiplier = 10n ** BigInt(decimals);
  let [integerPart, fractionalPart = ""] = value.split(".");
  fractionalPart = fractionalPart.padEnd(decimals, "0").slice(0, decimals);
  const weiValue = BigInt(integerPart) * multiplier + BigInt(fractionalPart);
  return weiValue;
};
var coinToWei = (value, decimals = DEFAULT_DECIMALS) => {
  return coinToWeiInBigInt(value, decimals).toString();
};
var weiToCoin = (weiValue, decimals = DEFAULT_DECIMALS) => {
  validateDecimals(decimals);
  const weiBigInt = BigInt(weiValue);
  const divisor = 10n ** BigInt(decimals);
  const ethAmountBigInt = weiBigInt / divisor;
  const remainder = weiBigInt % divisor;
  const remainderStr = remainder.toString().padStart(decimals, "0");
  const formattedRemainder = remainderStr.replace(/0+$/, "");
  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? "." + formattedRemainder : ""}`;
  return formattedEthAmount;
};
var dangerouslyWeiToCoinInFloat = (weiValue, decimals = DEFAULT_DECIMALS) => parseFloat(weiToCoin(weiValue, decimals));
var formatNice = (value, formattingThreshold = 1e5) => {
  const numStr = typeof value === "string" ? value : value.toString();
  const roughNum = parseFloat(numStr);
  if (isNaN(roughNum))
    throw new Error(`Coin.format: Invalid number: ${numStr}`);
  if (formattingThreshold === -1) {
    return numStr;
  }
  const [integerPart, fractionalPart = ""] = numStr.split(".");
  const integerNum = parseInt(integerPart);
  if (integerNum < formattingThreshold) {
    if (!fractionalPart)
      return numStr;
    const roughRemainder = parseFloat(`0.${fractionalPart}`);
    let digits = 0;
    if (roughRemainder < 0.1)
      digits = 6;
    else if (integerNum < 1)
      digits = 4;
    else if (integerNum < 10)
      digits = 3;
    else if (integerNum < 1e4)
      digits = 2;
    else if (integerNum < 1e5)
      digits = 1;
    let fractionalPadded = fractionalPart.substring(0, digits);
    if (fractionalPadded.length < 2 && digits >= 2)
      fractionalPadded = fractionalPadded.padEnd(2, "0");
    if (fractionalPadded.replace(/0/g, "") === "")
      return integerPart;
    if (!fractionalPadded)
      return integerPart;
    return `${integerPart}.${fractionalPadded}`;
  }
  const suffixes = ["", "K", "M", "B", "T"];
  const i = integerNum === 0 ? 0 : Math.min(Math.floor(Math.log(integerNum) / 6.907755278982137), 4);
  const [integerPartOfNice, fractionalPartOfNice = ""] = (integerNum / Math.pow(1e3, i)).toString().split(".");
  const formatted = integerPartOfNice + (fractionalPartOfNice.length > 0 ? "." + fractionalPartOfNice.slice(0, 3) : "");
  return `${formatted}${suffixes[i]}`;
};
var formatFixed = (value, precision = 3) => {
  const numStr = value.toString();
  if (precision === -1)
    return numStr;
  const [integerPart, fractionalPart = ""] = numStr.split(".");
  if (!fractionalPart)
    return numStr;
  return `${integerPart}.${fractionalPart.substring(0, precision).padEnd(precision, "0")}`;
};
var weiFormatNice = (weiValue, decimals = DEFAULT_DECIMALS, formattingThreshold = 1e5) => {
  return formatNice(weiToCoin(weiValue, decimals), formattingThreshold);
};
var weiFormatFixed = (weiValue, decimals = DEFAULT_DECIMALS, precision = 3) => {
  return formatFixed(weiToCoin(weiValue, decimals), precision);
};
var weiToGwei = (gwei, decimals = DEFAULT_DECIMALS) => {
  const weiBigInt = BigInt(gwei);
  if (weiBigInt < 0n)
    throw new Error("Invalid gwei value");
  const divisor = 10n ** (BigInt(decimals) / 2n);
  const [integerPart, fractionalPart = ""] = [
    (weiBigInt / divisor).toString(),
    (weiBigInt % divisor).toString().padStart(decimals / 2, "0").replace(/0+$/, "")
  ];
  if (!fractionalPart)
    return integerPart;
  return `${integerPart}.${fractionalPart}`;
};
var gweiToWei = (gwei, decimals = DEFAULT_DECIMALS) => {
  const multiplier = 10n ** (BigInt(decimals) / 2n);
  const [integerPart, fractionalPart = ""] = gwei.toString().split(".");
  if (BigInt(integerPart) < 0n)
    throw new Error("Invalid gwei value - must be positive");
  const gweiIntegerPartInWei = BigInt(integerPart) * multiplier;
  if (!fractionalPart)
    return gweiIntegerPartInWei.toString();
  const fractionalPartStr = fractionalPart.padEnd(decimals / 2, "0").slice(0, decimals / 2);
  const weiValue = gweiIntegerPartInWei + BigInt(fractionalPartStr);
  return weiValue.toString();
};
var coinToGwei = (value, decimals = DEFAULT_DECIMALS) => {
  return weiToGwei(coinToWei(value, decimals), decimals);
};
var gweiToCoin = (value, decimals = DEFAULT_DECIMALS) => {
  return weiToCoin(gweiToWei(value, decimals), decimals);
};
var cleanUpCoinsValue = (value) => {
  return value.toString().trim().replace(/\.?0+$/, "");
};
var Coin = (currency, decimals = DEFAULT_DECIMALS, precision = 3, formattingThreshold = 1e5) => {
  if (typeof currency !== "string")
    throw new Error("Invalid currency, must be a string");
  validateDecimals(decimals);
  const paddedCurrency = currency.trim() === "" ? "" : ` ${currency.trim()}`;
  return {
    coinToWeiInBigInt: (value) => coinToWeiInBigInt(value, decimals),
    coinToWei: (value) => coinToWei(value, decimals),
    weiToCoin: (value) => weiToCoin(value, decimals),
    dangerouslyWeiToCoinInFloat: (value) => dangerouslyWeiToCoinInFloat(value, decimals),
    formatNice: (value) => formatNice(value, formattingThreshold) + paddedCurrency,
    formatMetric: (value) => formatNice(value, formattingThreshold),
    formatFixed: (value, _precision = precision) => formatFixed(value, _precision) + paddedCurrency,
    formatFixedClean: (value, _precision = precision) => formatFixed(value, _precision),
    weiFormatNice: (value) => weiFormatNice(value, decimals, formattingThreshold) + paddedCurrency,
    weiFormatMetric: (value) => weiFormatNice(value, decimals, formattingThreshold),
    weiFormatFixed: (value, _precision = precision) => weiFormatFixed(value, decimals, _precision) + paddedCurrency,
    weiFormatFixedClean: (value, _precision = precision) => weiFormatFixed(value, decimals, _precision),
    gwei: {
      gweiToWei: (value) => gweiToWei(value, decimals),
      weiToGwei: (value) => weiToGwei(value, decimals),
      gweiToCoin: (value) => gweiToCoin(value, decimals),
      coinToGwei: (value) => coinToGwei(value, decimals)
    },
    inAllFormats: (value, _precision = precision) => {
      const wei = coinToWei(value, decimals);
      const coins = cleanUpCoinsValue(value);
      const metric = formatNice(value, formattingThreshold);
      return {
        value: coins,
        metric,
        nice: metric + paddedCurrency,
        fixed: formatFixed(value, _precision) + paddedCurrency,
        exact: coins + paddedCurrency,
        currency,
        wei
      };
    },
    weiInAllFormats: (wei, _precision = precision) => {
      const coins = weiToCoin(wei, decimals);
      const metric = weiFormatNice(wei, decimals, formattingThreshold);
      return {
        value: coins,
        metric,
        nice: metric + paddedCurrency,
        fixed: weiFormatFixed(wei, decimals, _precision) + paddedCurrency,
        exact: coins + paddedCurrency,
        currency,
        wei: wei.toString()
      };
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Coin,
  DEFAULT_DECIMALS,
  cleanUpCoinsValue,
  coinToGwei,
  coinToWei,
  coinToWeiInBigInt,
  dangerouslyWeiToCoinInFloat,
  formatFixed,
  formatNice,
  gweiToCoin,
  gweiToWei,
  weiFormatFixed,
  weiFormatNice,
  weiToCoin,
  weiToGwei
});
//# sourceMappingURL=index.js.map